<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Мессенджер</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="top-container">
        <div class="top-row">
            <div class="menu-icon">☰</div>
            <div class="avatar-small" id="top-avatar"></div>
            <div class="search-container">
                <input type="text" class="search-input" placeholder="поиск">
                <span class="clear-btn">×</span>
            </div>
        </div>
        
        <div class="user-container" id="user-container"></div>
    </div>
    
    <div class="right-container">
        <div class="default-content" id="default-content">
            <img src="https://cdn-icons-png.flaticon.com/512/5757/5757765.png" alt="Выберите чат" class="default-image">
        </div>
        
        <div class="chat-container hidden" id="chat-container">
            <div class="chat-header">
                <div class="chat-username" id="chat-username"></div>
                <div class="chat-header-info">
                    <div class="chat-status" id="chat-status"></div>
                </div>
            </div>
            <div class="chat-messages" id="chat-messages">
                <div class="no-messages">Нет сообщений</div>
            </div>
            <div class="message-input-container">
                <button class="voice-message-btn" id="voice-message-btn">
                    <img src="https://images.icon-icons.com/2066/PNG/512/mic_icon_125214.png" alt="Запись">
                </button>
                <div class="message-input-wrapper">
                    <input type="text" class="message-input" placeholder="Напишите сообщение..." id="message-input">
                    <div class="recording-container hidden" id="recording-container">
                        Запись: <span id="recording-time">0</span> сек.
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Контекстное меню -->
    <div class="context-menu" id="context-menu">
        <div class="context-menu-item add-friend hidden" id="context-menu-add">Добавить в друзья</div>
        <div class="context-menu-item remove-friend hidden" id="context-menu-remove">Удалить из друзей</div>
    </div>

    <!-- Модальное окно выхода -->
    <div class="modal-overlay hidden" id="logout-overlay"></div>
    <div class="logout-modal hidden" id="logout-modal">
        <button class="modal-close-btn" id="logout-close-btn">×</button>
        <div class="logout-text">Выйти из аккаунта</div>
        <div class="logout-buttons">
            <button class="logout-button logout-cancel" id="logout-cancel-btn">Отмена</button>
            <button class="logout-button logout-confirm" id="logout-confirm-btn">Выйти</button>
        </div>
    </div>

    <script src="eel.js"></script>
    <script>
        let currentUser = null;
        let contextMenu = null;
        let contextMenuTarget = null;
        let currentChatUserId = null;
        let lastMessageId = null;
        let activeChats = {};
        let readStatusInterval = null;
        let statusUpdateInterval = null;
        let onlineStatusInterval = null;
        let mediaRecorder = null;
        let audioChunks = [];
        let recordingStartTime = 0;
        let audioContext = null;
        let analyser = null;
        let visualizationInterval = null;
        let currentPlayingAudio = null;
        let voiceMessagePlaying = false;
        let currentPlayingVoiceElement = null;

        document.addEventListener('DOMContentLoaded', async function() {
            // Проверяем авторизацию
            const user_id = localStorage.getItem('user_id');
            if (!user_id) {
                window.location.href = 'login.html';
                return;
            }

            // Добавляем обработчик перед выгрузкой страницы
            window.addEventListener('beforeunload', function() {
                stopVoiceMessage();
                if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                    mediaRecorder.stop();
                }
            });

            // Запускаем отправку статуса онлайн
            startOnlineStatusUpdates();

            // Загружаем данные пользователя
            try {
                currentUser = await eel.get_user_data(user_id)();
                if (!currentUser) {
                    localStorage.removeItem('user_id');
                    window.location.href = 'login.html';
                    return;
                }
            } catch (error) {
                localStorage.removeItem('user_id');
                window.location.href = 'login.html';
                return;
            }

            // Устанавливаем аватар текущего пользователя
            document.getElementById('top-avatar').style.backgroundImage = 'url(https://cdn-icons-png.flaticon.com/512/3135/3135715.png)';

            // Инициализация поиска
            const searchInput = document.querySelector('.search-input');
            const clearBtn = document.querySelector('.clear-btn');
            
            searchInput.addEventListener('input', async function() {
                const searchTerm = this.value.trim();
                if (searchTerm.length > 0) {
                    const users = await eel.search_users(searchTerm, user_id)();
                    displaySearchResults(users);
                } else {
                    loadFriends();
                }
            });

            clearBtn.addEventListener('click', function() {
                searchInput.value = '';
                searchInput.focus();
                loadFriends();
            });

            // Инициализация контекстного меню
            contextMenu = document.getElementById('context-menu');
            document.addEventListener('click', closeContextMenu);
            document.getElementById('context-menu-add').addEventListener('click', handleAddFriend);
            document.getElementById('context-menu-remove').addEventListener('click', handleRemoveFriend);

            // Обработчики для меню выхода
            document.querySelector('.menu-icon').addEventListener('click', function() {
                document.getElementById('logout-overlay').classList.remove('hidden');
                document.getElementById('logout-modal').classList.remove('hidden');
            });

            document.getElementById('logout-close-btn').addEventListener('click', closeLogoutModal);
            document.getElementById('logout-cancel-btn').addEventListener('click', closeLogoutModal);
            document.getElementById('logout-overlay').addEventListener('click', closeLogoutModal);
            document.getElementById('logout-confirm-btn').addEventListener('click', function() {
                eel.update_last_online(localStorage.getItem('user_id'))();
                localStorage.removeItem('user_id');
                window.location.href = 'login.html';
            });

            // Обработчик нажатия ESC
            document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape') {
        // Если открыто модальное окно выхода - закрываем его
        if (!document.getElementById('logout-modal').classList.contains('hidden')) {
            closeLogoutModal();
            return;
        }
        
        // Если открыт чат - обрабатываем закрытие
        if (!document.getElementById('chat-container').classList.contains('hidden')) {
            // Сбрасываем currentChatUserId только если это не чат с самим собой
            if (currentChatUserId !== localStorage.getItem('user_id')) {
                currentChatUserId = null;
            }
            
            // Скрываем контейнер чата и показываем дефолтный экран
            document.getElementById('default-content').classList.remove('hidden');
            document.getElementById('chat-container').classList.add('hidden');
            
            // Убираем выделение активного чата
            document.querySelectorAll('.user-bar').forEach(el => {
                el.classList.remove('active-chat');
            });
            
            // Останавливаем воспроизведение голосовых сообщений
            stopVoiceMessage();
            currentPlayingAudio = null;
            voiceMessagePlaying = false;
            currentPlayingVoiceElement = null;
            
            // Очищаем интервалы
            if (readStatusInterval) {
                clearInterval(readStatusInterval);
                readStatusInterval = null;
            }
            if (statusUpdateInterval) {
                clearInterval(statusUpdateInterval);
                statusUpdateInterval = null;
            }
            
            // Для чата с самим собой сохраняем возможность открыть его снова
            if (currentChatUserId === localStorage.getItem('user_id')) {
                const selfChat = document.querySelector(`.user-bar[data-user-id="${currentChatUserId}"]`);
                if (selfChat) {
                    selfChat.classList.add('active-chat');
                }
            }
        }
    }
});

            // Обработчик клика по карточке пользователя
            document.addEventListener('click', function(e) {
                let userBar = e.target.closest('.user-bar');
                if (userBar) {
                    const userId = userBar.dataset.userId;
                    openChat(userId);
                    
                    document.querySelectorAll('.user-bar').forEach(el => {
                        el.classList.remove('active-chat');
                    });
                    userBar.classList.add('active-chat');
                }
            });
            
            // Обработчик отправки сообщения
            document.getElementById('message-input').addEventListener('keypress', async function(e) {
                if (e.key === 'Enter' && this.value.trim()) {
                    await sendMessage(this.value.trim());
                    this.value = '';
                }
            });

            // Инициализация голосовых сообщений
            document.getElementById('voice-message-btn').addEventListener('mousedown', startRecording);
            document.getElementById('voice-message-btn').addEventListener('touchstart', startRecording);
            document.getElementById('voice-message-btn').addEventListener('mouseup', stopRecording);
            document.getElementById('voice-message-btn').addEventListener('touchend', stopRecording);
            document.getElementById('voice-message-btn').addEventListener('mouseleave', stopRecording);

            // Проверка новых сообщений каждые 2 секунды
            setInterval(checkForNewMessages, 2000);

            // Первоначальная загрузка друзей
            await loadFriends();
        });

        function startOnlineStatusUpdates() {
            updateOnlineStatus();
            onlineStatusInterval = setInterval(updateOnlineStatus, 30000);
            window.addEventListener('beforeunload', updateOnlineStatus);
        }

        async function updateOnlineStatus() {
            try {
                await eel.update_last_online(localStorage.getItem('user_id'))();
            } catch (error) {
                console.error('Ошибка обновления статуса онлайн:', error);
            }
        }

        function closeLogoutModal() {
            document.getElementById('logout-overlay').classList.add('hidden');
            document.getElementById('logout-modal').classList.add('hidden');
        }


        function closeChat(softClose = false) {
    document.getElementById('default-content').classList.remove('hidden');
    document.getElementById('chat-container').classList.add('hidden');
    document.querySelectorAll('.user-bar').forEach(el => {
        el.classList.remove('active-chat');
    });
    
    stopVoiceMessage();
    currentPlayingAudio = null;
    voiceMessagePlaying = false;
    currentPlayingVoiceElement = null;
    
    // Сбрасываем currentChatUserId только если это не softClose
    if (!softClose) {
        currentChatUserId = null;
    }
    
    lastMessageId = null;
    
    if (readStatusInterval) {
        clearInterval(readStatusInterval);
        readStatusInterval = null;
    }
    if (statusUpdateInterval) {
        clearInterval(statusUpdateInterval);
        statusUpdateInterval = null;
    }
}

async function openChat(userId) {
    // Если чат уже открыт, просто прокручиваем сообщения
    if (currentChatUserId === userId && !document.getElementById('chat-container').classList.contains('hidden')) {
        const messagesContainer = document.getElementById('chat-messages');
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
        return;
    }

    // Полностью останавливаем текущее воспроизведение
    stopVoiceMessage();
    currentPlayingAudio = null;
    voiceMessagePlaying = false;
    currentPlayingVoiceElement = null;
    
    if (readStatusInterval) clearInterval(readStatusInterval);
    if (statusUpdateInterval) clearInterval(statusUpdateInterval);

    currentChatUserId = userId;
    const user = await eel.get_user_data(userId)();
    
    if (user) {
        document.getElementById('default-content').classList.add('hidden');
        document.getElementById('chat-container').classList.remove('hidden');
        document.getElementById('chat-username').textContent = 
            userId === localStorage.getItem('user_id') ? 'Избранное' : user.nickname;
        await updateUserStatus();
        
        if (activeChats[userId]) {
            document.getElementById('chat-messages').innerHTML = activeChats[userId].messages;
            lastMessageId = activeChats[userId].lastMessageId;
            const messagesContainer = document.getElementById('chat-messages');
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
            
            // Обновляем индикаторы перед установкой обработчиков
            await updateListenIndicators();
            setupVoiceMessageHandlers();
        } else {
            await loadChatHistory(userId);
        }
        
        readStatusInterval = setInterval(updateReadStatus, 2000);
        updateReadStatus();
        
        statusUpdateInterval = setInterval(updateUserStatus, 5000);
        
        // Помечаем карточку пользователя как активную
        document.querySelectorAll('.user-bar').forEach(el => {
            el.classList.remove('active-chat');
        });
        const userCard = document.querySelector(`.user-bar[data-user-id="${userId}"]`);
        if (userCard) {
            userCard.classList.add('active-chat');
        }
    }
}

async function updateListenIndicators() {
    if (!currentChatUserId) return;
    
    try {
        const messages = Array.from(document.querySelectorAll('.message'))
            .map(el => ({id: el.dataset.id, isVoice: !!el.querySelector('.voice-message')}))
            .filter(msg => msg.id && msg.isVoice);
        
        if (messages.length === 0) return;
        
        const listenedStatus = await eel.check_voice_messages_listened_status(messages.map(m => m.id))();
        
        messages.forEach(msg => {
            const messageElement = document.querySelector(`.message[data-id="${msg.id}"]`);
            if (messageElement) {
                const voiceMessage = messageElement.querySelector('.voice-message');
                if (voiceMessage) {
                    const indicator = voiceMessage.querySelector('.listen-indicator');
                    if (indicator) {
                        const isListened = listenedStatus[msg.id] || false;
                        indicator.style.opacity = isListened ? '0' : '0.7';
                    }
                }
            }
        });
    } catch (error) {
        console.error('Ошибка при обновлении индикаторов прослушивания:', error);
    }
}


function setupVoiceMessageHandlers() {
    const voiceMessages = document.querySelectorAll('.voice-message');
    voiceMessages.forEach((voiceMessage) => {
        const playBtn = voiceMessage.querySelector('.play-voice-btn');
        playBtn.addEventListener('click', async () => {
            const isPlaying = voiceMessage.classList.contains('playing');
            const messageElement = voiceMessage.closest('.message');
            const isMyMessage = messageElement.classList.contains('my-message');
            
            if (isPlaying) {
                stopVoiceMessage(voiceMessage);
            } else {
                // Для своих сообщений используем данные из кеша
                if (isMyMessage) {
                    const messageId = messageElement.dataset.id;
                    const cachedMessage = activeChats[currentChatUserId]?.messagesData?.find(m => m.id === messageId);
                    if (cachedMessage && cachedMessage.voiceData) {
                        playVoiceMessage(cachedMessage.voiceData, voiceMessage, cachedMessage.duration);
                        return;
                    }
                }
                
                // Для чужих сообщений запрашиваем данные с сервера
                const messageId = messageElement.dataset.id;
                const response = await eel.get_voice_message(messageId)();
                if (response.success) {
                    playVoiceMessage(response.voice_data, voiceMessage, response.duration);
                } else {
                    alert('Не удалось загрузить голосовое сообщение');
                }
            }
        });
    });
}

        async function updateUserStatus() {
            if (!currentChatUserId) return;

            try {
                const user = await eel.get_user_data(currentChatUserId)();
                if (!user) return;

                const statusElement = document.getElementById('chat-status');
                const now = new Date();
                const lastOnline = new Date(user.last_online + ' UTC');

                const diffMinutes = Math.floor((now - lastOnline) / (1000 * 60));

                if (currentChatUserId === localStorage.getItem('user_id')) {
                    statusElement.textContent = '';
                    statusElement.classList.remove('online');
                } else if (diffMinutes < 5) {
                    statusElement.textContent = 'В сети';
                    statusElement.classList.add('online');
                } else {
                    statusElement.textContent = `Был(а) в сети ${formatTimeAgo(lastOnline)}`;
                    statusElement.classList.remove('online');
                }

                updateOnlineStatusInContacts();
            } catch (error) {
                console.error('Ошибка при обновлении статуса:', error);
            }
        }

        function updateOnlineStatusInContacts() {
            const userBars = document.querySelectorAll('.user-bar:not(.current-user)');
            userBars.forEach(async bar => {
                const userId = bar.dataset.userId;
                try {
                    const user = await eel.get_user_data(userId)();
                    if (user) {
                        const now = new Date();
                        const lastOnline = new Date(user.last_online + ' UTC');
                        const diffMinutes = Math.floor((now - lastOnline) / (1000 * 60));

                        const avatar = bar.querySelector('.avatar-medium');
                        if (diffMinutes < 5) {
                            avatar.classList.add('online');
                        } else {
                            avatar.classList.remove('online');
                        }
                    }
                } catch (error) {
                    console.error('Ошибка при обновлении статуса контакта:', error);
                }
            });
        }

        function formatTimeAgo(date) {
            const now = new Date();
            const diff = Math.floor((now - date) / 1000);
            
            if (diff < 60) return 'только что';
            if (diff < 3600) return `${Math.floor(diff / 60)} мин. назад`;
            if (diff < 86400) return `${Math.floor(diff / 3600)} ч. назад`;
            
            const days = Math.floor(diff / 86400);
            if (days === 1) return 'вчера';
            if (days < 7) return `${days} дн. назад`;
            
            return date.toLocaleDateString('ru-RU', {
                day: 'numeric',
                month: 'long',
                year: 'numeric'
            });
        }

        async function updateReadStatus() {
    if (!currentChatUserId) return;
    
    try {
        const myMessages = Array.from(document.querySelectorAll('.my-message'))
            .map(el => el.dataset.id)
            .filter(id => id);
        
        if (myMessages.length === 0) return;
        
        const readStatus = await eel.check_message_read_status(myMessages)();
        const listenedStatus = await eel.check_voice_messages_listened_status(myMessages)();
        
        for (const [messageId, isRead] of Object.entries(readStatus)) {
            const messageElement = document.querySelector(`.message[data-id="${messageId}"]`);
            if (messageElement) {
                // Обновляем статус прочтения только для текстовых сообщений
                const voiceMessage = messageElement.querySelector('.voice-message');
                if (!voiceMessage) {
                    const infoElement = messageElement.querySelector('.message-info');
                    if (infoElement) {
                        const timeElement = infoElement.querySelector('span');
                        if (timeElement) {
                            infoElement.innerHTML = `${timeElement.outerHTML}${isRead ? '✓✓' : '✓'}`;
                        }
                    }
                }
                
                // Обновляем индикатор прослушивания для голосовых сообщений
                if (voiceMessage) {
                    const indicator = voiceMessage.querySelector('.listen-indicator');
                    if (indicator) {
                        const isListened = listenedStatus[messageId] || false;
                        indicator.style.opacity = isListened ? '0' : '0.7';
                    }
                }
            }
        }
    } catch (error) {
        console.error('Ошибка при обновлении статуса прочтения:', error);
    }
}

async function loadChatHistory(userId) {
    try {
        const messages = await eel.get_chat_history(localStorage.getItem('user_id'), userId)();
        const messagesContainer = document.getElementById('chat-messages');
        messagesContainer.innerHTML = '';

        if (messages && messages.length > 0) {
            messages.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
            
            // Сохраняем данные сообщений
            const messagesData = [];
            
            messages.forEach(msg => {
                const isMyMessage = msg.sender_id === localStorage.getItem('user_id');
                addMessageToChat(msg, isMyMessage, false);
                
                if (msg.isVoiceMessage || msg.is_voice) {
                    messagesData.push({
                        id: msg.id,
                        voiceData: msg.voiceData,
                        duration: msg.duration,
                        isVoiceMessage: true
                    });
                }
            });
            
            lastMessageId = messages[messages.length - 1].id;
            
            activeChats[userId] = {
                messages: messagesContainer.innerHTML,
                lastMessageId: lastMessageId,
                messagesData: messagesData
            };
            
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
            setupVoiceMessageHandlers();
        } else {
            messagesContainer.innerHTML = '<div class="no-messages">Нет сообщений</div>';
            lastMessageId = null;
            
            activeChats[userId] = {
                messages: messagesContainer.innerHTML,
                lastMessageId: null,
                messagesData: []
            };
        }
    } catch (error) {
        console.error('Error loading chat history:', error);
    }
}
        async function sendMessage(text) {
            if (!currentChatUserId || !text) return;
            
            try {
                const result = await eel.send_message(
                    localStorage.getItem('user_id'),
                    currentChatUserId,
                    text
                )();
                
                if (result.success) {
                    const message = {
                        id: result.message_id,
                        sender_id: localStorage.getItem('user_id'),
                        receiver_id: currentChatUserId,
                        text: text,
                        timestamp: result.timestamp,
                        read: result.read
                    };
                    
                    addMessageToChat(message, true, true);
                    lastMessageId = message.id;
                    
                    if (activeChats[currentChatUserId]) {
                        const messagesContainer = document.getElementById('chat-messages');
                        activeChats[currentChatUserId] = {
                            messages: messagesContainer.innerHTML,
                            lastMessageId: lastMessageId
                        };
                    }
                    
                    // Обновляем последнее сообщение на карточке пользователя
                    updateLastMessageOnUserCard(currentChatUserId, text, true);
                } else {
                    console.error("Ошибка при отправке:", result.message);
                }
            } catch (error) {
                console.error('Error sending message:', error);
            }
        }

        function updateLastMessageOnUserCard(userId, messageText, isMyMessage) {
            const userCard = document.querySelector(`.user-bar[data-user-id="${userId}"]`);
            if (!userCard) return;
            
            const lastMsgDiv = userCard.querySelector('.last-message');
            let displayText = messageText;
            
            if (displayText.length > 25) {
                displayText = displayText.substring(0, 22) + '...';
            }
            
            if (isMyMessage) {
                if (lastMsgDiv) {
                    lastMsgDiv.innerHTML = `<span class="you-indicator">Вы:</span> ${displayText}`;
                } else {
                    // Если элемента еще нет, создаем его
                    const contentWrapper = userCard.querySelector('.user-content-wrapper');
                    if (contentWrapper) {
                        const newLastMsgDiv = document.createElement('div');
                        newLastMsgDiv.className = 'last-message';
                        newLastMsgDiv.innerHTML = `<span class="you-indicator">Вы:</span> ${displayText}`;
                        contentWrapper.appendChild(newLastMsgDiv);
                    }
                }
            } else {
                if (lastMsgDiv) {
                    lastMsgDiv.textContent = displayText;
                } else {
                    const contentWrapper = userCard.querySelector('.user-content-wrapper');
                    if (contentWrapper) {
                        const newLastMsgDiv = document.createElement('div');
                        newLastMsgDiv.className = 'last-message';
                        newLastMsgDiv.textContent = displayText;
                        contentWrapper.appendChild(newLastMsgDiv);
                    }
                }
            }
        }

        function addMessageToChat(message, isMyMessage, isNewMessage = true) {
    const messagesContainer = document.getElementById('chat-messages');
    
    if (messagesContainer.querySelector('.no-messages')) {
        messagesContainer.innerHTML = '';
    }
    
    let messageElement = document.querySelector(`.message[data-id="${message.id}"]`);
    
    if (!messageElement) {
        messageElement = document.createElement('div');
        messageElement.className = `message ${isMyMessage ? 'my-message' : 'their-message'}`;
        messageElement.dataset.id = message.id;
        
        const date = new Date(message.timestamp);
        const timeString = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        const dateString = date.toLocaleDateString([], { day: 'numeric', month: 'short' });
        
        if (message.isVoiceMessage || message.is_voice) {
            const voiceElement = createVoiceMessageElement(message);
            messageElement.appendChild(voiceElement);
            
            if (message.read) {
                const indicator = voiceElement.querySelector('.listen-indicator');
                if (indicator) indicator.style.opacity = '0';
            }
        } else {
            messageElement.innerHTML = `
                <div class="message-text">${message.text}</div>
                <div class="message-info">
                    <span>${dateString} ${timeString}</span>
                    ${isMyMessage ? (message.read ? '✓✓' : '✓') : ''}
                </div>
            `;
        }
        
        messagesContainer.appendChild(messageElement);
    } else if (isMyMessage && !message.isVoiceMessage && !message.is_voice) {
        const infoElement = messageElement.querySelector('.message-info');
        if (infoElement) {
            const timeElement = infoElement.querySelector('span');
            if (timeElement) {
                infoElement.innerHTML = `${timeElement.outerHTML}${message.read ? '✓✓' : '✓'}`;
            }
        }
    }
    
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
    
    // Сохраняем состояние чата и данные сообщений
    if (currentChatUserId) {
        if (!activeChats[currentChatUserId]) {
            activeChats[currentChatUserId] = {
                messages: '',
                lastMessageId: null,
                messagesData: []
            };
        }
        
        activeChats[currentChatUserId].messages = messagesContainer.innerHTML;
        activeChats[currentChatUserId].lastMessageId = lastMessageId;
        
        if (isNewMessage && (message.isVoiceMessage || message.is_voice)) {
            activeChats[currentChatUserId].messagesData.push({
                id: message.id,
                voiceData: message.voiceData,
                duration: message.duration,
                isVoiceMessage: true
            });
        }
    }
}


        async function checkForNewMessages() {
            if (!currentChatUserId) return;
            
            try {
                const newMessages = await eel.check_new_messages(
                    localStorage.getItem('user_id'),
                    lastMessageId
                )();
                
                if (newMessages && newMessages.length > 0) {
                    newMessages.forEach(msg => {
                        if (msg.sender_id === currentChatUserId) {
                            addMessageToChat(msg, false, true);
                            // Обновляем последнее сообщение на карточке
                            updateLastMessageOnUserCard(currentChatUserId, msg.text, false);
                        }
                    });
                    
                    lastMessageId = newMessages[newMessages.length - 1].id;
                    
                    const messagesContainer = document.getElementById('chat-messages');
                    activeChats[currentChatUserId] = {
                        messages: messagesContainer.innerHTML,
                        lastMessageId: lastMessageId
                    };
                    
                    updateOnlineStatusInContacts();
                    
                    // Устанавливаем обработчики для новых голосовых сообщений
                    setupVoiceMessageHandlers();
                }
            } catch (error) {
                console.error('Error checking new messages:', error);
            }
        }
        
        async function loadFriends() {
            const user_id = localStorage.getItem('user_id');
            try {
                currentUser = await eel.get_user_data(user_id)();
                
                const container = document.getElementById('user-container');
                container.innerHTML = '';
                
                // Добавляем карточку текущего пользователя
                const selfCard = createUserCard({
                    user_id: user_id,
                    nickname: currentUser.nickname,
                    isCurrentUser: true
                });
                container.appendChild(selfCard);
                
                // Добавляем друзей
                if (currentUser.friends && currentUser.friends.length > 0) {
                    for (const friendId of currentUser.friends) {
                        const friend = await eel.get_user_data(friendId)();
                        if (friend) {
                            // Получаем последнее сообщение
                            const lastMessage = await eel.get_last_message(user_id, friendId)();
                            const friendCard = createUserCard({
                                user_id: friendId,
                                nickname: friend.nickname,
                                isFriend: true,
                                lastMessage: lastMessage
                            });
                            container.appendChild(friendCard);
                        }
                    }
                    
                    updateOnlineStatusInContacts();
                } else {
                    const noFriends = document.createElement('div');
                    noFriends.className = 'no-friends';
                    noFriends.textContent = 'У вас пока нет друзей. Найдите их через поиск!';
                    container.appendChild(noFriends);
                }
            } catch (error) {
                console.error('Error loading friends:', error);
            }
        }

        function createUserCard(userData) {
            const card = document.createElement('div');
            card.className = 'user-bar' + (userData.isCurrentUser ? ' current-user' : '');
            card.dataset.userId = userData.user_id;
            
            const avatar = document.createElement('div');
            avatar.className = 'avatar-medium';
            avatar.style.backgroundImage = 'url(https://cdn-icons-png.flaticon.com/512/3135/3135715.png)';
            
            const contentWrapper = document.createElement('div');
            contentWrapper.className = 'user-content-wrapper';
            
            const username = document.createElement('div');
            username.className = 'username';
            username.textContent = userData.isCurrentUser ? `Вы (${userData.nickname})` : userData.nickname;
            
            contentWrapper.appendChild(username);
            
            // Добавляем последнее сообщение, если оно есть
            if (userData.lastMessage && !userData.isCurrentUser) {
                const lastMsgDiv = document.createElement('div');
                lastMsgDiv.className = 'last-message';
                
                let messageText = userData.lastMessage.text;
                if (messageText.length > 25) {
                    messageText = messageText.substring(0, 22) + '...';
                }
                
                if (userData.lastMessage.sender_id === localStorage.getItem('user_id')) {
                    lastMsgDiv.innerHTML = `<span class="you-indicator">Вы:</span> ${messageText}`;
                } else {
                    lastMsgDiv.textContent = messageText;
                }
                
                contentWrapper.appendChild(lastMsgDiv);
            }
            
            card.appendChild(avatar);
            card.appendChild(contentWrapper);
            
            if (!userData.isCurrentUser) {
                card.addEventListener('contextmenu', function(e) {
                    e.preventDefault();
                    showContextMenu(e, userData);
                });
            }
            
            return card;
        }

        function showContextMenu(e, userData) {
            closeContextMenu();
            
            contextMenuTarget = userData.user_id;
            
            const addBtn = document.getElementById('context-menu-add');
            const removeBtn = document.getElementById('context-menu-remove');
            
            if (currentUser.friends.includes(userData.user_id)) {
                addBtn.classList.add('hidden');
                removeBtn.classList.remove('hidden');
            } else {
                addBtn.classList.remove('hidden');
                removeBtn.classList.add('hidden');
            }
            
            contextMenu.style.display = 'block';
            contextMenu.style.left = `${e.pageX}px`;
            contextMenu.style.top = `${e.pageY}px`;
        }

        function closeContextMenu() {
            if (contextMenu) {
                contextMenu.style.display = 'none';
            }
            contextMenuTarget = null;
        }

        async function handleAddFriend() {
            if (!contextMenuTarget) return;
            
            const user_id = localStorage.getItem('user_id');
            try {
                const response = await eel.add_friend(user_id, contextMenuTarget)();
                
                if (response.success) {
                    await loadFriends();
                }
                alert(response.message);
            } catch (error) {
                alert('Ошибка при добавлении в друзья');
                console.error('Error adding friend:', error);
            }
            
            closeContextMenu();
        }

        async function handleRemoveFriend() {
            if (!contextMenuTarget) return;
            
            const user_id = localStorage.getItem('user_id');
            try {
                const response = await eel.remove_friend(user_id, contextMenuTarget)();
                
                if (response.success) {
                    await loadFriends();
                    if (currentChatUserId === contextMenuTarget) {
                        closeChat();
                    }
                }
                alert(response.message);
            } catch (error) {
                alert('Ошибка при удалении из друзей');
                console.error('Error removing friend:', error);
            }
            
            closeContextMenu();
        }

        async function displaySearchResults(users) {
            const container = document.getElementById('user-container');
            container.innerHTML = '';
            
            if (users.length === 0) {
                const noResults = document.createElement('div');
                noResults.className = 'no-results';
                noResults.textContent = 'Ничего не найдено';
                container.appendChild(noResults);
                return;
            }
            
            for (const user of users) {
                const isFriend = currentUser.friends.includes(user.user_id);
                // Получаем последнее сообщение для результатов поиска
                const lastMessage = await eel.get_last_message(localStorage.getItem('user_id'), user.user_id)();
                const userCard = createUserCard({
                    user_id: user.user_id,
                    nickname: user.nickname,
                    isFriend: isFriend,
                    lastMessage: lastMessage
                });
                container.appendChild(userCard);
            }
            
            updateOnlineStatusInContacts();
        }

        // Функции для работы с голосовыми сообщениями
        async function startRecording(e) {
            e.preventDefault();
            
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                mediaRecorder = new MediaRecorder(stream);
                audioChunks = [];
                recordingStartTime = Date.now();
                const visualizationData = [];
                
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                const source = audioContext.createMediaStreamSource(stream);
                source.connect(analyser);
                analyser.fftSize = 32;
                
                mediaRecorder.ondataavailable = (e) => {
                    if (e.data.size > 0) audioChunks.push(e.data);
                    
                    // Собираем данные для визуализации
                    const bufferLength = analyser.frequencyBinCount;
                    const dataArray = new Uint8Array(bufferLength);
                    analyser.getByteFrequencyData(dataArray);
                    
                    // Нормализуем данные для 20 полосок
                    const step = Math.floor(bufferLength / 20);
                    const frameData = [];
                    for (let i = 0; i < 20; i++) {
                        frameData.push(dataArray[i * step] / 255);
                    }
                    visualizationData.push(frameData);
                };
                
                mediaRecorder.onstop = async () => {
                    const recordingTime = (Date.now() - recordingStartTime) / 1000;
                    if (recordingTime < 0.5) {
                        alert('Сообщение слишком короткое');
                        return;
                    }
                    
                    const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
                    await sendVoiceMessage(audioBlob, recordingTime, visualizationData);
                };
                
                mediaRecorder.start(100);
                document.getElementById('message-input').classList.add('hidden');
                document.getElementById('recording-container').classList.remove('hidden');
                updateRecordingTime();
            } catch (error) {
                console.error('Ошибка записи:', error);
                alert('Не удалось получить доступ к микрофону');
            }
        }

        function stopRecording(e) {
            e.preventDefault();
            
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
                mediaRecorder.stream.getTracks().forEach(track => track.stop());
                
                // Скрываем индикатор записи
                document.getElementById('recording-container').classList.add('hidden');
                document.getElementById('message-input').classList.remove('hidden');
            }
        }

        function updateRecordingTime() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                const recordingTime = ((Date.now() - recordingStartTime) / 1000).toFixed(1);
                document.getElementById('recording-time').textContent = recordingTime;
                setTimeout(updateRecordingTime, 100);
            }
        }

        async function sendVoiceMessage(audioBlob, duration, visualizationData) {
    if (!currentChatUserId || !audioBlob) return;
    
    try {
        const reader = new FileReader();
        reader.readAsDataURL(audioBlob);
        
        reader.onload = async () => {
            const audioData = reader.result.split(',')[1];
            
            const finalVisualization = [];
            if (visualizationData && visualizationData.length > 0) {
                for (let i = 0; i < 20; i++) {
                    let sum = 0;
                    for (const frame of visualizationData) {
                        sum += frame[i];
                    }
                    finalVisualization.push(sum / visualizationData.length);
                }
            }
            
            const result = await eel.send_voice_message(
                localStorage.getItem('user_id'),
                currentChatUserId,
                audioData,
                duration,
                finalVisualization
            )();
            
            if (result.success) {
                const message = {
                    id: result.message_id,
                    sender_id: localStorage.getItem('user_id'),
                    receiver_id: currentChatUserId,
                    text: '[Голосовое сообщение]',
                    timestamp: result.timestamp,
                    read: result.read,
                    isVoiceMessage: true,
                    voiceData: audioData,
                    duration: duration,
                    visualization: finalVisualization,
                    listened: currentChatUserId === localStorage.getItem('user_id') // Для своих сообщений сразу помечаем как прослушанные
                };
                
                addMessageToChat(message, true, true);
                lastMessageId = message.id;
                
                // Сохраняем состояние чата
                const messagesContainer = document.getElementById('chat-messages');
                activeChats[currentChatUserId] = {
                    messages: messagesContainer.innerHTML,
                    lastMessageId: lastMessageId,
                    messagesData: activeChats[currentChatUserId]?.messagesData || []
                };
                
                // Добавляем данные сообщения в кеш
                activeChats[currentChatUserId].messagesData.push({
                    id: message.id,
                    voiceData: message.voiceData,
                    duration: message.duration,
                    isVoiceMessage: true,
                    listened: message.listened
                });
                
                // Обновляем последнее сообщение на карточке
                updateLastMessageOnUserCard(currentChatUserId, 'Голосовое сообщение', true);
                
                // Устанавливаем обработчики для голосовых сообщений
                setupVoiceMessageHandlers();
            }
        };
    } catch (error) {
        console.error('Ошибка отправки голосового сообщения:', error);
    }
}

function createVoiceMessageElement(message) {
    const voiceMessage = document.createElement('div');
    voiceMessage.className = 'voice-message';
    voiceMessage.dataset.messageId = message.id;
    
    const playBtn = document.createElement('button');
    playBtn.className = 'play-voice-btn';
    playBtn.innerHTML = '<img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTdnax9muCZwZsJujMzKiWx8tnQXgbwNaX39A&s" alt="Play">';
    
    const isMyMessage = message.sender_id === localStorage.getItem('user_id');
    
    // Всегда добавляем индикатор, но управляем его видимостью через opacity
    const listenIndicator = document.createElement('div');
    listenIndicator.className = 'listen-indicator';
    
    // Для своих сообщений индикатор всегда видим (если не прослушано)
    if (isMyMessage) {
        listenIndicator.style.opacity = message.listened ? '0' : '0.7';
    } 
    // Для чужих сообщений индикатор видим только если не прослушано
    else {
        listenIndicator.style.opacity = message.listened ? '0' : '0.7';
    }
    
    voiceMessage.appendChild(listenIndicator);
    
    const visualization = document.createElement('div');
    visualization.className = 'voice-visualization';
    
    const visualizationData = message.visualization || Array(20).fill(0.3);
    for (let i = 0; i < 20; i++) {
        const bar = document.createElement('div');
        bar.className = 'voice-bar';
        const height = Math.max(3, visualizationData[i] * 30);
        bar.style.height = `${height}px`;
        
        if (isMyMessage) {
            bar.style.backgroundColor = `rgba(0, 0, 0, ${0.2 + visualizationData[i] * 0.8})`;
        } else {
            bar.style.backgroundColor = `rgba(255, 255, 255, ${0.5 + visualizationData[i] * 0.5})`;
        }
        
        visualization.appendChild(bar);
    }
    
    const time = document.createElement('div');
    time.className = 'voice-time';
    time.dataset.duration = message.duration;
    time.textContent = `${message.duration.toFixed(1)} сек.`;
    
    voiceMessage.appendChild(playBtn);
    voiceMessage.appendChild(visualization);
    voiceMessage.appendChild(time);
    
    return voiceMessage;
}
function playVoiceMessage(audioData, voiceMessageElement, duration) {
    // Если это уже текущее сообщение и оно на паузе - возобновляем
    if (currentPlayingVoiceElement === voiceMessageElement && currentPlayingAudio) {
        const currentTime = currentPlayingAudio.currentTime;
        currentPlayingAudio.play().then(() => {
            voiceMessageElement.classList.add('playing');
            voiceMessagePlaying = true;
            
            const playBtn = voiceMessageElement.querySelector('.play-voice-btn img');
            playBtn.src = 'https://png.klev.club/uploads/posts/2024-05/png-klev-club-uejr-p-ikonka-pauzi-png-30.png';
            
            const timeElement = voiceMessageElement.querySelector('.voice-time');
            const startTime = Date.now() - (currentTime * 1000);
            
            const updateTime = () => {
                if (!voiceMessagePlaying) return;
                
                const elapsed = (Date.now() - startTime) / 1000;
                const currentPos = Math.min(elapsed, duration);
                timeElement.textContent = `${currentPos.toFixed(1)} / ${duration.toFixed(1)} сек.`;
                
                if (currentPos >= duration) {
                    handleVoiceMessagePlayed(voiceMessageElement);
                } else if (voiceMessagePlaying) {
                    requestAnimationFrame(updateTime);
                }
            };
            
            updateTime();
        }).catch(error => {
            console.error('Ошибка возобновления:', error);
        });
        return;
    }

    // Останавливаем текущее воспроизведение, если есть
    if (currentPlayingAudio) {
        currentPlayingAudio.pause();
        currentPlayingAudio = null;
        
        if (currentPlayingVoiceElement) {
            stopVoiceMessage(currentPlayingVoiceElement, true);
        }
    }

    // Устанавливаем класс playing для текущего элемента
    voiceMessageElement.classList.add('playing');
    voiceMessagePlaying = true;
    currentPlayingVoiceElement = voiceMessageElement;
    
    const audio = new Audio(`data:audio/wav;base64,${audioData}`);
    currentPlayingAudio = audio;
    
    const playBtn = voiceMessageElement.querySelector('.play-voice-btn img');
    playBtn.src = 'https://png.klev.club/uploads/posts/2024-05/png-klev-club-uejr-p-ikonka-pauzi-png-30.png';
    
    const timeElement = voiceMessageElement.querySelector('.voice-time');
    timeElement.dataset.duration = duration;
    timeElement.textContent = `${duration.toFixed(1)} сек.`;
    
    // Получаем родительский элемент сообщения
    const messageElement = voiceMessageElement.closest('.message');
    const isMyMessage = messageElement.classList.contains('my-message');
    
    // Для своих сообщений не меняем состояние индикатора при воспроизведении
    if (isMyMessage) {
        const indicator = voiceMessageElement.querySelector('.listen-indicator');
        if (indicator) {
            // Оставляем индикатор видимым, если сообщение не прослушано
            indicator.style.opacity = '0.7';
        }
    }
    
    // Функция обновления времени
    const updateTime = () => {
        if (!voiceMessagePlaying) return;
        
        const currentPos = audio.currentTime;
        timeElement.textContent = `${currentPos.toFixed(1)} / ${duration.toFixed(1)} сек.`;
        
        if (currentPos >= duration) {
            handleVoiceMessagePlayed(voiceMessageElement);
        } else if (voiceMessagePlaying) {
            requestAnimationFrame(updateTime);
        }
    };
        
    // Обработчики событий аудио
    audio.addEventListener('ended', () => {
        handleVoiceMessagePlayed(voiceMessageElement);
    });
    
    audio.addEventListener('pause', () => {
        voiceMessagePlaying = false;
        const currentTime = audio.currentTime;
        timeElement.textContent = `${currentTime.toFixed(1)} / ${duration.toFixed(1)} сек.`;
    });
    
    audio.addEventListener('error', () => {
        stopVoiceMessage(voiceMessageElement, true);
        alert('Ошибка воспроизведения голосового сообщения');
    });
    
    // Запускаем воспроизведение
    audio.play().then(() => {
        updateTime();
    }).catch(error => {
        console.error('Ошибка воспроизведения:', error);
        stopVoiceMessage(voiceMessageElement, true);
    });
}

function handleVoiceMessagePlayed(voiceMessageElement) {
    const messageElement = voiceMessageElement.closest('.message');
    const messageId = messageElement?.dataset.id;
    const timeElement = voiceMessageElement.querySelector('.voice-time');
    const duration = parseFloat(timeElement.dataset.duration) || 0;
    
    timeElement.textContent = `${duration.toFixed(1)} сек.`;
    stopVoiceMessage(voiceMessageElement, true);
    
    const isMyMessage = messageElement.classList.contains('my-message');
    const indicator = voiceMessageElement.querySelector('.listen-indicator');
    
    // Для своих сообщений НЕ изменяем состояние индикатора
    if (!isMyMessage && indicator) {
        indicator.style.opacity = '0';
    }
    
    // Обновляем состояние в кеше только для чужих сообщений
    if (!isMyMessage && currentChatUserId && activeChats[currentChatUserId]?.messagesData) {
        const messageIndex = activeChats[currentChatUserId].messagesData.findIndex(m => m.id === messageId);
        if (messageIndex !== -1) {
            activeChats[currentChatUserId].messagesData[messageIndex].listened = true;
        }
    }
    
    // Отправляем на сервер информацию о прослушивании (только для чужих сообщений)
    if (messageId && !isMyMessage) {
        const userId = localStorage.getItem('user_id');
        eel.mark_voice_message_as_listened(messageId, userId)();
    }
}


function stopVoiceMessage(voiceMessageElement = null, reset = false) {
    if (!voiceMessageElement) {
        voiceMessageElement = currentPlayingVoiceElement;
    }
    
    if (currentPlayingAudio) {
        currentPlayingAudio.pause();
        if (reset) {
            currentPlayingAudio.currentTime = 0;
            currentPlayingAudio = null;
        }
        voiceMessagePlaying = false;
    }
    
    if (voiceMessageElement) {
        voiceMessageElement.classList.remove('playing');
        const playBtn = voiceMessageElement.querySelector('.play-voice-btn img');
        playBtn.src = 'https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTdnax9muCZwZsJujMzKiWx8tnQXgbwNaX39A&s';
        
        const timeElement = voiceMessageElement.querySelector('.voice-time');
        const duration = parseFloat(timeElement.dataset.duration) || 0;
        
        if (reset) {
            timeElement.textContent = `${duration.toFixed(1)} сек.`;
            currentPlayingVoiceElement = null;
        } else {
            timeElement.textContent = `${Math.min(currentPlayingAudio?.currentTime || 0, duration).toFixed(1)} / ${duration.toFixed(1)} сек.`;
        }
    }
}
    </script>
</body>
</html>