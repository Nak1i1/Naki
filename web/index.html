<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Мессенджер</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>

    <!-- Модальное окно отправки медиа -->
<div class="media-send-overlay hidden" id="media-send-overlay"></div>
<div class="media-send-modal hidden" id="media-send-modal">
    <div class="media-send-title" id="media-send-title">Отправить фото</div>
    <div class="media-preview-container">
        <img src="" alt="Preview" class="media-preview hidden" id="image-preview">
        <video controls class="media-preview hidden" id="video-preview"></video>
    </div>
    <input type="text" class="media-caption-input" id="media-caption-input" placeholder="Введите текст">
    <div class="media-send-buttons">
        <button class="media-send-button add" id="media-add-button">Добавить</button>
        <button class="media-send-button cancel" id="media-cancel-button">Отмена</button>
        <button class="media-send-button send" id="media-send-button">Отправить</button>
    </div>
</div>

    <!-- Скрытый input для выбора файлов -->
<input type="file" id="file-input" class="file-input" accept="image/*,video/*" onchange="handleFileSelect(event)">

    <div class="top-container">
        <div class="top-row">
            <div class="menu-icon">☰</div>
            <div class="avatar-small" id="top-avatar"></div>
            <div class="search-container">
                <input type="text" class="search-input" placeholder="поиск">
                <span class="clear-btn">×</span>
            </div>
        </div>
        
        <div class="user-container" id="user-container"></div>
    </div>
    
    <div class="right-container">
        <div class="default-content" id="default-content">
            <img src="https://cdn-icons-png.flaticon.com/512/5757/5757765.png" alt="Выберите чат" class="default-image">
        </div>
        
<div class="chat-container hidden" id="chat-container">
    <div class="chat-header">
        <div class="chat-username" id="chat-username"></div>
        <div class="chat-header-info">
            <div class="chat-status" id="chat-status"></div>
        </div>
    </div>
    <div class="chat-scroll-container">
        <div class="chat-messages-wrapper" id="chat-messages-wrapper">
            <div class="chat-messages" id="chat-messages">
                <div class="no-messages">Нет сообщений</div>
            </div>
        </div>
        <div class="custom-scrollbar" id="custom-scrollbar">
            <div class="custom-scrollbar-thumb" id="custom-scrollbar-thumb"></div>
        </div>
    </div>
    <div class="message-input-container">
        <div class="reply-container hidden" id="reply-container"></div>
        <div class="input-row">
    <button class="photo-message-btn" id="photo-message-btn">
        <img src="https://cdn-icons-png.flaticon.com/512/266/266074.png" alt="Фото">
    </button>
    <div class="message-input-wrapper">
        <input type="text" class="message-input" placeholder="Напишите сообщение..." id="message-input">
        <div class="recording-container hidden" id="recording-container">
            Запись: <span id="recording-time">0</span> сек.
        </div>
    </div>
    <button class="voice-message-btn" id="voice-message-btn">
        <img src="https://images.icon-icons.com/2066/PNG/512/mic_icon_125214.png" alt="Запись">
    </button>
</div>
    </div>
</div>

<!-- Всплывающее меню для кнопки фото -->
<div class="photo-options-menu hidden" id="photo-options-menu">
    <button class="photo-option" data-type="photo-video">
        <img src="https://cdn-icons-png.flaticon.com/512/266/266074.png" alt="Фото/Видео">
        <span>Фото и видео</span>
    </button>
    <button class="photo-option" data-type="documents">
        <img src="https://cdn-icons-png.flaticon.com/512/2991/2991112.png" alt="Документы">
        <span>Документы</span>
    </button>
    <button class="photo-option" data-type="poll">
        <img src="https://cdn-icons-png.flaticon.com/512/3034/3034626.png" alt="Опрос">
        <span>Создать опрос</span>
    </button>
    <button class="photo-option" data-type="location">
        <img src="https://cdn-icons-png.flaticon.com/512/535/535137.png" alt="Геолокация">
        <span>Геолокация</span>
    </button>
</div>


<!-- Add this to your HTML -->
<div class="video-message-container hidden" id="video-loading-overlay">
    <div class="video-loading-content">
        <div class="video-loading-spinner"></div>
        <div class="video-loading-text">Загрузка видео...</div>
        <div class="video-loading-progress">0 MB / 0 MB</div>
        <button class="video-loading-cancel">Отмена</button>
    </div>
</div>




    <!-- Контекстное меню -->
    <div class="context-menu" id="context-menu">
        <div class="context-menu-item add-friend hidden" id="context-menu-add">Добавить в друзья</div>
        <div class="context-menu-item remove-friend hidden" id="context-menu-remove">Удалить из друзей</div>
    </div>

    <!-- Модальное окно выхода -->
    <div class="modal-overlay hidden" id="logout-overlay"></div>
    <div class="logout-modal hidden" id="logout-modal">
        <button class="modal-close-btn" id="logout-close-btn">×</button>
        <div class="logout-text">Выйти из аккаунта</div>
        <div class="logout-buttons">
            <button class="logout-button logout-cancel" id="logout-cancel-btn">Отмена</button>
            <button class="logout-button logout-confirm" id="logout-confirm-btn">Выйти</button>
        </div>
    </div>

<div class="message-context-menu hidden" id="message-context-menu">
    <div class="message-context-item" id="message-reply">Ответить</div>
    <div class="message-context-item" id="message-edit">Изменить</div>
    <div class="message-context-item" id="message-pin">Закрепить</div>
    <div class="message-context-item" id="message-delete">Удалить</div>
    <div class="message-context-item" id="message-delete-for-me" style="display: none;">Удалить у меня</div>
    <div class="message-context-item" id="message-forward">Переслать</div>
    <div class="message-context-item" id="message-copy">Копировать</div>
</div>

    <script src="eel.js"></script>
    <script>
        let currentUser = null;
        let contextMenu = null;
        let contextMenuTarget = null;
        let currentChatUserId = null;
        let lastMessageId = null;
        let activeChats = {};
        let readStatusInterval = null;
        let statusUpdateInterval = null;
        let onlineStatusInterval = null;
        let mediaRecorder = null;
        let audioChunks = [];
        let recordingStartTime = 0;
        let audioContext = null;
        let analyser = null;
        let visualizationInterval = null;
        let currentPlayingAudio = null;
        let voiceMessagePlaying = false;
        let currentPlayingVoiceElement = null;
        let currentContextMessage = null; 
        let chatInputs = {};
        let scrollPositions = {};
    let isDraggingScroll = false;
    let scrollDragStartY = 0;
    let scrollThumbStartY = 0;
    

    

async function updateLastMessageAfterDelete(chatUserId) {
    try {
        const lastMessage = await eel.get_last_message(localStorage.getItem('user_id'), chatUserId)();
        const userCard = document.querySelector(`.user-bar[data-user-id="${chatUserId}"]`);
        
        if (!userCard) return;
        
        const lastMsgDiv = userCard.querySelector('.last-message');
        const contentWrapper = userCard.querySelector('.user-content-wrapper');
        
        if (lastMessage) {
            let displayText = lastMessage.text;
            if (displayText.length > 25) {
                displayText = displayText.substring(0, 22) + '...';
            }
            
            if (lastMessage.sender_id === localStorage.getItem('user_id')) {
                if (lastMsgDiv) {
                    lastMsgDiv.innerHTML = `<span class="you-indicator">Вы:</span> ${displayText}`;
                } else if (contentWrapper) {
                    const newLastMsgDiv = document.createElement('div');
                    newLastMsgDiv.className = 'last-message';
                    newLastMsgDiv.innerHTML = `<span class="you-indicator">Вы:</span> ${displayText}`;
                    contentWrapper.appendChild(newLastMsgDiv);
                }
            } else {
                if (lastMsgDiv) {
                    lastMsgDiv.textContent = displayText;
                } else if (contentWrapper) {
                    const newLastMsgDiv = document.createElement('div');
                    newLastMsgDiv.className = 'last-message';
                    newLastMsgDiv.textContent = displayText;
                    contentWrapper.appendChild(newLastMsgDiv);
                }
            }
        } else {
            // Если сообщений нет, удаляем блок last-message
            if (lastMsgDiv) {
                lastMsgDiv.remove();
            }
        }
    } catch (error) {
        console.error('Ошибка при обновлении последнего сообщения:', error);
    }
}

document.addEventListener('DOMContentLoaded', async function() {

document.addEventListener('DOMContentLoaded', function() {
    const fileInput = document.getElementById('file-input');
    if (fileInput) {
        fileInput.addEventListener('change', handleFileSelect);
    }
});

    // Проверяем авторизацию
    const user_id = localStorage.getItem('user_id');
    if (!user_id) {
        window.location.href = 'login.html';
        return;
    }
        initCustomScroll();

            // Добавляем обработчик перед выгрузкой страницы
            window.addEventListener('beforeunload', function() {
                stopVoiceMessage();
                if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                    mediaRecorder.stop();
                }
            });

            // Запускаем отправку статуса онлайн
            startOnlineStatusUpdates();

            // Загружаем данные пользователя
            try {
                currentUser = await eel.get_user_data(user_id)();
                if (!currentUser) {
                    localStorage.removeItem('user_id');
                    window.location.href = 'login.html';
                    return;
                }
            } catch (error) {
                localStorage.removeItem('user_id');
                window.location.href = 'login.html';
                return;
            }

            // Устанавливаем аватар текущего пользователя
            document.getElementById('top-avatar').style.backgroundImage = 'url(https://cdn-icons-png.flaticon.com/512/3135/3135715.png)';

            // Инициализация поиска
            const searchInput = document.querySelector('.search-input');
            const clearBtn = document.querySelector('.clear-btn');
            
            searchInput.addEventListener('input', async function() {
                const searchTerm = this.value.trim();
                if (searchTerm.length > 0) {
                    const users = await eel.search_users(searchTerm, user_id)();
                    displaySearchResults(users);
                } else {
                    loadFriends();
                }
            });

            clearBtn.addEventListener('click', function() {
                searchInput.value = '';
                searchInput.focus();
                loadFriends();
            });

            // Инициализация контекстного меню
            contextMenu = document.getElementById('context-menu');
            document.addEventListener('click', closeContextMenu);
            document.getElementById('context-menu-add').addEventListener('click', handleAddFriend);
            document.getElementById('context-menu-remove').addEventListener('click', handleRemoveFriend);

            // Обработчики для меню выхода
            document.querySelector('.menu-icon').addEventListener('click', function() {
                document.getElementById('logout-overlay').classList.remove('hidden');
                document.getElementById('logout-modal').classList.remove('hidden');
            });

            document.getElementById('logout-close-btn').addEventListener('click', closeLogoutModal);
            document.getElementById('logout-cancel-btn').addEventListener('click', closeLogoutModal);
            document.getElementById('logout-overlay').addEventListener('click', closeLogoutModal);
            document.getElementById('logout-confirm-btn').addEventListener('click', function() {
                eel.update_last_online(localStorage.getItem('user_id'))();
                localStorage.removeItem('user_id');
                window.location.href = 'login.html';
            });






            // Обработчик нажатия ESC
document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape') {
        // Если открыто модальное окно удаления - закрываем его
        if (!document.getElementById('delete-message-modal').classList.contains('hidden')) {
            document.getElementById('delete-message-overlay').classList.add('hidden');
            document.getElementById('delete-message-modal').classList.add('hidden');
            return;
        }
        
        // Если открыт чат - обрабатываем закрытие
        if (!document.getElementById('chat-container').classList.contains('hidden')) {
            // Сбрасываем currentChatUserId только если это не чат с самим собой
            if (currentChatUserId !== localStorage.getItem('user_id')) {
                currentChatUserId = null;
            }
            
            // Скрываем контейнер чата и показываем дефолтный экран
            document.getElementById('default-content').classList.remove('hidden');
            document.getElementById('chat-container').classList.add('hidden');
            
            // Убираем выделение активного чата
            document.querySelectorAll('.user-bar').forEach(el => {
                el.classList.remove('active-chat');
            });
            
            // Останавливаем воспроизведение голосовых сообщений
            stopVoiceMessage();
            currentPlayingAudio = null;
            voiceMessagePlaying = false;
            currentPlayingVoiceElement = null;
            
            // Очищаем интервалы
            if (readStatusInterval) {
                clearInterval(readStatusInterval);
                readStatusInterval = null;
            }
            if (statusUpdateInterval) {
                clearInterval(statusUpdateInterval);
                statusUpdateInterval = null;
            }
            
            // Для чата с самим собой сохраняем возможность открыть его снова
            if (currentChatUserId === localStorage.getItem('user_id')) {
                const selfChat = document.querySelector(`.user-bar[data-user-id="${currentChatUserId}"]`);
                if (selfChat) {
                    selfChat.classList.add('active-chat');
                }
            }
        }
    }
});


document.getElementById('message-delete-for-me').addEventListener('click', async () => {
    if (!currentContextMessage) {
        messageContextMenu.classList.add('hidden');
        return;
    }
    
    const messageId = currentContextMessage.dataset.id;
    try {
        currentContextMessage.remove();
        
        if (currentChatUserId && activeChats[currentChatUserId]) {
            const messagesContainer = document.getElementById('chat-messages');
            activeChats[currentChatUserId].messages = messagesContainer.innerHTML;
            
            if (activeChats[currentChatUserId].messagesData) {
                activeChats[currentChatUserId].messagesData = 
                    activeChats[currentChatUserId].messagesData.filter(m => m.id !== messageId);
            }
        }
        
        // Обновляем последнее сообщение на карточке
        await updateLastMessageAfterDelete(currentChatUserId);
    } catch (error) {
        console.error('Ошибка при удалении:', error);
        alert('Ошибка при удалении сообщения');
    } finally {
        messageContextMenu.classList.add('hidden');
    }
});

async function handleDelete() {
    if (!currentContextMessage) {
        messageContextMenu.classList.add('hidden');
        return;
    }
    
    const messageId = currentContextMessage.dataset.id;
    const messageElement = document.querySelector(`.message[data-id="${messageId}"]`);
    const isMyMessage = messageElement.classList.contains('my-message');
    
    if (!isMyMessage) {
        try {
            const result = await eel.delete_message(messageId)();
            if (result.success) {
                currentContextMessage.remove();
                
                if (currentChatUserId && activeChats[currentChatUserId]) {
                    const messagesContainer = document.getElementById('chat-messages');
                    activeChats[currentChatUserId].messages = messagesContainer.innerHTML;
                    
                    if (activeChats[currentChatUserId].messagesData) {
                        activeChats[currentChatUserId].messagesData = 
                            activeChats[currentChatUserId].messagesData.filter(m => m.id !== messageId);
                    }
                }
                
                await updateLastMessageAfterDelete(currentChatUserId);
            } else {
                alert(result.message || 'Не удалось удалить сообщение');
            }
        } catch (error) {
            console.error('Ошибка при удалении:', error);
            alert('Ошибка при удалении сообщения');
        } finally {
            messageContextMenu.classList.add('hidden');
        }
        return;
    }
    
    // Показать модальное окно для своих сообщений
    document.getElementById('delete-message-overlay').classList.remove('hidden');
    document.getElementById('delete-message-modal').classList.remove('hidden');
    
    // Обработчики для модального окна
    const closeDeleteModal = () => {
        document.getElementById('delete-message-overlay').classList.add('hidden');
        document.getElementById('delete-message-modal').classList.add('hidden');
        messageContextMenu.classList.add('hidden');
    };
    
    document.getElementById('delete-message-close-btn').addEventListener('click', closeDeleteModal, { once: true });
    document.getElementById('delete-message-cancel-btn').addEventListener('click', closeDeleteModal, { once: true });
    document.getElementById('delete-message-overlay').addEventListener('click', closeDeleteModal, { once: true });
    
    document.getElementById('delete-for-all-btn').addEventListener('click', async () => {
        try {
            const result = await eel.delete_message(messageId)();
            if (result.success) {
                currentContextMessage.remove();
                
                if (currentChatUserId && activeChats[currentChatUserId]) {
                    const messagesContainer = document.getElementById('chat-messages');
                    activeChats[currentChatUserId].messages = messagesContainer.innerHTML;
                    
                    if (activeChats[currentChatUserId].messagesData) {
                        activeChats[currentChatUserId].messagesData = 
                            activeChats[currentChatUserId].messagesData.filter(m => m.id !== messageId);
                    }
                }
                
                await updateLastMessageAfterDelete(currentChatUserId);
            } else {
                alert(result.message || 'Не удалось удалить сообщение');
            }
        } catch (error) {
            console.error('Ошибка при удалении:', error);
            alert('Ошибка при удалении сообщения');
        } finally {
            closeDeleteModal();
        }
    }, { once: true });
    
    document.getElementById('delete-for-me-btn').addEventListener('click', async () => {
        try {
            currentContextMessage.remove();
            
            if (currentChatUserId && activeChats[currentChatUserId]) {
                const messagesContainer = document.getElementById('chat-messages');
                activeChats[currentChatUserId].messages = messagesContainer.innerHTML;
                
                if (activeChats[currentChatUserId].messagesData) {
                    activeChats[currentChatUserId].messagesData = 
                        activeChats[currentChatUserId].messagesData.filter(m => m.id !== messageId);
                }
            }
            
            await updateLastMessageAfterDelete(currentChatUserId);
        } catch (error) {
            console.error('Ошибка при удалении:', error);
            alert('Ошибка при удалении сообщения');
        } finally {
            closeDeleteModal();
        }
    }, { once: true });
}

            // Обработчик клика по карточке пользователя
            document.addEventListener('click', function(e) {
                let userBar = e.target.closest('.user-bar');
                if (userBar) {
                    const userId = userBar.dataset.userId;
                    openChat(userId);
                    
                    document.querySelectorAll('.user-bar').forEach(el => {
                        el.classList.remove('active-chat');
                    });
                    userBar.classList.add('active-chat');
                }
            });
            
document.getElementById('message-input').addEventListener('keypress', async function(e) {
    if (e.key === 'Enter' && this.value.trim()) {
        await sendMessage(this.value.trim());
        this.value = '';
    }
});

            // Инициализация голосовых сообщений
            document.getElementById('voice-message-btn').addEventListener('mousedown', startRecording);
            document.getElementById('voice-message-btn').addEventListener('touchstart', startRecording);
            document.getElementById('voice-message-btn').addEventListener('mouseup', stopRecording);
            document.getElementById('voice-message-btn').addEventListener('touchend', stopRecording);
            document.getElementById('voice-message-btn').addEventListener('mouseleave', stopRecording);

            // Проверка новых сообщений каждые 2 секунды
            setInterval(checkForNewMessages, 2000);

            // Первоначальная загрузка друзей
            await loadFriends();
        });



function initCustomScroll() {
    const messagesWrapper = document.getElementById('chat-messages-wrapper');
    const scrollbar = document.getElementById('custom-scrollbar');
    const scrollThumb = document.getElementById('custom-scrollbar-thumb');
    const rightContainer = document.querySelector('.right-container');
    
    let isDraggingScroll = false;
    let scrollDragStartY = 0;
    let scrollThumbStartY = 0;

    // Функция обновления позиции и размера ползунка
    function updateScrollThumb() {
        if (!messagesWrapper) return;
        
        const { scrollHeight, clientHeight, scrollTop } = messagesWrapper;
        
        // Не показывать скроллбар если контент помещается
        if (scrollHeight <= clientHeight) {
            scrollbar.style.display = 'none';
            return;
        }
        
        scrollbar.style.display = 'block';
        const thumbHeight = Math.max(20, (clientHeight / scrollHeight) * clientHeight);
        const thumbPosition = (scrollTop / (scrollHeight - clientHeight)) * (clientHeight - thumbHeight);
        
        scrollThumb.style.height = `${thumbHeight}px`;
        scrollThumb.style.top = `${thumbPosition}px`;
    }
    
    // Обработчики для перетаскивания ползунка
    scrollThumb.addEventListener('mousedown', (e) => {
        isDraggingScroll = true;
        scrollThumb.classList.add('dragging'); // Добавляем класс при начале перетаскивания
        scrollDragStartY = e.clientY;
        scrollThumbStartY = parseInt(scrollThumb.style.top || '0');
        e.preventDefault();
        
        document.addEventListener('mousemove', handleScrollMove);
        document.addEventListener('mouseup', handleScrollEnd);
    });
    
    const handleScrollMove = (e) => {
        if (!isDraggingScroll) return;
        
        const deltaY = e.clientY - scrollDragStartY;
        let newThumbPosition = scrollThumbStartY + deltaY;
        
        // Ограничиваем позицию ползунка
        const maxPosition = messagesWrapper.clientHeight - scrollThumb.offsetHeight;
        newThumbPosition = Math.max(0, Math.min(maxPosition, newThumbPosition));
        
        // Обновляем позицию ползунка
        scrollThumb.style.top = `${newThumbPosition}px`;
        
        // Прокручиваем контент
        const scrollRatio = newThumbPosition / maxPosition;
        messagesWrapper.scrollTop = scrollRatio * (messagesWrapper.scrollHeight - messagesWrapper.clientHeight);
    };
    
    const handleScrollEnd = () => {
        isDraggingScroll = false;
        scrollThumb.classList.remove('dragging'); // Убираем класс при окончании перетаскивания
        document.removeEventListener('mousemove', handleScrollMove);
        document.removeEventListener('mouseup', handleScrollEnd);
    };
    
    // Прокрутка при клике на область скроллбара
    scrollbar.addEventListener('click', (e) => {
        if (e.target === scrollbar) {
            const rect = scrollbar.getBoundingClientRect();
            const clickPosition = e.clientY - rect.top;
            const thumbHeight = scrollThumb.offsetHeight;
            
            // Позиционируем ползунок по центру клика
            let newThumbPosition = clickPosition - thumbHeight / 2;
            newThumbPosition = Math.max(0, Math.min(rect.height - thumbHeight, newThumbPosition));
            scrollThumb.style.top = `${newThumbPosition}px`;
            
            // Прокручиваем контент
            const scrollRatio = newThumbPosition / (rect.height - thumbHeight);
            messagesWrapper.scrollTop = scrollRatio * (messagesWrapper.scrollHeight - messagesWrapper.clientHeight);
        }
    });
    
    // Обновляем ползунок при прокрутке колесом
    messagesWrapper.addEventListener('scroll', updateScrollThumb);
    
    // Инициализируем ползунок
    updateScrollThumb();
    
    // Обновляем ползунок при изменении размера окна
    window.addEventListener('resize', updateScrollThumb);
    
    // Обновляем ползунок при изменении содержимого
    const observer = new MutationObserver(updateScrollThumb);
    observer.observe(messagesWrapper, { childList: true, subtree: true });
}
        function startOnlineStatusUpdates() {
            updateOnlineStatus();
            onlineStatusInterval = setInterval(updateOnlineStatus, 30000);
            window.addEventListener('beforeunload', updateOnlineStatus);
        }

        async function updateOnlineStatus() {
            try {
                await eel.update_last_online(localStorage.getItem('user_id'))();
            } catch (error) {
                console.error('Ошибка обновления статуса онлайн:', error);
            }
        }

        function closeLogoutModal() {
            document.getElementById('logout-overlay').classList.add('hidden');
            document.getElementById('logout-modal').classList.add('hidden');
        }


        function closeChat(softClose = false) {
    document.getElementById('default-content').classList.remove('hidden');
    document.getElementById('chat-container').classList.add('hidden');
    document.querySelectorAll('.user-bar').forEach(el => {
        el.classList.remove('active-chat');
    });
    
    stopVoiceMessage();
    currentPlayingAudio = null;
    voiceMessagePlaying = false;
    currentPlayingVoiceElement = null;
    
    // Сбрасываем currentChatUserId только если это не softClose
    if (!softClose) {
        currentChatUserId = null;
    }
    
    lastMessageId = null;
    
    if (readStatusInterval) {
        clearInterval(readStatusInterval);
        readStatusInterval = null;
    }
    if (statusUpdateInterval) {
        clearInterval(statusUpdateInterval);
        statusUpdateInterval = null;
    }
}




// Add this to your script
function formatFileSize(bytes) {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat(bytes / Math.pow(k, i)).toFixed(2) + ' ' + sizes[i];
}

// Add this to your DOMContentLoaded event
document.addEventListener('click', function(e) {
    const videoLoadElement = e.target.closest('.video-loading');
    if (videoLoadElement) {
        const messageId = videoLoadElement.dataset.messageId;
        loadVideoMessage(messageId);
    }
});

async function loadVideoMessage(messageId) {

    const progressElement = loadingOverlay.querySelector('.video-loading-progress');
const totalSize = response.file_size;
let loaded = 0;
const updateProgress = (chunkSize) => {
    loaded += chunkSize;
    progressElement.textContent = `${(loaded / (1024 * 1024)).toFixed(2)} MB / ${(totalSize / (1024 * 1024)).toFixed(2)} MB`;
};
    try {
        const videoElement = document.querySelector(`.video-preview[data-message-id="${messageId}"]`);
        const loadingElement = document.querySelector(`.video-loading[data-message-id="${messageId}"]`);
        
        if (!videoElement || !loadingElement) return;
        
        // Показываем оверлей загрузки
        const loadingOverlay = document.createElement('div');
        loadingOverlay.className = 'video-loading-overlay';
        loadingOverlay.innerHTML = `
            <div class="video-loading-content">
                <div class="video-loading-spinner"></div>
                <div class="video-loading-text">Загрузка видео...</div>
                <div class="video-loading-progress">0 MB / 0 MB</div>
                <button class="video-loading-cancel">Отмена</button>
            </div>
        `;
        
        document.body.appendChild(loadingOverlay);
        
        // Получаем данные видео
        const response = await eel.get_media_message(messageId)();
        if (!response.success) {
            throw new Error(response.message);
        }
        
        // Устанавливаем источник видео как base64
        videoElement.src = `data:video/mp4;base64,${response.media_data}`;
        loadingElement.classList.add('hidden');
        videoElement.classList.remove('hidden');
        loadingOverlay.remove();
        
        // Помечаем как прочитанное, если это не мое сообщение
        if (!videoElement.closest('.my-message')) {
            await eel.mark_messages_as_read(
                videoElement.closest('.message').dataset.sender_id,
                localStorage.getItem('user_id')
            )();
        }
        
        // Обработчик отмены загрузки
        const cancelBtn = loadingOverlay.querySelector('.video-loading-cancel');
        if (cancelBtn) {
            cancelBtn.addEventListener('click', () => {
                loadingOverlay.remove();
            });
        }
    } catch (error) {
        console.error('Ошибка загрузки видео:', error);
        alert('Ошибка при загрузке видео');
        document.querySelector('.video-loading-overlay')?.remove();
    }
}

async function sendMedia() {
    const fileInput = document.getElementById('file-input');
    if (!fileInput.files.length) return;
    
    const file = fileInput.files[0];
    const caption = mediaCaptionInput.value.trim();
    
    try {
        const reader = new FileReader();
        reader.onload = async (event) => {
            const fileData = event.target.result.split(',')[1];
            const fileType = file.type.startsWith('video/') ? 'video' : 'image';
            
            // Показываем индикатор загрузки
            const loadingIndicator = document.createElement('div');
            loadingIndicator.className = 'loading-indicator';
            loadingIndicator.textContent = 'Отправка...';
            mediaSendModal.appendChild(loadingIndicator);
            mediaSendButton.disabled = true;
            
            try {
                const result = await eel.send_media_message(
                    localStorage.getItem('user_id'),
                    currentChatUserId,
                    fileData,
                    fileType,
                    file.name,
                    caption
                )();
                
                if (result.success) {
                    const message = {
                        id: result.message_id,
                        sender_id: localStorage.getItem('user_id'),
                        receiver_id: currentChatUserId,
                        text: caption || (fileType === 'video' ? '[Видео]' : '[Фото]'),
                        timestamp: result.timestamp,
                        read: result.read,
                        isMedia: true,
                        mediaType: fileType,
                        file_id: result.file_id,  // Сохраняем ID файла
                        filename: file.name
                    };
                    
                    addMessageToChat(message, true, true);
                    lastMessageId = message.id;
                    
                    if (activeChats[currentChatUserId]) {
                        const messagesContainer = document.getElementById('chat-messages');
                        activeChats[currentChatUserId].messages = messagesContainer.innerHTML;
                        activeChats[currentChatUserId].lastMessageId = lastMessageId;
                    }
                    
                    updateLastMessageOnUserCard(
                        currentChatUserId, 
                        fileType === 'video' ? 'Видео' : 'Фото', 
                        true
                    );
                    
                    closeMediaModal();
                } else {
                    alert('Ошибка при отправке: ' + result.message);
                }
            } catch (error) {
                console.error('Ошибка отправки:', error);
                alert('Ошибка при отправке файла');
            } finally {
                loadingIndicator.remove();
                mediaSendButton.disabled = false;
            }
        };
        reader.readAsDataURL(file);
    } catch (error) {
        console.error('Ошибка чтения файла:', error);
        alert('Ошибка при обработке файла');
    }
}

async function checkAndRestoreReplyState() {
    if (!currentChatUserId) return;
    
    try {
        const replyState = await eel.get_reply_state(localStorage.getItem('user_id'), currentChatUserId)();
        if (replyState.success) {
            const message = await eel.get_message_data(replyState.message_id)();
            if (message) {
                const replyContainer = document.getElementById('reply-container');
                const isMyMessage = message.sender_id === localStorage.getItem('user_id');
                
                replyContainer.dataset.messageId = message.id;
                replyContainer.innerHTML = `
                    <div class="reply-header">
                        <div class="reply-author">${isMyMessage ? 'Вы' : document.getElementById('chat-username').textContent}</div>
                        <div class="reply-close">×</div>
                    </div>
                    <div class="reply-text">${message.text.length > 50 ? message.text.substring(0, 47) + '...' : message.text}</div>
                `;
                
                replyContainer.classList.remove('hidden');
                document.querySelector('.message-input-container').classList.add('expanded');
                
                // Обработчик закрытия ответа
                replyContainer.querySelector('.reply-close').addEventListener('click', async () => {
                    replyContainer.classList.add('hidden');
                    document.querySelector('.message-input-container').classList.remove('expanded');
                    await eel.clear_reply_state(localStorage.getItem('user_id'), currentChatUserId)();
                });
            }
        }
    } catch (error) {
        console.error('Ошибка восстановления состояния ответа:', error);
    }
}



async function openChat(userId) {
    // Сохраняем текущую позицию прокрутки перед переключением
    if (currentChatUserId) {
        const messagesWrapper = document.getElementById('chat-messages-wrapper');
        if (messagesWrapper) {
            scrollPositions[currentChatUserId] = messagesWrapper.scrollTop;
        }
        
        const currentText = document.getElementById('message-input').value;
        if (currentText.trim()) {
            await eel.save_draft_message(localStorage.getItem('user_id'), currentChatUserId, currentText)();
        }
        chatInputs[currentChatUserId] = currentText;
    }
    
    // Если чат уже открыт, просто прокручиваем сообщения
    if (currentChatUserId === userId && !document.getElementById('chat-container').classList.contains('hidden')) {
        const messagesWrapper = document.getElementById('chat-messages-wrapper');
        if (messagesWrapper) {
            messagesWrapper.scrollTop = scrollPositions[userId] || messagesWrapper.scrollHeight;
        }
        return;
    }

    // Полностью останавливаем текущее воспроизведение
    stopVoiceMessage();
    currentPlayingAudio = null;
    voiceMessagePlaying = false;
    currentPlayingVoiceElement = null;
    
    // Сбрасываем контейнер ответа при переходе в другой чат
    const replyContainer = document.getElementById('reply-container');
    if (replyContainer && !replyContainer.classList.contains('hidden')) {
        replyContainer.classList.add('hidden');
        document.querySelector('.message-input-container').classList.remove('expanded');
    }
    
    if (readStatusInterval) clearInterval(readStatusInterval);
    if (statusUpdateInterval) clearInterval(statusUpdateInterval);

    currentChatUserId = userId;
    const user = await eel.get_user_data(userId)();
    
    if (user) {
        document.getElementById('default-content').classList.add('hidden');
        document.getElementById('chat-container').classList.remove('hidden');
        document.getElementById('chat-username').textContent = 
            userId === localStorage.getItem('user_id') ? 'Избранное' : user.nickname;
        await updateUserStatus();
        
        // Инициализируем кастомный скроллбар (добавлено для чата с самим собой)
        initCustomScroll();
        
        if (activeChats[userId]) {
            document.getElementById('chat-messages').innerHTML = activeChats[userId].messages;
            lastMessageId = activeChats[userId].lastMessageId;
            
            // Восстанавливаем позицию прокрутки или прокручиваем вниз
            setTimeout(() => {
                const messagesWrapper = document.getElementById('chat-messages-wrapper');
                if (messagesWrapper) {
                    if (scrollPositions[userId] !== undefined) {
                        messagesWrapper.scrollTop = scrollPositions[userId];
                    } else {
                        messagesWrapper.scrollTop = messagesWrapper.scrollHeight;
                    }
                }
            }, 0);
            
            // Обновляем индикаторы перед установкой обработчиков
            await updateListenIndicators();
            setupVoiceMessageHandlers();
        } else {
            await loadChatHistory(userId);
        }
        
        // Восстанавливаем текст из черновика или из кеша
        const draftText = await eel.get_draft_message(localStorage.getItem('user_id'), userId)();
        document.getElementById('message-input').value = draftText || chatInputs[userId] || '';
        
        // Восстанавливаем состояние ответа
        await checkAndRestoreReplyState();
        
        readStatusInterval = setInterval(updateReadStatus, 2000);
        updateReadStatus();
        
        statusUpdateInterval = setInterval(updateUserStatus, 5000);
        
        // Помечаем карточку пользователя как активную
        document.querySelectorAll('.user-bar').forEach(el => {
            el.classList.remove('active-chat');
        });
        const userCard = document.querySelector(`.user-bar[data-user-id="${userId}"]`);
        if (userCard) {
            userCard.classList.add('active-chat');
        }
    } else {
        console.error('User data not found for ID:', userId);
        document.getElementById('chat-messages').innerHTML = 
            '<div class="error-message">Ошибка загрузки данных пользователя</div>';
    }
}


async function updateListenIndicators() {
    if (!currentChatUserId) return;
    
    try {
        const messages = Array.from(document.querySelectorAll('.message'))
            .map(el => ({id: el.dataset.id, isVoice: !!el.querySelector('.voice-message')}))
            .filter(msg => msg.id && msg.isVoice);
        
        if (messages.length === 0) return;
        
        // Проверяем localStorage
        const listenedMessages = JSON.parse(localStorage.getItem('listenedVoiceMessages') || '{}');
        
        // Сначала обновляем индикаторы на основе localStorage
        messages.forEach(msg => {
            const messageElement = document.querySelector(`.message[data-id="${msg.id}"]`);
            if (messageElement) {
                const voiceMessage = messageElement.querySelector('.voice-message');
                if (voiceMessage) {
                    const indicator = voiceMessage.querySelector('.listen-indicator');
                    if (indicator) {
                        const isMyMessage = messageElement.classList.contains('my-message');
                        
                        // Если сообщение уже прослушано (по данным localStorage), скрываем индикатор
                        if (listenedMessages[msg.id] && !isMyMessage) {
                            indicator.style.opacity = '0';
                        }
                    }
                }
            }
        });
        
        // Затем проверяем статус на сервере
        const listenedStatus = await eel.check_voice_messages_listened_status(messages.map(m => m.id))();
        
        messages.forEach(msg => {
            const messageElement = document.querySelector(`.message[data-id="${msg.id}"]`);
            if (messageElement) {
                const voiceMessage = messageElement.querySelector('.voice-message'); // Исправлено здесь
                if (voiceMessage) {
                    const indicator = voiceMessage.querySelector('.listen-indicator');
                    if (indicator) {
                        const isListened = listenedStatus[msg.id] || false;
                        const isMyMessage = messageElement.classList.contains('my-message');
                        
                        if (!isMyMessage && isListened) {
                            indicator.style.opacity = '0';
                            
                            // Сохраняем в localStorage
                            const listenedMessages = JSON.parse(localStorage.getItem('listenedVoiceMessages') || '{}');
                            listenedMessages[msg.id] = true;
                            localStorage.setItem('listenedVoiceMessages', JSON.stringify(listenedMessages));
                        }
                    }
                }
            }
        });
    } catch (error) {
        console.error('Ошибка при обновлении индикаторов прослушивания:', error);
    }
}


function setupVoiceMessageHandlers() {
    const voiceMessages = document.querySelectorAll('.voice-message');
    voiceMessages.forEach((voiceMessage) => {
        const playBtn = voiceMessage.querySelector('.play-voice-btn');
        playBtn.addEventListener('click', async () => {
            const isPlaying = voiceMessage.classList.contains('playing');
            const messageElement = voiceMessage.closest('.message');
            const isMyMessage = messageElement.classList.contains('my-message');
            
            if (isPlaying) {
                stopVoiceMessage(voiceMessage);
            } else {
                // Для своих сообщений используем данные из кеша
                if (isMyMessage) {
                    const messageId = messageElement.dataset.id;
                    const cachedMessage = activeChats[currentChatUserId]?.messagesData?.find(m => m.id === messageId);
                    if (cachedMessage && cachedMessage.voiceData) {
                        playVoiceMessage(cachedMessage.voiceData, voiceMessage, cachedMessage.duration);
                        return;
                    }
                }
                
                // Для чужих сообщений запрашиваем данные с сервера
                const messageId = messageElement.dataset.id;
                const response = await eel.get_voice_message(messageId)();
                if (response.success) {
                    playVoiceMessage(response.voice_data, voiceMessage, response.duration);
                } else {
                    alert('Не удалось загрузить голосовое сообщение');
                }
            }
        });
    });
}

        async function updateUserStatus() {
            if (!currentChatUserId) return;

            try {
                const user = await eel.get_user_data(currentChatUserId)();
                if (!user) return;

                const statusElement = document.getElementById('chat-status');
                const now = new Date();
                const lastOnline = new Date(user.last_online + ' UTC');

                const diffMinutes = Math.floor((now - lastOnline) / (1000 * 60));

                if (currentChatUserId === localStorage.getItem('user_id')) {
                    statusElement.textContent = '';
                    statusElement.classList.remove('online');
                } else if (diffMinutes < 5) {
                    statusElement.textContent = 'В сети';
                    statusElement.classList.add('online');
                } else {
                    statusElement.textContent = `Был(а) в сети ${formatTimeAgo(lastOnline)}`;
                    statusElement.classList.remove('online');
                }

                updateOnlineStatusInContacts();
            } catch (error) {
                console.error('Ошибка при обновлении статуса:', error);
            }
        }

        function updateOnlineStatusInContacts() {
            const userBars = document.querySelectorAll('.user-bar:not(.current-user)');
            userBars.forEach(async bar => {
                const userId = bar.dataset.userId;
                try {
                    const user = await eel.get_user_data(userId)();
                    if (user) {
                        const now = new Date();
                        const lastOnline = new Date(user.last_online + ' UTC');
                        const diffMinutes = Math.floor((now - lastOnline) / (1000 * 60));

                        const avatar = bar.querySelector('.avatar-medium');
                        if (diffMinutes < 5) {
                            avatar.classList.add('online');
                        } else {
                            avatar.classList.remove('online');
                        }
                    }
                } catch (error) {
                    console.error('Ошибка при обновлении статуса контакта:', error);
                }
            });
        }

        function formatTimeAgo(date) {
            const now = new Date();
            const diff = Math.floor((now - date) / 1000);
            
            if (diff < 60) return 'только что';
            if (diff < 3600) return `${Math.floor(diff / 60)} мин. назад`;
            if (diff < 86400) return `${Math.floor(diff / 3600)} ч. назад`;
            
            const days = Math.floor(diff / 86400);
            if (days === 1) return 'вчера';
            if (days < 7) return `${days} дн. назад`;
            
            return date.toLocaleDateString('ru-RU', {
                day: 'numeric',
                month: 'long',
                year: 'numeric'
            });
        }

        async function updateReadStatus() {
    if (!currentChatUserId) return;
    
    try {
        const myMessages = Array.from(document.querySelectorAll('.my-message'))
            .map(el => el.dataset.id)
            .filter(id => id);
        
        if (myMessages.length === 0) return;
        
        const readStatus = await eel.check_message_read_status(myMessages)();
        const listenedStatus = await eel.check_voice_messages_listened_status(myMessages)();
        
        for (const [messageId, isRead] of Object.entries(readStatus)) {
            const messageElement = document.querySelector(`.message[data-id="${messageId}"]`);
            if (messageElement) {
                // Обновляем статус прочтения только для текстовых сообщений
                const voiceMessage = messageElement.querySelector('.voice-message');
                if (!voiceMessage) {
                    const infoElement = messageElement.querySelector('.message-info');
                    if (infoElement) {
                        const timeElement = infoElement.querySelector('span');
                        if (timeElement) {
                            infoElement.innerHTML = `${timeElement.outerHTML}${isRead ? '✓✓' : '✓'}`;
                        }
                    }
                }
                
                // Обновляем индикатор прослушивания для голосовых сообщений
                if (voiceMessage) {
                    const indicator = voiceMessage.querySelector('.listen-indicator');
                    if (indicator) {
                        const isListened = listenedStatus[messageId] || false;
                        indicator.style.opacity = isListened ? '0' : '0.7';
                    }
                }
            }
        }
    } catch (error) {
        console.error('Ошибка при обновлении статуса прочтения:', error);
    }
}

async function loadChatHistory(userId) {
    try {
        const messages = await eel.get_chat_history(localStorage.getItem('user_id'), userId)();
        const messagesContainer = document.getElementById('chat-messages');
        messagesContainer.innerHTML = '';

        if (messages && Array.isArray(messages) && messages.length > 0) {
            messages.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
            
            // Сохраняем данные сообщений
            const messagesData = [];
            
            for (const msg of messages) {
                const isMyMessage = msg.sender_id === localStorage.getItem('user_id');
                addMessageToChat(msg, isMyMessage, false);
                
                if (msg.isVoiceMessage || msg.is_voice) {
                    messagesData.push({
                        id: msg.id,
                        voiceData: msg.voiceData,
                        duration: msg.duration,
                        isVoiceMessage: true
                    });
                }
            }
            
            lastMessageId = messages[messages.length - 1].id;
            
            activeChats[userId] = {
                messages: messagesContainer.innerHTML,
                lastMessageId: lastMessageId,
                messagesData: messagesData
            };
            
            // Прокручиваем вниз только если позиция не сохранена
            setTimeout(() => {
                const messagesWrapper = document.getElementById('chat-messages-wrapper');
                if (messagesWrapper) {
                    if (scrollPositions[userId] !== undefined) {
                        messagesWrapper.scrollTop = scrollPositions[userId];
                    } else {
                        messagesWrapper.scrollTop = messagesWrapper.scrollHeight;
                    }
                }
            }, 0);
            
            setupVoiceMessageHandlers();
        } else {
            messagesContainer.innerHTML = '<div class="no-messages">Нет сообщений</div>';
            lastMessageId = null;
            
            activeChats[userId] = {
                messages: messagesContainer.innerHTML,
                lastMessageId: null,
                messagesData: []
            };
        }
    } catch (error) {
        console.error('Error loading chat history:', error);
        document.getElementById('chat-messages').innerHTML = 
            '<div class="error-message">Ошибка загрузки истории сообщений</div>';
    }
}
async function sendMessage(text) {
    if (!currentChatUserId || !text) return;
    
    try {
        const replyContainer = document.getElementById('reply-container');
        const isReplying = !replyContainer.classList.contains('hidden');
        const replyToId = isReplying ? replyContainer.dataset.messageId : null;
        
        const result = await eel.send_message(
            localStorage.getItem('user_id'),
            currentChatUserId,
            text,
            replyToId
        )();
        
        if (result.success) {
            const message = {
                id: result.message_id,
                sender_id: localStorage.getItem('user_id'),
                receiver_id: currentChatUserId,
                text: text,
                timestamp: result.timestamp,
                read: result.read,
                reply_to: result.reply_to,
                reply_text: result.reply_text,
                reply_sender_id: result.reply_sender_id
            };
            
            addMessageToChat(message, true, true);
            lastMessageId = message.id;
            
            if (activeChats[currentChatUserId]) {
                const messagesContainer = document.getElementById('chat-messages');
                activeChats[currentChatUserId] = {
                    messages: messagesContainer.innerHTML,
                    lastMessageId: lastMessageId
                };
            }
            
            // Обновляем последнее сообщение на карточке пользователя
            updateLastMessageOnUserCard(currentChatUserId, text, true);
            
            // Сбрасываем контейнер ответа и очищаем состояние в БД
            if (replyContainer) {
                replyContainer.classList.add('hidden');
                replyContainer.innerHTML = '';
                document.querySelector('.message-input-container').classList.remove('expanded');
                await eel.clear_reply_state(localStorage.getItem('user_id'), currentChatUserId)();
            }
            
            // Очищаем черновик после успешной отправки
            await eel.clear_draft_message(localStorage.getItem('user_id'), currentChatUserId)();
            chatInputs[currentChatUserId] = '';
        } else {
            console.error("Ошибка при отправке:", result.message);
        }
    } catch (error) {
        console.error('Error sending message:', error);
    }
}

        function updateLastMessageOnUserCard(userId, messageText, isMyMessage) {
            const userCard = document.querySelector(`.user-bar[data-user-id="${userId}"]`);
            if (!userCard) return;
            
            const lastMsgDiv = userCard.querySelector('.last-message');
            let displayText = messageText;
            
            if (displayText.length > 25) {
                displayText = displayText.substring(0, 22) + '...';
            }
            
            if (isMyMessage) {
                if (lastMsgDiv) {
                    lastMsgDiv.innerHTML = `<span class="you-indicator">Вы:</span> ${displayText}`;
                } else {
                    // Если элемента еще нет, создаем его
                    const contentWrapper = userCard.querySelector('.user-content-wrapper');
                    if (contentWrapper) {
                        const newLastMsgDiv = document.createElement('div');
                        newLastMsgDiv.className = 'last-message';
                        newLastMsgDiv.innerHTML = `<span class="you-indicator">Вы:</span> ${displayText}`;
                        contentWrapper.appendChild(newLastMsgDiv);
                    }
                }
            } else {
                if (lastMsgDiv) {
                    lastMsgDiv.textContent = displayText;
                } else {
                    const contentWrapper = userCard.querySelector('.user-content-wrapper');
                    if (contentWrapper) {
                        const newLastMsgDiv = document.createElement('div');
                        newLastMsgDiv.className = 'last-message';
                        newLastMsgDiv.textContent = displayText;
                        contentWrapper.appendChild(newLastMsgDiv);
                    }
                }
            }
        }

function addMessageToChat(message, isMyMessage, scrollToBottom = true) {
    const messagesContainer = document.getElementById('chat-messages');
    
    // Удаляем сообщение "Нет сообщений", если оно есть
    const noMessagesDiv = messagesContainer.querySelector('.no-messages');
    if (noMessagesDiv) {
        noMessagesDiv.remove();
    }
    
    // Создаем элемент сообщения
    const messageElement = document.createElement('div');
    messageElement.className = `message ${isMyMessage ? 'my-message' : 'their-message'}`;
    messageElement.dataset.id = message.id;
    messageElement.dataset.sender_id = message.sender_id;
    
    // Добавляем контент в зависимости от типа сообщения
    if (message.isMedia) {
        // Медиа сообщение (фото/видео)
        const mediaContainer = document.createElement('div');
        mediaContainer.className = 'media-message';
        
        if (message.mediaType === 'image') {
            const img = document.createElement('img');
            img.src = `data:image/jpeg;base64,${message.mediaData}`;
            img.className = 'media-preview';
            img.alt = 'Фото';
            mediaContainer.appendChild(img);
        } else if (message.mediaType === 'video') {
            const videoContainer = document.createElement('div');
            videoContainer.className = 'video-message';
            
            // Создаем элемент загрузки
            const loadingElement = document.createElement('div');
            loadingElement.className = 'video-loading';
            loadingElement.dataset.messageId = message.id;
            loadingElement.innerHTML = `
                <div class="video-load-icon"></div>
                <div class="video-load-text">Загрузить видео</div>
            `;
            
            // Создаем элемент видео (скрытый до загрузки)
            const videoPreview = document.createElement('video');
            videoPreview.className = 'video-preview hidden';
            videoPreview.controls = true;
            videoPreview.dataset.messageId = message.id;
            
            videoContainer.appendChild(loadingElement);
            videoContainer.appendChild(videoPreview);
            mediaContainer.appendChild(videoContainer);
        }
        
        if (message.text) {
            const caption = document.createElement('div');
            caption.className = 'media-caption';
            caption.textContent = message.text;
            mediaContainer.appendChild(caption);
        }
        
        messageElement.appendChild(mediaContainer);
    } else if (message.isVoiceMessage) {
        // Голосовое сообщение
        const voiceMessage = createVoiceMessageElement(message);
        messageElement.appendChild(voiceMessage);
    } else {
        // Текстовое сообщение
        const textElement = document.createElement('div');
        textElement.className = 'message-text';
        textElement.textContent = message.text;
        messageElement.appendChild(textElement);
    }
    
    // Добавляем информацию о сообщении (время, статус прочтения)
    const infoElement = document.createElement('div');
    infoElement.className = 'message-info';
    
    const timeElement = document.createElement('span');
    timeElement.textContent = formatMessageTime(message.timestamp);
    infoElement.appendChild(timeElement);
    
    if (isMyMessage && !message.isVoiceMessage) {
        const readStatus = document.createElement('span');
        readStatus.textContent = message.read ? '✓✓' : '✓';
        infoElement.appendChild(readStatus);
    }
    
    messageElement.appendChild(infoElement);
    
    // Добавляем сообщение в контейнер
    messagesContainer.appendChild(messageElement);
    
    // Прокручиваем вниз, если нужно
    if (scrollToBottom) {
        setTimeout(() => {
            const messagesWrapper = document.getElementById('chat-messages-wrapper');
            if (messagesWrapper) {
                messagesWrapper.scrollTop = messagesWrapper.scrollHeight;
            }
        }, 0);
    }
    
    return messageElement;
}

// Добавим обработчик для загрузки видео
document.addEventListener('click', function(e) {
    const videoLoadElement = e.target.closest('.video-loading');
    if (videoLoadElement) {
        const messageId = videoLoadElement.dataset.messageId;
        loadVideoMessage(messageId);
    }
});

async function loadVideoMessage(messageId) {
    try {
        const videoElement = document.querySelector(`.video-preview[data-message-id="${messageId}"]`);
        const loadingElement = document.querySelector(`.video-loading[data-message-id="${messageId}"]`);
        
        if (!videoElement || !loadingElement) return;
        
        // Показываем оверлей загрузки
        const loadingOverlay = document.createElement('div');
        loadingOverlay.className = 'video-loading-overlay';
        loadingOverlay.innerHTML = `
            <div class="video-loading-content">
                <div class="video-loading-spinner"></div>
                <div class="video-loading-text">Загрузка видео...</div>
                <button class="video-loading-cancel">Отмена</button>
            </div>
        `;
        
        document.body.appendChild(loadingOverlay);
        
        // Получаем данные видео
        const response = await eel.get_media_message(messageId)();
        if (!response.success) {
            throw new Error(response.message);
        }
        
        // Устанавливаем источник видео как base64
        videoElement.src = `data:video/mp4;base64,${response.media_data}`;
        loadingElement.classList.add('hidden');
        videoElement.classList.remove('hidden');
        loadingOverlay.remove();
        
        // Помечаем как прочитанное, если это не мое сообщение
        if (!videoElement.closest('.my-message')) {
            await eel.mark_messages_as_read(
                videoElement.closest('.message').dataset.sender_id,
                localStorage.getItem('user_id')
            )();
        }
        
        // Обработчик отмены загрузки
        const cancelBtn = loadingOverlay.querySelector('.video-loading-cancel');
        if (cancelBtn) {
            cancelBtn.addEventListener('click', () => {
                loadingOverlay.remove();
            });
        }
    } catch (error) {
        console.error('Ошибка загрузки видео:', error);
        alert('Ошибка при загрузке видео');
        document.querySelector('.video-loading-overlay')?.remove();
    }
}


function formatMessageTime(timestamp) {
    const date = new Date(timestamp);
    return date.toLocaleTimeString('ru-RU', { hour: '2-digit', minute: '2-digit' });
}



        async function checkForNewMessages() {
            if (!currentChatUserId) return;
            
            try {
                const newMessages = await eel.check_new_messages(
                    localStorage.getItem('user_id'),
                    lastMessageId
                )();
                
                if (newMessages && newMessages.length > 0) {
                    newMessages.forEach(msg => {
                        if (msg.sender_id === currentChatUserId) {
                            addMessageToChat(msg, false, true);
                            // Обновляем последнее сообщение на карточке
                            updateLastMessageOnUserCard(currentChatUserId, msg.text, false);
                        }
                    });
                    
                    lastMessageId = newMessages[newMessages.length - 1].id;
                    
                    const messagesContainer = document.getElementById('chat-messages');
                    activeChats[currentChatUserId] = {
                        messages: messagesContainer.innerHTML,
                        lastMessageId: lastMessageId
                    };
                    
                    updateOnlineStatusInContacts();
                    
                    // Устанавливаем обработчики для новых голосовых сообщений
                    setupVoiceMessageHandlers();
                }
            } catch (error) {
                console.error('Error checking new messages:', error);
            }
        }
        
        async function loadFriends() {
            const user_id = localStorage.getItem('user_id');
            try {
                currentUser = await eel.get_user_data(user_id)();
                
                const container = document.getElementById('user-container');
                container.innerHTML = '';
                
                // Добавляем карточку текущего пользователя
                const selfCard = createUserCard({
                    user_id: user_id,
                    nickname: currentUser.nickname,
                    isCurrentUser: true
                });
                container.appendChild(selfCard);
                
                // Добавляем друзей
                if (currentUser.friends && currentUser.friends.length > 0) {
                    for (const friendId of currentUser.friends) {
                        const friend = await eel.get_user_data(friendId)();
                        if (friend) {
                            // Получаем последнее сообщение
                            const lastMessage = await eel.get_last_message(user_id, friendId)();
                            const friendCard = createUserCard({
                                user_id: friendId,
                                nickname: friend.nickname,
                                isFriend: true,
                                lastMessage: lastMessage
                            });
                            container.appendChild(friendCard);
                        }
                    }
                    
                    updateOnlineStatusInContacts();
                } else {
                    const noFriends = document.createElement('div');
                    noFriends.className = 'no-friends';
                    noFriends.textContent = 'У вас пока нет друзей. Найдите их через поиск!';
                    container.appendChild(noFriends);
                }
            } catch (error) {
                console.error('Error loading friends:', error);
            }
        }

        function createUserCard(userData) {
            const card = document.createElement('div');
            card.className = 'user-bar' + (userData.isCurrentUser ? ' current-user' : '');
            card.dataset.userId = userData.user_id;
            
            const avatar = document.createElement('div');
            avatar.className = 'avatar-medium';
            avatar.style.backgroundImage = 'url(https://cdn-icons-png.flaticon.com/512/3135/3135715.png)';
            
            const contentWrapper = document.createElement('div');
            contentWrapper.className = 'user-content-wrapper';
            
            const username = document.createElement('div');
            username.className = 'username';
            username.textContent = userData.isCurrentUser ? `Вы (${userData.nickname})` : userData.nickname;
            
            contentWrapper.appendChild(username);
            
            // Добавляем последнее сообщение, если оно есть
            if (userData.lastMessage && !userData.isCurrentUser) {
                const lastMsgDiv = document.createElement('div');
                lastMsgDiv.className = 'last-message';
                
                let messageText = userData.lastMessage.text;
                if (messageText.length > 25) {
                    messageText = messageText.substring(0, 22) + '...';
                }
                
                if (userData.lastMessage.sender_id === localStorage.getItem('user_id')) {
                    lastMsgDiv.innerHTML = `<span class="you-indicator">Вы:</span> ${messageText}`;
                } else {
                    lastMsgDiv.textContent = messageText;
                }
                
                contentWrapper.appendChild(lastMsgDiv);
            }
            
            card.appendChild(avatar);
            card.appendChild(contentWrapper);
            
            if (!userData.isCurrentUser) {
                card.addEventListener('contextmenu', function(e) {
                    e.preventDefault();
                    showContextMenu(e, userData);
                });
            }
            
            return card;
        }

        function showContextMenu(e, userData) {
            closeContextMenu();
            
            contextMenuTarget = userData.user_id;
            
            const addBtn = document.getElementById('context-menu-add');
            const removeBtn = document.getElementById('context-menu-remove');
            
            if (currentUser.friends.includes(userData.user_id)) {
                addBtn.classList.add('hidden');
                removeBtn.classList.remove('hidden');
            } else {
                addBtn.classList.remove('hidden');
                removeBtn.classList.add('hidden');
            }
            
            contextMenu.style.display = 'block';
            contextMenu.style.left = `${e.pageX}px`;
            contextMenu.style.top = `${e.pageY}px`;
        }

        function closeContextMenu() {
            if (contextMenu) {
                contextMenu.style.display = 'none';
            }
            contextMenuTarget = null;
        }

        async function handleAddFriend() {
            if (!contextMenuTarget) return;
            
            const user_id = localStorage.getItem('user_id');
            try {
                const response = await eel.add_friend(user_id, contextMenuTarget)();
                
                if (response.success) {
                    await loadFriends();
                }
                alert(response.message);
            } catch (error) {
                alert('Ошибка при добавлении в друзья');
                console.error('Error adding friend:', error);
            }
            
            closeContextMenu();
        }

        async function handleRemoveFriend() {
            if (!contextMenuTarget) return;
            
            const user_id = localStorage.getItem('user_id');
            try {
                const response = await eel.remove_friend(user_id, contextMenuTarget)();
                
                if (response.success) {
                    await loadFriends();
                    if (currentChatUserId === contextMenuTarget) {
                        closeChat();
                    }
                }
                alert(response.message);
            } catch (error) {
                alert('Ошибка при удалении из друзей');
                console.error('Error removing friend:', error);
            }
            
            closeContextMenu();
        }

        async function displaySearchResults(users) {
            const container = document.getElementById('user-container');
            container.innerHTML = '';
            
            if (users.length === 0) {
                const noResults = document.createElement('div');
                noResults.className = 'no-results';
                noResults.textContent = 'Ничего не найдено';
                container.appendChild(noResults);
                return;
            }
            
            for (const user of users) {
                const isFriend = currentUser.friends.includes(user.user_id);
                // Получаем последнее сообщение для результатов поиска
                const lastMessage = await eel.get_last_message(localStorage.getItem('user_id'), user.user_id)();
                const userCard = createUserCard({
                    user_id: user.user_id,
                    nickname: user.nickname,
                    isFriend: isFriend,
                    lastMessage: lastMessage
                });
                container.appendChild(userCard);
            }
            
            updateOnlineStatusInContacts();
        }

        // Функции для работы с голосовыми сообщениями
        async function startRecording(e) {
    e.preventDefault();
    
    try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        mediaRecorder = new MediaRecorder(stream);
        audioChunks = [];
        recordingStartTime = Date.now();
        
        mediaRecorder.ondataavailable = (e) => {
            if (e.data.size > 0) audioChunks.push(e.data);
        };
        
        mediaRecorder.onstop = async () => {
            const recordingTime = (Date.now() - recordingStartTime) / 1000;
            if (recordingTime < 0.5) {
                alert('Сообщение слишком короткое');
                return;
            }
            
            const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
            await sendVoiceMessage(audioBlob, recordingTime);
        };
        
        mediaRecorder.start(100);
        document.getElementById('message-input').classList.add('hidden');
        document.getElementById('recording-container').classList.remove('hidden');
        updateRecordingTime();
    } catch (error) {
        console.error('Ошибка записи:', error);
        alert('Не удалось получить доступ к микрофону');
    }
}

        function stopRecording(e) {
            e.preventDefault();
            
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
                mediaRecorder.stream.getTracks().forEach(track => track.stop());
                
                // Скрываем индикатор записи
                document.getElementById('recording-container').classList.add('hidden');
                document.getElementById('message-input').classList.remove('hidden');
            }
        }

        function updateRecordingTime() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                const recordingTime = ((Date.now() - recordingStartTime) / 1000).toFixed(1);
                document.getElementById('recording-time').textContent = recordingTime;
                setTimeout(updateRecordingTime, 100);
            }
        }

async function sendVoiceMessage(audioBlob, duration, oldVisualizationData = null) {
    if (!currentChatUserId || !audioBlob) return;
    
    try {
        const reader = new FileReader();
        reader.readAsDataURL(audioBlob);
        
        reader.onload = async () => {
            const audioData = reader.result.split(',')[1];
            
            // Анализируем аудио и создаем визуализацию
            const visualizationData = await analyzeAudioAndCreateVisualization(audioBlob, duration);
            
            const result = await eel.send_voice_message(
                localStorage.getItem('user_id'),
                currentChatUserId,
                audioData,
                duration,
                visualizationData
            )();
            
            if (result.success) {
                const message = {
                    id: result.message_id,
                    sender_id: localStorage.getItem('user_id'),
                    receiver_id: currentChatUserId,
                    text: '[Голосовое сообщение]',
                    timestamp: result.timestamp,
                    read: result.read,
                    isVoiceMessage: true,
                    voiceData: audioData,
                    duration: duration,
                    visualization: visualizationData,
                    listened: currentChatUserId === localStorage.getItem('user_id')
                };
                
                // Инициализируем messagesData, если его нет
                if (!activeChats[currentChatUserId]) {
                    activeChats[currentChatUserId] = {
                        messages: '',
                        lastMessageId: null,
                        messagesData: []
                    };
                } else if (!activeChats[currentChatUserId].messagesData) {
                    activeChats[currentChatUserId].messagesData = [];
                }
                
                addMessageToChat(message, true, true);
                lastMessageId = message.id;
                
                // Сохраняем состояние чата
                const messagesContainer = document.getElementById('chat-messages');
                activeChats[currentChatUserId].messages = messagesContainer.innerHTML;
                activeChats[currentChatUserId].lastMessageId = lastMessageId;
                
                // Добавляем данные сообщения в кеш
                activeChats[currentChatUserId].messagesData.push({
                    id: message.id,
                    voiceData: message.voiceData,
                    duration: message.duration,
                    isVoiceMessage: true,
                    listened: message.listened,
                    visualization: visualizationData
                });
                
                // Обновляем последнее сообщение на карточке
                updateLastMessageOnUserCard(currentChatUserId, 'Голосовое сообщение', true);
                
                // Устанавливаем обработчики для голосовых сообщений
                setupVoiceMessageHandlers();
            }
        };
    } catch (error) {
        console.error('Ошибка отправки голосового сообщения:', error);
    }
}

function createVoiceMessageElement(message) {
    const voiceMessage = document.createElement('div');
    voiceMessage.className = 'voice-message';
    voiceMessage.dataset.messageId = message.id;
    
    const playBtn = document.createElement('button');
    playBtn.className = 'play-voice-btn';
    playBtn.innerHTML = '<img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTdnax9muCZwZsJujMzKiWx8tnQXgbwNaX39A&s" alt="Play">';
    
    const isMyMessage = message.sender_id === localStorage.getItem('user_id');
    
    // Проверяем localStorage перед установкой opacity
    const listenedMessages = JSON.parse(localStorage.getItem('listenedVoiceMessages') || '{}');
    const isListened = listenedMessages[message.id] || message.listened;
    
    // Создаем индикатор прослушивания
    const listenIndicator = document.createElement('div');
    listenIndicator.className = 'listen-indicator';
    
    if (isMyMessage) {
        listenIndicator.style.opacity = isListened ? '0' : '0.7';
    } else {
        listenIndicator.style.opacity = isListened ? '0' : '0.7';
    }
    
    voiceMessage.appendChild(listenIndicator);
    
    const visualizationContainer = document.createElement('div');
    visualizationContainer.className = 'voice-visualization-container';
    
    const visualization = document.createElement('div');
    visualization.className = 'voice-visualization';
    
    // Получаем данные визуализации из сообщения
    const visualizationData = message.visualization || Array(20).fill(0.3);
    
    // Создаем полоски визуализации
// Создаем полоски визуализации
for (let i = 0; i < 20; i++) {
    const bar = document.createElement('div');
    bar.className = 'voice-bar';
    bar.style.setProperty('--i', i);
    
    // Нормализуем значение (0-1) и масштабируем до высоты (3-30px)
    const height = Math.max(3, visualizationData[i] * 30);
    bar.style.height = `${height}px`;
    
    if (isMyMessage) {
        bar.style.backgroundColor = `rgba(0, 0, 0, ${0.2 + visualizationData[i] * 0.8})`;
    } else {
        bar.style.backgroundColor = `rgba(255, 255, 255, ${0.5 + visualizationData[i] * 0.5})`;
    }
    
    visualization.appendChild(bar);
}
    
    // Добавляем ползунок прогресса
    const progressBar = document.createElement('div');
    progressBar.className = 'voice-progress';
    progressBar.style.display = 'none';
    
    visualizationContainer.appendChild(visualization);
    visualizationContainer.appendChild(progressBar);
    
    const time = document.createElement('div');
    time.className = 'voice-time';
    time.dataset.duration = message.duration;
    time.textContent = `${message.duration.toFixed(1)} сек.`;
    
    voiceMessage.appendChild(playBtn);
    voiceMessage.appendChild(visualizationContainer);
    voiceMessage.appendChild(time);
    
    return voiceMessage;
}

function initMessageContextMenu() {
    console.log('initMessageContextMenu вызвана');
    const messageContextMenu = document.getElementById('message-context-menu');
    window.messageContextMenu = messageContextMenu; // Делаем глобальной для доступа из других функций
    

    // Закрытие меню при клике вне его
    document.addEventListener('click', function(e) {
        if (messageContextMenu && !messageContextMenu.contains(e.target)) {
            messageContextMenu.classList.add('hidden');
        }
    });

// В функции initMessageContextMenu обновляем обработчик правого клика:
document.addEventListener('contextmenu', function(e) {
    const messageElement = e.target.closest('.message');
    if (messageElement) {
        e.preventDefault();
        currentContextMessage = messageElement;
        
        const isVideoMessage = messageElement.querySelector('.video-preview') !== null;
        const isMyMessage = messageElement.classList.contains('my-message');
        
        // Hide edit option for video messages
        document.getElementById('message-edit').classList.toggle('hidden', !isMyMessage || isVideoMessage);
        document.getElementById('message-edit').classList.toggle('hidden', !isMyMessage || isVoiceMessage);
        document.getElementById('message-delete').classList.toggle('hidden', !isMyMessage);
        document.getElementById('message-delete-for-me').classList.toggle('hidden', isMyMessage);
        document.getElementById('message-pin').classList.toggle('hidden', !isMyMessage || isVoiceMessage);
        document.getElementById('message-reply').classList.toggle('hidden', false);
        document.getElementById('message-forward').classList.toggle('hidden', false);
        document.getElementById('message-copy').classList.toggle('hidden', false);
        
        // Позиционируем меню
        const menuWidth = messageContextMenu.offsetWidth;
        const menuHeight = messageContextMenu.offsetHeight;
        const windowWidth = window.innerWidth;
        const windowHeight = window.innerHeight;
        const isVoiceMessage = messageElement.querySelector('.voice-message') !== null;

        
        let left = e.clientX;
        let top = e.clientY;
        
        // Проверяем, чтобы меню не выходило за границы экрана
        if (left + menuWidth > windowWidth) {
            left = windowWidth - menuWidth - 5;
        }
        
        if (top + menuHeight > windowHeight) {
            top = windowHeight - menuHeight - 5;
        }
        
        messageContextMenu.style.left = `${left}px`;
        messageContextMenu.style.top = `${top}px`;
        messageContextMenu.style.display = 'block';
        messageContextMenu.classList.remove('hidden');
        
        // Убедимся, что меню поверх других элементов
        messageContextMenu.style.zIndex = '1000';
    }
});

    // Общая функция для закрытия меню
    function closeMessageContextMenu() {
        if (messageContextMenu) {
            messageContextMenu.classList.add('hidden');
        }
    }

    // Обработчики пунктов меню
    document.getElementById('message-reply').addEventListener('click', function() {
        handleReply();
        closeMessageContextMenu();
    });
    
    document.getElementById('message-edit').addEventListener('click', function() {
        handleEdit();
        closeMessageContextMenu();
    });
    
    document.getElementById('message-pin').addEventListener('click', function() {
        handlePin();
        closeMessageContextMenu();
    });
    
    document.getElementById('message-delete').addEventListener('click', function() {
        handleDelete();
        closeMessageContextMenu();
    });
    
    document.getElementById('message-forward').addEventListener('click', function() {
        handleForward();
        closeMessageContextMenu();
    });
    
    document.getElementById('message-copy').addEventListener('click', function() {
        handleCopy();
        closeMessageContextMenu();
    });

async function handleReply() {
    if (!currentContextMessage) return;
    
    try {
        const messageText = currentContextMessage.querySelector('.message-text')?.textContent || '[Голосовое сообщение]';
        const isMyMessage = currentContextMessage.classList.contains('my-message');
        const replyContainer = document.getElementById('reply-container');
        const messageId = currentContextMessage.dataset.id;
        
        // Сохраняем состояние ответа в БД для текущего чата
        await eel.save_reply_state(
            localStorage.getItem('user_id'),
            currentChatUserId,
            messageId
        )();
        
        // Устанавливаем ID сообщения, на которое отвечаем
        replyContainer.dataset.messageId = messageId;
        
        replyContainer.innerHTML = `
            <div class="reply-header">
                <div class="reply-author">${isMyMessage ? 'Вы' : document.getElementById('chat-username').textContent}</div>
                <div class="reply-close">×</div>
            </div>
            <div class="reply-text">${messageText.length > 50 ? messageText.substring(0, 47) + '...' : messageText}</div>
        `;
        
        replyContainer.classList.remove('hidden');
        document.querySelector('.message-input-container').classList.add('expanded');
        
        // Обработчик закрытия ответа
        replyContainer.querySelector('.reply-close').addEventListener('click', async () => {
            replyContainer.classList.add('hidden');
            document.querySelector('.message-input-container').classList.remove('expanded');
            // Очищаем состояние ответа в БД для текущего чата
            await eel.clear_reply_state(localStorage.getItem('user_id'), currentChatUserId)();
        });
        
        const messageInput = document.getElementById('message-input');
        messageInput.focus();
        
    } catch (error) {
        console.error('Ошибка при обработке ответа:', error);
    }
}



    function handleEdit() {
        if (!currentContextMessage) {
            messageContextMenu.classList.add('hidden');
            return;
        }
        
        try {
            const messageId = currentContextMessage.dataset.id;
            const messageTextElement = currentContextMessage.querySelector('.message-text');
            const originalText = messageTextElement.textContent;
            
            // Создаем поле ввода для редактирования
            const input = document.createElement('input');
            input.type = 'text';
            input.value = originalText;
            input.className = 'edit-message-input';
            
            // Заменяем текст на поле ввода
            messageTextElement.replaceWith(input);
            input.focus();
            
            // Функция завершения редактирования
            const finishEditing = async (newText) => {
                if (newText && newText !== originalText) {
                    const result = await eel.edit_message(messageId, newText)();
                    if (!result.success) {
                        throw new Error(result.message || 'Не удалось изменить сообщение');
                    }
                    return newText;
                }
                return originalText;
            };
            
            // Обработчики событий
            const handleKeyDown = async (e) => {
                if (e.key === 'Enter') {
                    const newText = input.value.trim();
                    try {
                        const finalText = await finishEditing(newText);
                        messageTextElement.textContent = finalText;
                    } catch (error) {
                        alert(error.message);
                        messageTextElement.textContent = originalText;
                    }
                    cleanup();
                } else if (e.key === 'Escape') {
                    messageTextElement.textContent = originalText;
                    cleanup();
                }
            };
            
            const handleBlur = async () => {
                const newText = input.value.trim();
                try {
                    const finalText = await finishEditing(newText);
                    messageTextElement.textContent = finalText;
                } catch (error) {
                    alert(error.message);
                    messageTextElement.textContent = originalText;
                }
                cleanup();
            };
            
            const cleanup = () => {
                input.replaceWith(messageTextElement);
                input.removeEventListener('keydown', handleKeyDown);
                input.removeEventListener('blur', handleBlur);
                messageContextMenu.classList.add('hidden');
            };
            
            input.addEventListener('keydown', handleKeyDown);
            input.addEventListener('blur', handleBlur);
            
        } catch (error) {
            console.error('Ошибка при редактировании:', error);
            alert('Ошибка при редактировании сообщения');
            messageContextMenu.classList.add('hidden');
        }
    }

    function handlePin() {
        alert('Функция "Закрепить" будет реализована в будущем');
        messageContextMenu.classList.add('hidden');
    }

    eel.expose(get_current_user_id);
function get_current_user_id() {
    return localStorage.getItem('user_id');
}





    function handleForward() {
        alert('Функция "Переслать" будет реализована в будущем');
        messageContextMenu.classList.add('hidden');
    }

    function handleCopy() {
        if (!currentContextMessage) {
            messageContextMenu.classList.add('hidden');
            return;
        }
        
        try {
            const messageText = currentContextMessage.querySelector('.message-text').textContent;
            navigator.clipboard.writeText(messageText)
                .then(() => {
                    console.log('Текст скопирован в буфер обмена');
                })
                .catch(err => {
                    console.error('Ошибка копирования:', err);
                    alert('Не удалось скопировать текст');
                });
        } catch (error) {
            console.error('Ошибка при копировании:', error);
            alert('Ошибка при копировании текста');
        } finally {
            messageContextMenu.classList.add('hidden');
        }
    }
}

// Вызов инициализации после загрузки DOM
document.addEventListener('DOMContentLoaded', function() {
    initMessageContextMenu();
});

function playVoiceMessage(audioData, voiceMessageElement, duration) {
    // Останавливаем текущее воспроизведение, если есть
    if (currentPlayingAudio) {
        currentPlayingAudio.pause();
        currentPlayingAudio = null;
        
        if (currentPlayingVoiceElement) {
            stopVoiceMessage(currentPlayingVoiceElement, true);
        }
    }

    // Устанавливаем класс playing для текущего элемента
    voiceMessageElement.classList.add('playing');
    voiceMessagePlaying = true;
    currentPlayingVoiceElement = voiceMessageElement;
    
    // Используем правильный MIME-тип для аудио
    const audio = new Audio(`data:audio/ogg;base64,${audioData}`);
    currentPlayingAudio = audio;
    
    const playBtn = voiceMessageElement.querySelector('.play-voice-btn img');
    playBtn.src = 'https://png.klev.club/uploads/posts/2024-05/png-klev-club-uejr-p-ikonка-pauzi-png-30.png';
    
    const progressBar = voiceMessageElement.querySelector('.voice-progress');
    progressBar.style.display = 'block';
    progressBar.style.left = '0%';
    
    const timeElement = voiceMessageElement.querySelector('.voice-time');
    timeElement.dataset.duration = duration;
    
    // Функция обновления прогресса
    const updateProgress = () => {
        if (!voiceMessagePlaying) return;
        
        const currentPos = audio.currentTime;
        const progressPercent = (currentPos / duration) * 100;
        
        progressBar.style.left = `${progressPercent}%`;
        
        const bars = voiceMessageElement.querySelectorAll('.voice-bar');
        bars.forEach((bar, i) => {
            const barPos = (i / bars.length) * 100;
            if (barPos < progressPercent) {
                bar.style.opacity = '0.7';
            } else {
                bar.style.opacity = '0.3';
            }
        });
        
        timeElement.textContent = `${currentPos.toFixed(1)} / ${duration.toFixed(1)} сек.`;
        
        if (currentPos >= duration) {
            handleVoiceMessagePlayed(voiceMessageElement);
        } else if (voiceMessagePlaying) {
            requestAnimationFrame(updateProgress);
        }
    };
        
    // Обработчики событий аудио
    audio.addEventListener('ended', () => {
        handleVoiceMessagePlayed(voiceMessageElement);
    });
    
    audio.addEventListener('pause', () => {
        voiceMessagePlaying = false;
        const currentTime = audio.currentTime;
        const progressPercent = (currentTime / duration) * 100;
        progressBar.style.left = `${progressPercent}%`;
        timeElement.textContent = `${currentTime.toFixed(1)} / ${duration.toFixed(1)} сек.`;
        
        playBtn.src = 'https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTdnax9muCZwZsJujMzKiWx8tnQXgbwNaX39A&s';
    });
    
    audio.addEventListener('error', (e) => {
        console.error('Audio error:', e);
        stopVoiceMessage(voiceMessageElement, true);
        alert('Ошибка воспроизведения голосового сообщения');
    });
    
    // Запускаем воспроизведение
    audio.play().then(() => {
        updateProgress();
    }).catch(error => {
        console.error('Ошибка воспроизведения:', error);
        stopVoiceMessage(voiceMessageElement, true);
    });
}

function handleVoiceMessagePlayed(voiceMessageElement) {
    const messageElement = voiceMessageElement.closest('.message');
    const messageId = messageElement?.dataset.id;
    const timeElement = voiceMessageElement.querySelector('.voice-time');
    const duration = parseFloat(timeElement.dataset.duration) || 0;
    
    // Скрываем ползунок
    const progressBar = voiceMessageElement.querySelector('.voice-progress');
    progressBar.style.display = 'none';
    
    timeElement.textContent = `${duration.toFixed(1)} сек.`;
    stopVoiceMessage(voiceMessageElement, true);
    
    const isMyMessage = messageElement.classList.contains('my-message');
    const indicator = voiceMessageElement.querySelector('.listen-indicator');
    
    // Для своих сообщений НЕ изменяем состояние индикатора
    if (!isMyMessage && indicator) {
        indicator.style.opacity = '0';
        
        // Сохраняем в localStorage, что сообщение прослушано
        if (messageId) {
            const listenedMessages = JSON.parse(localStorage.getItem('listenedVoiceMessages') || '{}');
            listenedMessages[messageId] = true;
            localStorage.setItem('listenedVoiceMessages', JSON.stringify(listenedMessages));
        }
    }
    
    // Обновляем состояние в кеше только для чужих сообщений
    if (!isMyMessage && currentChatUserId && activeChats[currentChatUserId]?.messagesData) {
        const messageIndex = activeChats[currentChatUserId].messagesData.findIndex(m => m.id === messageId);
        if (messageIndex !== -1) {
            activeChats[currentChatUserId].messagesData[messageIndex].listened = true;
        }
    }
    
    // Отправляем на сервер информацию о прослушивании (только для чужих сообщений)
    if (messageId && !isMyMessage) {
        const userId = localStorage.getItem('user_id');
        eel.mark_voice_message_as_listened(messageId, userId)();
    }
}

async function analyzeAudioAndCreateVisualization(audioBlob, duration) {
    try {
        // Создаем аудиоконтекст
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const arrayBuffer = await audioBlob.arrayBuffer();
        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
        
        // Получаем данные канала (берем первый канал)
        const channelData = audioBuffer.getChannelData(0);
        const sampleRate = audioBuffer.sampleRate;
        
        // Количество полосок
        const barsCount = 20;
        // Длительность одного сегмента в секундах
        const segmentDuration = duration / barsCount;
        // Количество семплов в одном сегменте
        const samplesPerSegment = Math.floor(segmentDuration * sampleRate);
        
        const visualizationData = [];
        
        // Анализируем каждый сегмент
        for (let i = 0; i < barsCount; i++) {
            const startSample = i * samplesPerSegment;
            const endSample = Math.min((i + 1) * samplesPerSegment, channelData.length);
            
            let maxAmplitude = 0;
            
            // Находим максимальную амплитуду в сегменте
            for (let j = startSample; j < endSample; j++) {
                const amplitude = Math.abs(channelData[j]);
                if (amplitude > maxAmplitude) {
                    maxAmplitude = amplitude;
                }
            }
            
            // Нормализуем значение от 0 до 1
            visualizationData.push(maxAmplitude);
        }
        
        return visualizationData;
    } catch (error) {
        console.error('Ошибка анализа аудио:', error);
        // Возвращаем массив нулей в случае ошибки
        return Array(20).fill(0);
    }
}



// Обработчики для пунктов меню
document.getElementById('message-reply').addEventListener('click', () => {
    if (currentContextMessage) {
        const messageText = currentContextMessage.querySelector('.message-text').textContent;
        const messageInput = document.getElementById('message-input');
        messageInput.value = `Ответ на: "${messageText}" `;
        messageInput.focus();
    }
    messageContextMenu.classList.add('hidden');
});

document.getElementById('message-edit').addEventListener('click', async () => {
    if (currentContextMessage) {
        const messageId = currentContextMessage.dataset.id;
        const messageText = currentContextMessage.querySelector('.message-text');
        const originalText = messageText.textContent;
        
        // Создаем поле ввода для редактирования
        const input = document.createElement('input');
        input.type = 'text';
        input.value = originalText;
        input.className = 'edit-message-input';
        
        // Заменяем текст на поле ввода
        messageText.replaceWith(input);
        input.focus();
        
        // Обработчик завершения редактирования
        const handleEdit = async (e) => {
            if (e.key === 'Enter' || e.type === 'blur') {
                const newText = input.value.trim();
                if (newText && newText !== originalText) {
                    try {
                        const result = await eel.edit_message(messageId, newText)();
                        if (result.success) {
                            messageText.textContent = newText;
                        } else {
                            alert(result.message);
                            messageText.textContent = originalText;
                        }
                    } catch (error) {
                        console.error('Ошибка редактирования:', error);
                        messageText.textContent = originalText;
                    }
                } else {
                    messageText.textContent = originalText;
                }
                
                input.replaceWith(messageText);
                input.removeEventListener('keydown', handleEdit);
                input.removeEventListener('blur', handleEdit);
            } else if (e.key === 'Escape') {
                messageText.textContent = originalText;
                input.replaceWith(messageText);
                input.removeEventListener('keydown', handleEdit);
                input.removeEventListener('blur', handleEdit);
            }
        };
        
        input.addEventListener('keydown', handleEdit);
        input.addEventListener('blur', handleEdit);
    }
    messageContextMenu.classList.add('hidden');
});

document.getElementById('message-pin').addEventListener('click', () => {
    if (currentContextMessage) {
        alert('Функция "Закрепить" будет реализована в будущем');
    }
    messageContextMenu.classList.add('hidden');
});

document.getElementById('message-delete').addEventListener('click', async () => {
    if (currentContextMessage) {
        if (confirm('Вы уверены, что хотите удалить это сообщение?')) {
            const messageId = currentContextMessage.dataset.id;
            try {
                const result = await eel.delete_message(messageId)();
                if (result.success) {
                    currentContextMessage.remove();
                } else {
                    alert(result.message);
                }
            } catch (error) {
                console.error('Ошибка удаления:', error);
                alert('Ошибка при удалении сообщения');
            }
        }
    }
    messageContextMenu.classList.add('hidden');
});

document.getElementById('message-forward').addEventListener('click', () => {
    if (currentContextMessage) {
        alert('Функция "Переслать" будет реализована в будущем');
    }
    messageContextMenu.classList.add('hidden');
});

document.getElementById('message-copy').addEventListener('click', () => {
    if (currentContextMessage) {
        const messageText = currentContextMessage.querySelector('.message-text').textContent;
        navigator.clipboard.writeText(messageText)
            .then(() => {
                // Можно добавить уведомление о успешном копировании
                console.log('Текст скопирован');
            })
            .catch(err => {
                console.error('Ошибка копирования:', err);
            });
    }
    messageContextMenu.classList.add('hidden');
});

// Стиль для поля редактирования
const style = document.createElement('style');
style.textContent = `
    .edit-message-input {
        width: 100%;
        padding: 5px;
        border: 1px solid #4CAF50;
        border-radius: 4px;
        font-size: 14px;
    }
`;
document.head.appendChild(style);  

function stopVoiceMessage(voiceMessageElement = null, reset = false) {
    if (!voiceMessageElement) {
        voiceMessageElement = currentPlayingVoiceElement;
    }
    
    if (currentPlayingAudio) {
        currentPlayingAudio.pause();
        if (reset) {
            currentPlayingAudio.currentTime = 0;
            currentPlayingAudio = null;
        }
        voiceMessagePlaying = false;
    }
    
    if (voiceMessageElement) {
        voiceMessageElement.classList.remove('playing');
        const playBtn = voiceMessageElement.querySelector('.play-voice-btn img');
        playBtn.src = 'https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTdnax9muCZwZsJujMzKiWx8tnQXgbwNaX39A&s';
        
        const timeElement = voiceMessageElement.querySelector('.voice-time');
        const duration = parseFloat(timeElement.dataset.duration) || 0;
        const progressBar = voiceMessageElement.querySelector('.voice-progress');
        
        if (reset) {
            progressBar.style.display = 'none';
            timeElement.textContent = `${duration.toFixed(1)} сек.`;
            currentPlayingVoiceElement = null;
        } else {
            // При паузе сохраняем текущее состояние прогресса
            const currentTime = currentPlayingAudio?.currentTime || 0;
            const progressPercent = (currentTime / duration) * 100;
            progressBar.style.left = `${progressPercent}%`;
            timeElement.textContent = `${currentTime.toFixed(1)} / ${duration.toFixed(1)} сек.`;
        }
    }
}

// Обработчики для меню фото
const photoBtn = document.getElementById('photo-message-btn');
const photoOptionsMenu = document.getElementById('photo-options-menu');
const fileInput = document.getElementById('file-input');
const mediaSendModal = document.getElementById('media-send-modal');
const mediaSendOverlay = document.getElementById('media-send-overlay');
const mediaSendTitle = document.getElementById('media-send-title');
const imagePreview = document.getElementById('image-preview');
const videoPreview = document.getElementById('video-preview');
const mediaCaptionInput = document.getElementById('media-caption-input');
const mediaAddButton = document.getElementById('media-add-button');
const mediaCancelButton = document.getElementById('media-cancel-button');
const mediaSendButton = document.getElementById('media-send-button');
let selectedFiles = [];
let currentMediaType = 'photo';
let photoMenuTimeout;

// Показываем меню при наведении на кнопку
photoBtn.addEventListener('mouseenter', () => {
    clearTimeout(photoMenuTimeout);
    positionPhotoMenu();
    photoOptionsMenu.classList.remove('hidden');
    photoOptionsMenu.classList.add('show');
});

// Скрываем меню при уходе с кнопки (с задержкой)
photoBtn.addEventListener('mouseleave', () => {
    photoMenuTimeout = setTimeout(() => {
        photoOptionsMenu.classList.remove('show');
    }, 200);
});

// Отменяем скрытие при наведении на меню
photoOptionsMenu.addEventListener('mouseenter', () => {
    clearTimeout(photoMenuTimeout);
});

// Скрываем меню при уходе с него
photoOptionsMenu.addEventListener('mouseleave', () => {
    photoOptionsMenu.classList.remove('show');
});

// Обработчики для кнопок меню
document.querySelectorAll('.photo-option').forEach(option => {
    option.addEventListener('click', function() {
        const type = this.dataset.type;
        if (type === 'photo-video') {
            openFileSelector();
        } else {
            alert(`Выбрана опция: ${this.querySelector('span').textContent}`);
        }
        photoOptionsMenu.classList.remove('show');
    });
});

function openFileSelector() {
    const fileInput = document.getElementById('file-input');
    if (fileInput) {
        fileInput.value = ''; // Сбрасываем предыдущий выбор
        fileInput.click();
    } else {
        console.error('File input element not found');
    }
}

function handleFileSelect(e) {
    const files = e.target.files;
    if (files.length === 0) return;
    
    const file = files[0];
    currentMediaType = file.type.startsWith('video/') ? 'video' : 'photo';
    
    // Показываем соответствующее превью
    imagePreview.classList.add('hidden');
    videoPreview.classList.add('hidden');
    
    if (currentMediaType === 'photo') {
        mediaSendTitle.textContent = 'Отправить фото';
        const reader = new FileReader();
        reader.onload = (event) => {
            imagePreview.src = event.target.result;
            imagePreview.classList.remove('hidden');
        };
        reader.readAsDataURL(file);
    } else {
        mediaSendTitle.textContent = 'Отправить видео';
        videoPreview.src = URL.createObjectURL(file);
        videoPreview.classList.remove('hidden');
    }
    
    // Показываем модальное окно
    mediaSendOverlay.classList.remove('hidden');
    mediaSendModal.classList.remove('hidden');
    mediaCaptionInput.value = '';
    mediaCaptionInput.focus();
}
// Обработчик отправки медиа
mediaSendButton.addEventListener('click', async function() {
    const file = fileInput.files[0];
    if (!file) {
        alert('Пожалуйста, выберите файл');
        return;
    }

    // Проверка размера файла (например, не более 10MB)
    if (file.size > 10 * 1024 * 1024) {
        alert('Файл слишком большой (максимум 10MB)');
        return;
    }

    const caption = mediaCaptionInput.value.trim();
    
    try {
        const reader = new FileReader();
        reader.onload = async (event) => {
            const fileData = event.target.result.split(',')[1];
            const fileType = file.type.startsWith('video/') ? 'video' : 'image';
            
            // Показываем индикатор загрузки
            const loadingIndicator = document.createElement('div');
            loadingIndicator.className = 'loading-indicator';
            loadingIndicator.textContent = 'Отправка...';
            mediaSendModal.appendChild(loadingIndicator);
            mediaSendButton.disabled = true;
            
            try {
                const result = await eel.send_media_message(
                    localStorage.getItem('user_id'),
                    currentChatUserId,
                    fileData,
                    fileType,
                    file.name,
                    caption
                )();
                
                if (result.success) {
                    const message = {
                        id: result.message_id,
                        sender_id: localStorage.getItem('user_id'),
                        receiver_id: currentChatUserId,
                        text: caption || (fileType === 'video' ? '[Видео]' : '[Фото]'),
                        timestamp: result.timestamp,
                        read: result.read,
                        isMedia: true,
                        mediaType: fileType,
                        mediaData: fileData,
                        filename: file.name
                    };
                    
                    addMessageToChat(message, true, true);
                    lastMessageId = message.id;
                    
                    if (activeChats[currentChatUserId]) {
                        const messagesContainer = document.getElementById('chat-messages');
                        activeChats[currentChatUserId].messages = messagesContainer.innerHTML;
                        activeChats[currentChatUserId].lastMessageId = lastMessageId;
                    }
                    
                    updateLastMessageOnUserCard(
                        currentChatUserId, 
                        fileType === 'video' ? 'Видео' : 'Фото', 
                        true
                    );
                    
                    closeMediaModal();
                } else {
                    alert('Ошибка при отправке: ' + result.message);
                }
            } catch (error) {
                console.error('Ошибка отправки:', error);
                alert('Ошибка при отправке файла');
            } finally {
                loadingIndicator.remove();
                mediaSendButton.disabled = false;
            }
        };
        reader.readAsDataURL(file);
    } catch (error) {
        console.error('Ошибка чтения файла:', error);
        alert('Ошибка при обработке файла');
    }
});

mediaCancelButton.addEventListener('click', closeMediaModal);
mediaSendOverlay.addEventListener('click', closeMediaModal);

function closeMediaModal() {
    mediaSendOverlay.classList.add('hidden');
    mediaSendModal.classList.add('hidden');
    selectedFiles = [];
}

function sendMedia() {
    if (selectedFiles.length === 0) {
        alert('Пожалуйста, выберите файл');
        return;
    }
    
    const caption = mediaCaptionInput.value.trim();
    const file = selectedFiles[0];
    
    console.log('Отправка файла:', file, 'с текстом:', caption);
    
    closeMediaModal();
}

// Обработчик нажатия ESC для закрытия модального окна
document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape' && !mediaSendOverlay.classList.contains('hidden')) {
        closeMediaModal();
    }
});




// Позиционируем меню относительно кнопки
function positionPhotoMenu() {
    const rect = photoBtn.getBoundingClientRect();
    photoOptionsMenu.style.left = `${rect.left}px`;
    photoOptionsMenu.style.bottom = `${window.innerHeight - rect.top + 10}px`;
}

// Обновляем позицию при изменении размера окна
window.addEventListener('resize', positionPhotoMenu);





    </script>
<!-- Модальное окно удаления сообщения -->
<div class="modal-overlay hidden" id="delete-message-overlay"></div>
<div class="delete-message-modal hidden" id="delete-message-modal">
    <button class="modal-close-btn" id="delete-message-close-btn">×</button>
    <div class="delete-message-text">Удалить сообщение</div>
    <div class="delete-message-buttons">
        <button class="delete-message-button delete-for-all" id="delete-for-all-btn">Удалить у всех</button>
        <button class="delete-message-button delete-for-me" id="delete-for-me-btn">Только у меня</button>
    </div>
    <button class="delete-message-cancel" id="delete-message-cancel-btn">Отмена</button>
</div>






</body>
</html>