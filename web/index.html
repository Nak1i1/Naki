<!doctype html>
<html lang="ru">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Мессенджер</title>
		<link rel="stylesheet" href="style.css" />
		<link rel="icon" type="image/png" href="logo.png" />
		<link rel="apple-touch-icon" href="logo.png" />
		<meta name="mobile-web-app-capable" content="yes" />
		<meta
			name="apple-mobile-web-app-status-bar-style"
			content="black-translucent"
		/>
		<meta name="theme-color" content="#4CAF50" />
	</head>
	<body>
		<div class="media-send-overlay hidden" id="media-send-overlay"></div>
		<div class="media-send-modal hidden" id="media-send-modal">
			<div class="media-send-title" id="media-send-title">Отправить медиа</div>
			<div class="media-preview-grid" id="media-preview-grid"></div>
			<input
				type="text"
				class="media-caption-input"
				id="media-caption-input"
				placeholder="Введите текст"
			/>
			<div class="media-send-buttons">
				<button class="media-send-button add" id="media-add-button">
					Добавить
				</button>
				<button class="media-send-button cancel" id="media-cancel-button">
					Отмена
				</button>
				<button class="media-send-button send" id="media-send-button">
					Отправить все
				</button>
			</div>
		</div>
		<div class="image-modal-overlay hidden" id="image-modal-overlay">
			<div class="image-modal-content">
				<button class="image-modal-close" id="image-modal-close">×</button>
				<img
					src=""
					alt="Full screen image"
					class="image-modal-img"
					id="image-modal-img"
				/>
			</div>
		</div>
		<input
			type="file"
			id="file-input"
			class="file-input"
			accept="image/*,video/*"
			onchange="handleFileSelect(event)"
		/>

		<div class="top-container">
			<div class="top-row">
				<div class="menu-icon">☰</div>
				<div class="avatar-small" id="top-avatar"></div>
				<div class="search-container">
					<input type="text" class="search-input" placeholder="поиск" />
					<span class="clear-btn">×</span>
				</div>
			</div>
			<div class="user-container" id="user-container"></div>
		</div>

		<div class="right-container">
			<div class="default-content" id="default-content">
				<img
					src="https://cdn-icons-png.flaticon.com/512/5757/5757765.png"
					alt="Выберите чат"
					class="default-image"
				/>
			</div>
			<div class="chat-container hidden" id="chat-container">
				<div class="chat-header">
					<div class="chat-username" id="chat-username"></div>
					<div class="chat-header-info">
						<div class="chat-status" id="chat-status"></div>
					</div>
				</div>
				<div class="chat-scroll-container">
					<div class="chat-messages-wrapper" id="chat-messages-wrapper">
						<div class="chat-messages" id="chat-messages"></div>
					</div>
					<div class="custom-scrollbar" id="custom-scrollbar">
						<div
							class="custom-scrollbar-thumb"
							id="custom-scrollbar-thumb"
						></div>
					</div>
				</div>
				<div class="message-input-container">
					<div class="reply-container hidden" id="reply-container"></div>
					<div class="input-row">
						<button class="photo-message-btn" id="photo-message-btn">
							<img
								src="https://cdn-icons-png.flaticon.com/512/266/266074.png"
								alt="Фото"
							/>
						</button>
						<div class="message-input-wrapper">
							<input
								type="text"
								class="message-input"
								placeholder="Напишите сообщение..."
								id="message-input"
							/>
							<div class="recording-container hidden" id="recording-container">
								Запись: <span id="recording-time">0</span> сек.
							</div>
						</div>
						<button class="voice-message-btn" id="voice-message-btn">
							<img
								src="https://images.icon-icons.com/2066/PNG/512/mic_icon_125214.png"
								alt="Запись"
							/>
						</button>
					</div>
				</div>
			</div>
		</div>

		<div class="photo-options-menu hidden" id="photo-options-menu">
			<button class="photo-option" data-type="photo-video">
				<img
					src="https://cdn-icons-png.flaticon.com/512/266/266074.png"
					alt="Фото/Видео"
				/>
				<span>Фото и видео</span>
			</button>
			<button class="photo-option" data-type="documents">
				<img
					src="https://cdn-icons-png.flaticon.com/512/2991/2991112.png"
					alt="Документы"
				/>
				<span>Документы</span>
			</button>
			<button class="photo-option" data-type="poll">
				<img
					src="https://cdn-icons-png.flaticon.com/512/3034/3034626.png"
					alt="Опрос"
				/>
				<span>Создать опрос</span>
			</button>
			<button class="photo-option" data-type="location">
				<img
					src="https://cdn-icons-png.flaticon.com/512/535/535137.png"
					alt="Геолокация"
				/>
				<span>Геолокация</span>
			</button>
		</div>

		<div class="video-message-container hidden" id="video-loading-overlay">
			<div class="video-loading-content">
				<div class="video-loading-spinner"></div>
				<div class="video-loading-text">Загрузка видео...</div>
				<div class="video-loading-progress">0 MB / 0 MB</div>
				<button class="video-loading-cancel">Отмена</button>
			</div>
		</div>

		<div class="context-menu" id="context-menu">
			<div class="context-menu-item add-friend hidden" id="context-menu-add">
				Добавить в друзья
			</div>
			<div
				class="context-menu-item remove-friend hidden"
				id="context-menu-remove"
			>
				Удалить из друзей
			</div>
		</div>

		<div class="modal-overlay hidden" id="logout-overlay"></div>
		<div class="logout-modal hidden" id="logout-modal">
			<button class="modal-close-btn" id="logout-close-btn">×</button>
			<div class="logout-text">Выйти из аккаунта</div>
			<div class="logout-buttons">
				<button class="logout-button logout-cancel" id="logout-cancel-btn">
					Отмена
				</button>
				<button class="logout-button logout-confirm" id="logout-confirm-btn">
					Выйти
				</button>
			</div>
		</div>

		<div class="message-context-menu hidden" id="message-context-menu">
			<div class="message-context-item" id="message-reply">Ответить</div>
			<div class="message-context-item" id="message-edit">Изменить</div>
			<div class="message-context-item" id="message-pin">Закрепить</div>
			<div class="message-context-item" id="message-delete">Удалить</div>
			<div
				class="message-context-item"
				id="message-delete-for-me"
				style="display: none"
			>
				Удалить у меня
			</div>
			<div class="message-context-item" id="message-forward">Переслать</div>
			<div class="message-context-item" id="message-copy">Копировать</div>
		</div>

		<div class="modal-overlay hidden" id="delete-message-overlay"></div>
		<div class="delete-message-modal hidden" id="delete-message-modal">
			<button class="modal-close-btn" id="delete-message-close-btn">×</button>
			<div class="delete-message-text">Удалить сообщение</div>
			<div class="delete-message-buttons">
				<button
					class="delete-message-button delete-for-all"
					id="delete-for-all-btn"
				>
					Удалить у всех
				</button>
				<button
					class="delete-message-button delete-for-me"
					id="delete-for-me-btn"
				>
					Только у меня
				</button>
			</div>
			<button class="delete-message-cancel" id="delete-message-cancel-btn">
				Отмена
			</button>
		</div>

		<script src="eel.js"></script>
		<script>
			;(function () {
				let currentUser = null
				let contextMenu = null
				let contextMenuTarget = null
				let currentChatUserId = null
				let lastMessageId = null
				let activeChats = {}
				let readStatusInterval = null
				let statusUpdateInterval = null
				let onlineStatusInterval = null
				let currentPlayingAudio = null
				let voiceMessagePlaying = false
				let currentPlayingVoiceElement = null
				let ecdhInitialized = false
				let currentContextMessage = null
				let chatInputs = {}
				let scrollPositions = {}
				let isDraggingScroll = false
				let scrollDragStartY = 0
				let scrollThumbStartY = 0
				let messageElementsCache = new Map()
				let dateHeaders = new Map()
				let currentStickyDate = null
				let dateHeadersObserver = null
				let encryptionEnabled = false
				let currentPeerKey = null
				let messageCheckInterval = null
				let readStatusCheckInterval = null

				window.messageElements = new Map()

				class ECDHEncryption {
					static async generateKeyPair() {
						return await window.crypto.subtle.generateKey(
							{ name: 'ECDH', namedCurve: 'P-256' },
							true,
							['deriveKey'],
						)
					}
					static async exportPublicKey(key) {
						const exported = await window.crypto.subtle.exportKey('spki', key)
						return btoa(String.fromCharCode(...new Uint8Array(exported)))
					}
					static async exportPrivateKey(key) {
						const exported = await window.crypto.subtle.exportKey('pkcs8', key)
						return btoa(String.fromCharCode(...new Uint8Array(exported)))
					}
					static async importPublicKey(base64Key) {
						const binary = atob(base64Key)
						const buffer = new Uint8Array(binary.length)
						for (let i = 0; i < binary.length; i++)
							buffer[i] = binary.charCodeAt(i)
						return await window.crypto.subtle.importKey(
							'spki',
							buffer,
							{ name: 'ECDH', namedCurve: 'P-256' },
							true,
							[],
						)
					}
					static async importPrivateKeyFromPem(pem) {
						const pemContents = pem
							.replace('-----BEGIN PRIVATE KEY-----', '')
							.replace('-----END PRIVATE KEY-----', '')
							.replace(/\s/g, '')
						const binaryDer = Uint8Array.from(atob(pemContents), c =>
							c.charCodeAt(0),
						)
						return await window.crypto.subtle.importKey(
							'pkcs8',
							binaryDer,
							{ name: 'ECDH', namedCurve: 'P-256' },
							false,
							['deriveKey'],
						)
					}
					static async importPublicKeyFromPem(pem) {
						const pemContents = pem
							.replace('-----BEGIN PUBLIC KEY-----', '')
							.replace('-----END PUBLIC KEY-----', '')
							.replace(/\s/g, '')
						const binaryDer = Uint8Array.from(atob(pemContents), c =>
							c.charCodeAt(0),
						)
						return await window.crypto.subtle.importKey(
							'spki',
							binaryDer,
							{ name: 'ECDH', namedCurve: 'P-256' },
							true,
							[],
						)
					}
					static async deriveSharedSecret(privateKey, peerPublicKey) {
						return await window.crypto.subtle.deriveKey(
							{ name: 'ECDH', public: peerPublicKey },
							privateKey,
							{ name: 'AES-GCM', length: 256 },
							false,
							['encrypt', 'decrypt'],
						)
					}
					static async encryptMessage(sharedKey, plaintext) {
						const encoder = new TextEncoder()
						const encoded = encoder.encode(plaintext)
						const iv = window.crypto.getRandomValues(new Uint8Array(12))
						const ciphertext = await window.crypto.subtle.encrypt(
							{ name: 'AES-GCM', iv },
							sharedKey,
							encoded,
						)
						return {
							ciphertext: Array.from(new Uint8Array(ciphertext)),
							nonce: Array.from(iv),
						}
					}
					static async decryptMessage(sharedKey, ciphertextArray, nonceArray) {
						const ciphertext = new Uint8Array(ciphertextArray)
						const nonce = new Uint8Array(nonceArray)
						const decrypted = await window.crypto.subtle.decrypt(
							{ name: 'AES-GCM', iv: nonce },
							sharedKey,
							ciphertext,
						)
						return new TextDecoder().decode(decrypted)
					}
					static arrayToHex(array) {
						return Array.from(array)
							.map(b => b.toString(16).padStart(2, '0'))
							.join('')
					}
					static hexToArray(hex) {
						const bytes = []
						for (let i = 0; i < hex.length; i += 2)
							bytes.push(parseInt(hex.substr(i, 2), 16))
						return bytes
					}
				}

				async function setupEcdhEncryption(peerUserId) {
					try {
						const userId = localStorage.getItem('user_id')
						const password = sessionStorage.getItem('user_password')
						if (!userId || !password)
							throw new Error('Необходима аутентификация')
						const peerKeyResult = await eel.get_public_key(peerUserId)()
						if (!peerKeyResult.success)
							throw new Error('Не удалось получить публичный ключ собеседника')
						const sharedSecretResult = await eel.compute_shared_secret(
							userId,
							peerKeyResult.public_key,
							password,
						)()
						if (!sharedSecretResult.success)
							throw new Error(
								'Не удалось вычислить общий секрет: ' +
									sharedSecretResult.message,
							)
						console.log('ECDH шифрование настроено для чата с', peerUserId)
						return true
					} catch (error) {
						console.error('Ошибка настройки ECDH шифрования:', error)
						return false
					}
				}

				async function decryptEcdhMessage(
					ciphertextHex,
					nonceHex,
					myUserId,
					peerUserId,
					password,
					isMyMessage,
				) {
					try {
						const privateKeyResult = await eel.get_decrypted_private_key(
							myUserId,
							password,
						)()
						if (!privateKeyResult.success)
							throw new Error('Не удалось получить приватный ключ')
						const peerKeyResult = await eel.get_public_key(peerUserId)()
						if (!peerKeyResult.success)
							throw new Error('Не удалось получить публичный ключ собеседника')
						const privateKey = await ECDHEncryption.importPrivateKeyFromPem(
							privateKeyResult.private_key,
						)
						const peerPublicKey = await ECDHEncryption.importPublicKeyFromPem(
							peerKeyResult.public_key,
						)
						const sharedKey = await ECDHEncryption.deriveSharedSecret(
							privateKey,
							peerPublicKey,
						)
						const ciphertextArray = ECDHEncryption.hexToArray(ciphertextHex)
						const nonceArray = ECDHEncryption.hexToArray(nonceHex)
						return await ECDHEncryption.decryptMessage(
							sharedKey,
							ciphertextArray,
							nonceArray,
						)
					} catch (error) {
						console.error('Ошибка дешифрования ECDH сообщения:', error)
						return '[Не удалось расшифровать]'
					}
				}

				async function sendEcdhMessage(text) {
					try {
						if (!currentChatUserId || !text.trim()) return false
						const userId = localStorage.getItem('user_id')
						const password = sessionStorage.getItem('user_password')
						if (!password)
							throw new Error('Необходима аутентификация для шифрования')

						const peerKeyResult = await eel.get_public_key(currentChatUserId)()
						if (!peerKeyResult.success)
							throw new Error('Не удалось получить публичный ключ собеседника')
						const privateKeyResult = await eel.get_decrypted_private_key(
							userId,
							password,
						)()
						if (!privateKeyResult.success)
							throw new Error('Не удалось получить приватный ключ')

						const privateKey = await ECDHEncryption.importPrivateKeyFromPem(
							privateKeyResult.private_key,
						)
						const peerPublicKey = await ECDHEncryption.importPublicKeyFromPem(
							peerKeyResult.public_key,
						)
						const sharedKey = await ECDHEncryption.deriveSharedSecret(
							privateKey,
							peerPublicKey,
						)
						const encrypted = await ECDHEncryption.encryptMessage(
							sharedKey,
							text,
						)
						const ciphertextHex = ECDHEncryption.arrayToHex(
							encrypted.ciphertext,
						)
						const nonceHex = ECDHEncryption.arrayToHex(encrypted.nonce)

						const replyContainer = document.getElementById('reply-container')
						const isReply = !replyContainer.classList.contains('hidden')
						let replyToMessageId = null
						let repliedMessageData = null

						if (isReply) {
							replyToMessageId = replyContainer.dataset.messageId
							try {
								const repliedMessage =
									await getFullEcdhMessageData(replyToMessageId)
								if (repliedMessage) {
									let displayText = '[Сообщение]'
									if (repliedMessage.is_encrypted) {
										if (
											repliedMessage.encryption_type === 'ECDH-AES-GCM' &&
											repliedMessage.ciphertext &&
											repliedMessage.nonce
										) {
											displayText = await decryptEcdhMessage(
												repliedMessage.ciphertext,
												repliedMessage.nonce,
												userId,
												repliedMessage.sender_id === userId
													? repliedMessage.receiver_id
													: repliedMessage.sender_id,
												password,
												repliedMessage.sender_id === userId,
											)
										} else if (repliedMessage.text) {
											displayText = await MessageEncryption.decryptMessage(
												repliedMessage.text,
												password,
											)
										}
									} else {
										displayText = repliedMessage.text || '[Сообщение]'
									}
									repliedMessageData = {
										id: repliedMessage.id,
										sender_id: repliedMessage.sender_id,
										text: displayText,
										is_encrypted: repliedMessage.is_encrypted,
										encryption_type: repliedMessage.encryption_type,
										timestamp: repliedMessage.timestamp,
									}
								}
							} catch (error) {
								console.error('Ошибка получения данных ответа:', error)
							}
						}

						const result = await eel.send_ecdh_encrypted_message(
							userId,
							currentChatUserId,
							ciphertextHex,
							nonceHex,
							replyToMessageId,
						)()

						if (result.success) {
							const messageData = {
								id: result.message_id,
								sender_id: userId,
								receiver_id: currentChatUserId,
								text,
								ciphertext: ciphertextHex,
								nonce: nonceHex,
								timestamp: result.timestamp,
								read: result.read,
								is_encrypted: true,
								encryption_type: 'ECDH-AES-GCM',
							}
							if (isReply && replyToMessageId) {
								messageData.reply_to_message_id = replyToMessageId
								if (repliedMessageData)
									messageData.replied_message = repliedMessageData
							}
							await addMessageToChat(messageData, true, true)
							updateLastMessageOnUserCard(currentChatUserId, text, true)
							document.getElementById('message-input').value = ''
							if (isReply) await clearReplyState()
							console.log('Сообщение зашифровано и отправлено с ECDH')
							lastMessageId = result.message_id
							setTimeout(() => checkMessagesReadStatus(), 500)
							return true
						} else throw new Error(result.message)
					} catch (error) {
						console.error('Ошибка отправки ECDH сообщения:', error)
						alert('Ошибка отправки сообщения: ' + error.message)
						return false
					}
				}

				async function loadEcdhChatHistory(userId) {
					try {
						const currentUserId = localStorage.getItem('user_id')
						console.log(
							'Загружаем историю ECDH чата между',
							currentUserId,
							'и',
							userId,
						)
						const messagesContainer = document.getElementById('chat-messages')
						messagesContainer.innerHTML = ''
						dateHeaders.clear()
						window.messageElements.clear()

						const response = await eel.get_ecdh_chat_history(
							currentUserId,
							userId,
						)()
						if (!response.success) {
							console.warn(
								'Не удалось загрузить историю ECDH чата:',
								response.message,
							)
							const fallbackResponse = await eel.get_encrypted_chat_history(
								currentUserId,
								userId,
							)()
							if (fallbackResponse.success) {
								await processEncryptedMessages(
									fallbackResponse.messages,
									currentUserId,
									userId,
								)
							}
							return
						}
						console.log(
							'Получено ECDH сообщений:',
							response.messages ? response.messages.length : 0,
						)
						if (response.messages && response.messages.length > 0) {
							await processEcdhMessages(
								response.messages,
								currentUserId,
								userId,
							)
						} else {
							messagesContainer.innerHTML =
								'<div class="no-messages">Нет сообщений</div>'
						}
					} catch (error) {
						console.error('Ошибка загрузки истории ECDH чата:', error)
					}
				}

				async function processEcdhMessages(
					messages,
					currentUserId,
					peerUserId,
				) {
					const messagesContainer = document.getElementById('chat-messages')
					if (!messages || messages.length === 0) {
						messagesContainer.innerHTML =
							'<div class="no-messages">Нет сообщений</div>'
						return
					}

					const userPassword = sessionStorage.getItem('user_password')
					if (!userPassword) {
						showNoPasswordError()
						return
					}

					const processedMessageIds = new Set()
					for (const msg of messages) {
						if (msg.id && processedMessageIds.has(msg.id)) continue
						processedMessageIds.add(msg.id)

						const isMyMessage = msg.sender_id === currentUserId
						try {
							let displayText = '[Зашифрованное сообщение]'
							if (msg.is_encrypted && msg.ciphertext && msg.nonce) {
								displayText = await decryptEcdhMessage(
									msg.ciphertext,
									msg.nonce,
									currentUserId,
									isMyMessage ? peerUserId : msg.sender_id,
									userPassword,
									isMyMessage,
								)
							}
							const messageObj = {
								...msg,
								text: displayText,
								is_encrypted: true,
							}
							if (msg.replied_message && !msg.replied_message.text) {
								try {
									const repliedMessage = await getFullEcdhMessageData(
										msg.replied_message.id,
									)
									if (repliedMessage) {
										let repliedText = '[Сообщение]'
										if (repliedMessage.is_encrypted) {
											if (
												repliedMessage.encryption_type === 'ECDH-AES-GCM' &&
												repliedMessage.ciphertext &&
												repliedMessage.nonce
											) {
												repliedText = await decryptEcdhMessage(
													repliedMessage.ciphertext,
													repliedMessage.nonce,
													currentUserId,
													repliedMessage.sender_id === currentUserId
														? repliedMessage.receiver_id
														: repliedMessage.sender_id,
													userPassword,
													repliedMessage.sender_id === currentUserId,
												)
											} else if (repliedMessage.text) {
												repliedText = await MessageEncryption.decryptMessage(
													repliedMessage.text,
													userPassword,
												)
											}
										} else {
											repliedText = repliedMessage.text || '[Сообщение]'
										}
										messageObj.replied_message = {
											...msg.replied_message,
											text: repliedText,
										}
									}
								} catch (error) {
									console.error(
										'Ошибка получения данных ответного сообщения:',
										error,
									)
								}
							}
							await addMessageToChat(messageObj, isMyMessage, false)
						} catch (error) {
							console.error('Ошибка обработки сообщения:', error)
							await addMessageToChat(
								{ ...msg, text: '[Ошибка дешифрования]', is_encrypted: true },
								isMyMessage,
								false,
							)
						}
					}
					setTimeout(() => {
						const messagesWrapper = document.getElementById(
							'chat-messages-wrapper',
						)
						if (messagesWrapper) {
							messagesWrapper.scrollTop = messagesWrapper.scrollHeight
							updateStickyDateHeaders()
						}
					}, 100)
				}

				function showNoPasswordError() {
					const messagesContainer = document.getElementById('chat-messages')
					messagesContainer.innerHTML = `
                    <div class="error-message">
                        <div style="color: #f44336; font-weight: bold;">Ошибка дешифрования</div>
                        <div style="margin-top: 10px;">Для просмотра зашифрованных сообщений необходимо войти в систему.</div>
                        <button onclick="window.location.reload()" style="margin-top: 15px; padding: 8px 16px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer;">Перезагрузить страницу</button>
                    </div>
                `
				}

				async function getFullEcdhMessageData(messageId) {
					try {
						const userId = localStorage.getItem('user_id')
						if (!currentChatUserId) {
							console.error('Не выбран чат для поиска сообщения')
							return null
						}
						try {
							const ecdhHistory = await eel.get_ecdh_chat_history(
								userId,
								currentChatUserId,
							)()
							if (ecdhHistory.success && ecdhHistory.messages) {
								const message = ecdhHistory.messages.find(
									msg => msg.id === messageId,
								)
								if (message) return message
							}
						} catch (ecdhError) {
							console.warn('ECDH история не найдена:', ecdhError)
						}
						try {
							const regularHistory = await eel.get_encrypted_chat_history(
								userId,
								currentChatUserId,
							)()
							if (regularHistory.success && regularHistory.messages) {
								const message = regularHistory.messages.find(
									msg => msg.id === messageId,
								)
								if (message) return message
							}
						} catch (regularError) {
							console.warn('Обычная история не найдена:', regularError)
						}
						try {
							const messageData = await eel.get_message_data(messageId)()
							return messageData
						} catch (basicError) {
							console.error(
								'Не удалось получить базовые данные сообщения:',
								basicError,
							)
							return null
						}
					} catch (error) {
						console.error('Ошибка получения полных данных сообщения:', error)
						return null
					}
				}

				async function openChat(userId) {
					console.log('=== НАЧАЛО openChat ===', userId)
					const currentUserId = localStorage.getItem('user_id')
					const userPassword = sessionStorage.getItem('user_password')

					if (
						currentChatUserId === userId &&
						!document
							.getElementById('chat-container')
							.classList.contains('hidden')
					) {
						console.log('Чат уже открыт, просто обновляем')
						await updateUserStatus()
						startMessagePolling(userId)
						startReadStatusPolling()
						return
					}

					stopMessagePolling()
					stopReadStatusPolling()
					if (readStatusInterval) clearInterval(readStatusInterval)
					if (statusUpdateInterval) clearInterval(statusUpdateInterval)

					if (currentChatUserId) {
						try {
							const messagesWrapper = document.getElementById(
								'chat-messages-wrapper',
							)
							if (messagesWrapper)
								scrollPositions[currentChatUserId] = messagesWrapper.scrollTop
							const currentText = document.getElementById('message-input').value
							if (currentText.trim()) {
								await eel.save_draft_message(
									currentUserId,
									currentChatUserId,
									currentText,
								)()
							}
							chatInputs[currentChatUserId] = currentText
						} catch (error) {
							console.warn(
								'Ошибка сохранения состояния предыдущего чата:',
								error,
							)
						}
					}

					stopVoiceMessage()
					await clearReplyState()
					dateHeaders.clear()
					currentStickyDate = null
					currentChatUserId = userId

					try {
						const user = await eel.get_user_data(userId)()
						if (!user) {
							console.error('Пользователь не найден')
							alert('Пользователь не найден')
							return
						}

						document.getElementById('default-content').classList.add('hidden')
						document.getElementById('chat-container').classList.remove('hidden')
						const chatUsername = document.getElementById('chat-username')
						if (chatUsername)
							chatUsername.textContent =
								userId === currentUserId ? 'Избранное' : user.nickname

						await updateUserStatus()

						if (userId !== currentUserId && userPassword) {
							try {
								const peerKeyResult = await eel.get_public_key(userId)()
								if (peerKeyResult.success) {
									const sharedResult = await eel.compute_shared_secret(
										currentUserId,
										peerKeyResult.public_key,
										userPassword,
									)()
									if (sharedResult.success) {
										console.log('ECDH шифрование настроено')
										showEncryptionIndicator()
									} else {
										console.warn(
											'Не удалось вычислить общий секрет:',
											sharedResult.message,
										)
										hideEncryptionIndicator()
									}
								} else {
									console.warn(
										'Не удалось получить публичный ключ собеседника:',
										peerKeyResult.message,
									)
									hideEncryptionIndicator()
								}
								await eel.mark_chat_messages_as_read(currentUserId, userId)()
							} catch (encryptionError) {
								console.error(
									'Ошибка настройки ECDH шифрования:',
									encryptionError,
								)
								hideEncryptionIndicator()
							}
						} else {
							hideEncryptionIndicator()
						}

						initCustomScroll()
						const messagesContainer = document.getElementById('chat-messages')
						messagesContainer.innerHTML = ''
						dateHeaders.clear()
						window.messageElements.clear()

						try {
							await loadEcdhChatHistory(userId)
						} catch (historyError) {
							console.error('Ошибка загрузки истории:', historyError)
							messagesContainer.innerHTML = `
                            <div class="error-message">
                                <div style="color: #f44336; font-weight: bold;">Ошибка загрузки чата</div>
                                <div style="margin-top: 10px;">Не удалось загрузить историю сообщений.</div>
                                <button onclick="window.location.reload()" style="margin-top: 15px; padding: 8px 16px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer;">Перезагрузить страницу</button>
                            </div>
                        `
						}

						try {
							const draftText = await eel.get_draft_message(
								currentUserId,
								userId,
							)()
							const messageInput = document.getElementById('message-input')
							if (messageInput) {
								messageInput.value = draftText || chatInputs[userId] || ''
								messageInput.focus()
							}
						} catch (draftError) {
							console.warn('Ошибка восстановления черновика:', draftError)
						}

						try {
							await checkAndRestoreReplyState()
						} catch (replyError) {
							console.warn('Ошибка восстановления ответа:', replyError)
						}

						startMessagePolling(userId)
						startReadStatusPolling()

						statusUpdateInterval = setInterval(updateUserStatus, 5000)

						document
							.querySelectorAll('.user-bar')
							.forEach(el => el.classList.remove('active-chat'))
						const userCard = document.querySelector(
							`.user-bar[data-user-id="${userId}"]`,
						)
						if (userCard) {
							userCard.classList.add('active-chat')
							setTimeout(
								() =>
									userCard.scrollIntoView({
										behavior: 'smooth',
										block: 'nearest',
									}),
								100,
							)
						}

						setTimeout(() => {
							const messagesWrapper = document.getElementById(
								'chat-messages-wrapper',
							)
							if (messagesWrapper && scrollPositions[userId]) {
								messagesWrapper.scrollTop = scrollPositions[userId]
							} else if (messagesWrapper) {
								messagesWrapper.scrollTop = messagesWrapper.scrollHeight
							}
							updateStickyDateHeaders()
						}, 100)

						window.addEventListener('resize', updateStickyDateHeaders)
						console.log('=== ЧАТ УСПЕШНО ОТКРЫТ ===')
					} catch (error) {
						console.error('Критическая ошибка при открытии чата:', error)
						if (currentChatUserId) {
							const previousUserCard = document.querySelector(
								`.user-bar[data-user-id="${currentChatUserId}"]`,
							)
							if (previousUserCard)
								previousUserCard.classList.add('active-chat')
						}
						alert('Не удалось открыть чат: ' + error.message)
						document
							.getElementById('default-content')
							.classList.remove('hidden')
						document.getElementById('chat-container').classList.add('hidden')
						currentChatUserId = null
						stopMessagePolling()
						stopReadStatusPolling()
					}
				}

				async function closeChatAndReset() {
					document.getElementById('default-content').classList.remove('hidden')
					document.getElementById('chat-container').classList.add('hidden')
					currentChatUserId = null
					document
						.querySelectorAll('.user-bar')
						.forEach(el => el.classList.remove('active-chat'))
					stopVoiceMessage()
					currentPlayingAudio = null
					voiceMessagePlaying = false
					currentPlayingVoiceElement = null
					document.getElementById('message-input').value = ''
					await clearReplyState()
					if (readStatusInterval) clearInterval(readStatusInterval)
					if (statusUpdateInterval) clearInterval(statusUpdateInterval)
					console.log('Чат закрыт по ESC, возврат на главный экран')
				}

				function closeChat(softClose = false) {
					document.getElementById('default-content').classList.remove('hidden')
					document.getElementById('chat-container').classList.add('hidden')
					document
						.querySelectorAll('.user-bar')
						.forEach(el => el.classList.remove('active-chat'))
					stopVoiceMessage()
					currentPlayingAudio = null
					voiceMessagePlaying = false
					currentPlayingVoiceElement = null
					if (!softClose) currentChatUserId = null
					lastMessageId = null
					if (readStatusInterval) clearInterval(readStatusInterval)
					if (statusUpdateInterval) clearInterval(statusUpdateInterval)
				}

				async function updateUserStatus() {
					if (!currentChatUserId) return
					try {
						const user = await eel.get_user_data(currentChatUserId)()
						if (!user) return
						const statusElement = document.getElementById('chat-status')
						const now = new Date()
						const lastOnline = new Date(user.last_online + ' UTC')
						const diffMinutes = Math.floor((now - lastOnline) / (1000 * 60))

						if (currentChatUserId === localStorage.getItem('user_id')) {
							statusElement.textContent = ''
							statusElement.classList.remove('online')
						} else if (diffMinutes < 5) {
							statusElement.textContent = 'В сети'
							statusElement.classList.add('online')
						} else {
							statusElement.textContent = `Был(а) в сети ${formatTimeAgo(lastOnline)}`
							statusElement.classList.remove('online')
						}
						updateOnlineStatusInContacts()
					} catch (error) {
						console.error('Ошибка при обновлении статуса:', error)
					}
				}

				function updateOnlineStatusInContacts() {
					const userBars = document.querySelectorAll(
						'.user-bar:not(.current-user)',
					)
					userBars.forEach(async bar => {
						const userId = bar.dataset.userId
						try {
							const user = await eel.get_user_data(userId)()
							if (user) {
								const now = new Date()
								const lastOnline = new Date(user.last_online + ' UTC')
								const diffMinutes = Math.floor((now - lastOnline) / (1000 * 60))
								const avatar = bar.querySelector('.avatar-medium')
								if (diffMinutes < 5) avatar.classList.add('online')
								else avatar.classList.remove('online')
							}
						} catch (error) {
							console.error('Ошибка при обновлении статуса контакта:', error)
						}
					})
				}

				async function updateLastMessageOnUserCard(
					userId,
					messageText,
					isMyMessage = false,
				) {
					const userCard = document.querySelector(
						`.user-bar[data-user-id="${userId}"]`,
					)
					if (!userCard) return
					const lastMsgDiv = userCard.querySelector('.last-message')
					const contentWrapper = userCard.querySelector('.user-content-wrapper')
					let displayText = messageText || '[Сообщение]'
					if (displayText.length > 25)
						displayText = displayText.substring(0, 22) + '...'
					if (isMyMessage) {
						if (lastMsgDiv) {
							lastMsgDiv.innerHTML = `<span class="you-indicator">Вы:</span> ${displayText}`
						} else if (contentWrapper) {
							const newLastMsgDiv = document.createElement('div')
							newLastMsgDiv.className = 'last-message'
							newLastMsgDiv.innerHTML = `<span class="you-indicator">Вы:</span> ${displayText}`
							contentWrapper.appendChild(newLastMsgDiv)
						}
					} else {
						if (lastMsgDiv) {
							lastMsgDiv.textContent = displayText
						} else if (contentWrapper) {
							const newLastMsgDiv = document.createElement('div')
							newLastMsgDiv.className = 'last-message'
							newLastMsgDiv.textContent = displayText
							contentWrapper.appendChild(newLastMsgDiv)
						}
					}
				}

				async function updateLastMessageAfterDelete(
					chatUserId,
					lastMessageData = null,
				) {
					if (!chatUserId) return
					console.log('Обновляем последнее сообщение для чата:', chatUserId)
					try {
						const userId = localStorage.getItem('user_id')
						let lastMessage = lastMessageData
						if (!lastMessage)
							lastMessage = await eel.get_last_message(userId, chatUserId)()
						const userCard = document.querySelector(
							`.user-bar[data-user-id="${chatUserId}"]`,
						)
						if (!userCard) {
							console.log('Карточка пользователя не найдена:', chatUserId)
							return
						}
						const contentWrapper = userCard.querySelector(
							'.user-content-wrapper',
						)
						if (!contentWrapper) return

						const existingLastMsg = userCard.querySelector('.last-message')
						if (existingLastMsg) existingLastMsg.remove()

						const newLastMsgDiv = document.createElement('div')
						newLastMsgDiv.className = 'last-message'

						if (lastMessage) {
							let displayText = '[Сообщение]'
							let isMyMessage = lastMessage.sender_id === userId
							if (lastMessage.is_encrypted) {
								try {
									const password = sessionStorage.getItem('user_password')
									if (password) {
										if (
											lastMessage.encryption_type === 'ECDH-AES-GCM' &&
											lastMessage.ciphertext &&
											lastMessage.nonce
										) {
											displayText = await decryptEcdhMessage(
												lastMessage.ciphertext,
												lastMessage.nonce,
												userId,
												lastMessage.sender_id === userId
													? chatUserId
													: lastMessage.sender_id,
												password,
												isMyMessage,
											)
										} else if (lastMessage.text) {
											displayText = await MessageEncryption.decryptMessage(
												lastMessage.text,
												password,
											)
										} else {
											displayText = 'Зашифрованное сообщение'
										}
									} else {
										displayText = 'Зашифрованное сообщение'
									}
								} catch (e) {
									console.error('Ошибка дешифрования:', e)
									displayText = 'Зашифрованное сообщение'
								}
							} else {
								displayText = lastMessage.text || '[Сообщение]'
							}
							if (displayText.length > 25)
								displayText = displayText.substring(0, 22) + '...'
							if (isMyMessage) {
								newLastMsgDiv.innerHTML = `<span class="you-indicator">Вы:</span> ${displayText}`
							} else {
								newLastMsgDiv.textContent = displayText
							}
							console.log('Обновлено последнее сообщение:', displayText)
						} else {
							newLastMsgDiv.textContent = 'Нет сообщений'
							newLastMsgDiv.style.color = '#999'
							newLastMsgDiv.style.fontStyle = 'italic'
							console.log('Сообщений больше нет, показываем "Нет сообщений"')
						}
						contentWrapper.appendChild(newLastMsgDiv)
					} catch (error) {
						console.error('Ошибка при обновлении последнего сообщения:', error)
					}
				}

				async function loadAllLastMessages() {
					try {
						const user_id = localStorage.getItem('user_id')
						const userData = await eel.get_user_data(user_id)()
						if (
							!userData ||
							!userData.friends ||
							userData.friends.length === 0
						) {
							console.log('Нет друзей для загрузки сообщений')
							return
						}
						console.log(
							`Загружаем последние сообщения для ${userData.friends.length} друзей...`,
						)
						const userPassword = sessionStorage.getItem('user_password')
						if (!userPassword) {
							console.warn(
								'Пароль не найден в sessionStorage. Пропускаем дешифрование.',
							)
							return
						}
						for (const friendId of userData.friends) {
							try {
								const lastMessage = await eel.get_last_message(
									user_id,
									friendId,
								)()
								if (lastMessage) {
									let displayText = lastMessage.text || '[Сообщение]'
									let isMyMessage = lastMessage.sender_id === user_id
									if (lastMessage.is_encrypted) {
										try {
											if (lastMessage.encryption_type === 'ECDH-AES-GCM') {
												if (lastMessage.ciphertext && lastMessage.nonce) {
													displayText = await decryptEcdhMessage(
														lastMessage.ciphertext,
														lastMessage.nonce,
														user_id,
														friendId,
														userPassword,
														isMyMessage,
													)
												} else {
													displayText = 'Зашифрованное сообщение'
												}
											} else {
												displayText = await MessageEncryption.decryptMessage(
													lastMessage.text,
													userPassword,
												)
											}
										} catch (decryptError) {
											console.error(
												`Ошибка дешифрования для ${friendId}:`,
												decryptError,
											)
											displayText = 'Зашифрованное сообщение'
										}
									}
									updateLastMessageOnUserCard(
										friendId,
										displayText,
										isMyMessage,
									)
									console.log(
										`Сообщение дешифровано для пользователя ${friendId}:`,
										displayText.substring(0, 30) + '...',
									)
								}
							} catch (friendError) {
								console.error(
									`Ошибка обработки друга ${friendId}:`,
									friendError,
								)
							}
						}
						console.log('Дешифрование последних сообщений завершено')
					} catch (error) {
						console.error('Ошибка загрузки всех последних сообщений:', error)
					}
				}

				async function checkForNewMessages() {
					if (!currentChatUserId) return
					try {
						const userId = localStorage.getItem('user_id')
						const messages = Array.from(
							document.querySelectorAll('.message[data-id]'),
						)
						let lastMessageId = null
						if (messages.length > 0) {
							messages.sort(
								(a, b) =>
									new Date(a.dataset.timestamp).getTime() -
									new Date(b.dataset.timestamp).getTime(),
							)
							lastMessageId = messages[messages.length - 1].dataset.id
						}
						const response = await eel.get_new_messages(
							userId,
							currentChatUserId,
							lastMessageId,
						)()
						if (
							response.success &&
							response.messages &&
							response.messages.length > 0
						) {
							console.log(
								`Получено ${response.messages.length} новых сообщений`,
							)
							const newMessages = response.messages.sort(
								(a, b) =>
									new Date(a.timestamp).getTime() -
									new Date(b.timestamp).getTime(),
							)
							for (const msg of newMessages) {
								if (document.querySelector(`.message[data-id="${msg.id}"]`))
									continue
								const isMyMessage = msg.sender_id === userId
								await addMessageToChat(msg, isMyMessage, false)
								let displayText = msg.text || '[Сообщение]'
								if (msg.is_encrypted) {
									if (
										msg.encryption_type === 'ECDH-AES-GCM' &&
										msg.ciphertext &&
										msg.nonce
									) {
										try {
											const password = sessionStorage.getItem('user_password')
											if (password) {
												displayText = await decryptEcdhMessage(
													msg.ciphertext,
													msg.nonce,
													userId,
													msg.sender_id === userId
														? msg.receiver_id
														: msg.sender_id,
													password,
													isMyMessage,
												)
											} else {
												displayText = 'Зашифрованное сообщение'
											}
										} catch (e) {
											console.error('Ошибка дешифрования:', e)
											displayText = 'Зашифрованное сообщение'
										}
									} else if (msg.text) {
										try {
											const password = sessionStorage.getItem('user_password')
											if (password)
												displayText = await MessageEncryption.decryptMessage(
													msg.text,
													password,
												)
											else displayText = 'Зашифрованное сообщение'
										} catch (e) {
											displayText = 'Зашифрованное сообщение'
										}
									}
								}
								updateLastMessageOnUserCard(
									currentChatUserId,
									displayText,
									isMyMessage,
								)
							}
							const messagesWrapper = document.getElementById(
								'chat-messages-wrapper',
							)
							if (messagesWrapper) {
								const isAtBottom =
									messagesWrapper.scrollHeight - messagesWrapper.scrollTop <=
									messagesWrapper.clientHeight + 100
								if (isAtBottom)
									setTimeout(
										() =>
											(messagesWrapper.scrollTop =
												messagesWrapper.scrollHeight),
										50,
									)
							}
						}

						const currentMessageIds = Array.from(
							document.querySelectorAll('.message[data-id]'),
						)
							.map(el => el.dataset.id)
							.filter(id => id)
						if (currentMessageIds.length > 0) {
							try {
								const readStatus =
									await eel.check_message_read_status_bulk(currentMessageIds)()
								for (const messageId of currentMessageIds) {
									if (readStatus[messageId] === undefined) {
										const messageElement = document.querySelector(
											`.message[data-id="${messageId}"]`,
										)
										if (messageElement) {
											messageElement.remove()
											console.log(`Сообщение ${messageId} удалено из чата`)
										}
									}
								}
								if (currentMessageIds.length > Object.keys(readStatus).length)
									await updateLastMessageAfterDelete(currentChatUserId)
							} catch (error) {
								console.error('Ошибка при проверке удалённых сообщений:', error)
							}
						}
					} catch (error) {
						console.error('Ошибка при проверке новых сообщений:', error)
					}
				}

				function startMessagePolling(chatId) {
					if (messageCheckInterval) clearInterval(messageCheckInterval)
					if (!chatId) return
					console.log('Запуск проверки новых сообщений для чата:', chatId)
					messageCheckInterval = setInterval(async () => {
						if (!currentChatUserId || currentChatUserId !== chatId) {
							if (currentChatUserId !== chatId) stopMessagePolling()
							return
						}
						await checkForNewMessages()
					}, 2000)
				}

				function stopMessagePolling() {
					if (messageCheckInterval) {
						clearInterval(messageCheckInterval)
						messageCheckInterval = null
						console.log('Проверка сообщений остановлена')
					}
				}

				function startReadStatusPolling() {
					if (readStatusCheckInterval) clearInterval(readStatusCheckInterval)
					console.log('Запуск проверки статуса прочтения')
					readStatusCheckInterval = setInterval(async () => {
						await checkMessagesReadStatus()
					}, 3000)
				}

				function stopReadStatusPolling() {
					if (readStatusCheckInterval) {
						clearInterval(readStatusCheckInterval)
						readStatusCheckInterval = null
						console.log('Проверка статуса прочтения остановлена')
					}
				}

				async function checkMessagesReadStatus() {
					if (!currentChatUserId) return
					try {
						const myMessages = Array.from(
							document.querySelectorAll('.my-message[data-id]'),
						)
							.map(el => el.dataset.id)
							.filter(id => id)
						if (myMessages.length === 0) return
						const readStatus =
							await eel.check_message_read_status_bulk(myMessages)()
						for (const [messageId, isRead] of Object.entries(readStatus)) {
							const messageElement = document.querySelector(
								`.message[data-id="${messageId}"]`,
							)
							if (messageElement) {
								const readStatusSpan =
									messageElement.querySelector('.read-status')
								if (readStatusSpan) {
									const oldStatus = readStatusSpan.textContent
									const newStatus = isRead ? '✓✓' : '✓'
									if (oldStatus !== newStatus) {
										readStatusSpan.textContent = newStatus
										readStatusSpan.style.color = isRead ? '#4CAF50' : '#999'
										console.log(
											`Обновлен статус сообщения ${messageId}: ${newStatus}`,
										)
									}
								}
							}
						}
					} catch (error) {
						console.error('Ошибка при проверке статуса прочтения:', error)
					}
				}

				function updateMessageReadStatus(messageId, isRead) {
					if (window.messageElements && window.messageElements.has(messageId)) {
						const messageElement = window.messageElements.get(messageId)
						const readStatus = messageElement.querySelector('.read-status')
						if (readStatus) {
							readStatus.textContent = isRead ? '✓✓' : '✓'
							readStatus.style.color = isRead ? '#4CAF50' : '#999'
						}
					}
				}

				function updateMessageText(messageId, newText) {
					if (window.messageElements && window.messageElements.has(messageId)) {
						const messageElement = window.messageElements.get(messageId)
						const textElement = messageElement.querySelector('.message-text')
						if (textElement) {
							textElement.textContent = newText
							const editBadge = document.createElement('span')
							editBadge.className = 'edit-badge'
							editBadge.textContent = ' (ред.)'
							editBadge.style.color = '#999'
							editBadge.style.fontSize = '0.8em'
							textElement.appendChild(editBadge)
						}
					}
				}

				async function addMessageToChat(
					message,
					isMyMessage,
					scrollToBottom = true,
				) {
					const messagesContainer = document.getElementById('chat-messages')
					if (!messagesContainer) {
						console.error('Messages container not found')
						return null
					}

					if (message.id) {
						const existingMessage = document.querySelector(
							`.message[data-id="${message.id}"]`,
						)
						if (existingMessage) {
							if (isMyMessage && message.read !== undefined) {
								const readStatus = existingMessage.querySelector('.read-status')
								if (readStatus) {
									readStatus.textContent = message.read ? '✓✓' : '✓'
									readStatus.style.color = message.read ? '#4CAF50' : '#999'
								}
							}
							return existingMessage
						}
						if (window.messageElements.has(message.id))
							return window.messageElements.get(message.id)
					}

					const noMessagesDiv = messagesContainer.querySelector('.no-messages')
					if (noMessagesDiv) noMessagesDiv.remove()

					if (!message) return null

					let messageTimestamp = message.timestamp || new Date().toISOString()
					if (
						typeof messageTimestamp === 'string' &&
						!messageTimestamp.includes('Z') &&
						!messageTimestamp.includes('+')
					) {
						messageTimestamp += 'Z'
					}

					const messageDate = new Date(messageTimestamp)
					const dateKey = messageDate.toDateString()

					if (!dateHeaders.has(dateKey)) {
						const dateText = formatMessageDate(messageTimestamp)
						const dateHeader = createDateHeader(dateText, dateKey)
						const allChildren = Array.from(messagesContainer.children)
						let dateInsertIndex = allChildren.length
						for (let i = 0; i < allChildren.length; i++) {
							const child = allChildren[i]
							if (
								child.classList.contains('message') &&
								child.dataset.timestamp
							) {
								const childDate = new Date(child.dataset.timestamp)
								if (messageDate < childDate) {
									dateInsertIndex = i
									break
								}
							}
						}
						if (dateInsertIndex < allChildren.length) {
							messagesContainer.insertBefore(
								dateHeader,
								allChildren[dateInsertIndex],
							)
						} else {
							messagesContainer.appendChild(dateHeader)
						}
						dateHeaders.set(dateKey, dateHeader)
					}

					const messageElement = document.createElement('div')
					messageElement.className = `message ${isMyMessage ? 'my-message' : 'their-message'}`
					messageElement.dataset.id = message.id || ''
					messageElement.dataset.sender_id = message.sender_id || ''
					messageElement.dataset.receiver_id = message.receiver_id || ''
					messageElement.dataset.timestamp = messageTimestamp
					messageElement.dataset.encryption_type = message.encryption_type || ''

					if (message.reply_to_message_id || message.replied_message) {
						messageElement.classList.add('with-reply')
					}

					const messageContent = document.createElement('div')
					messageContent.className = 'message-content'

					if (message.reply_to_message_id || message.replied_message) {
						const replyPreview = document.createElement('div')
						replyPreview.className = 'reply-preview'

						let repliedText = '[Сообщение]'
						let replyAuthor = 'Собеседник'

						if (message.replied_message && message.replied_message.text) {
							repliedText = message.replied_message.text
							replyAuthor =
								message.replied_message.sender_id ===
								localStorage.getItem('user_id')
									? 'Вы'
									: document.getElementById('chat-username')?.textContent ||
										'Собеседник'
						} else if (message.reply_to_message_id) {
							try {
								const repliedMessage = await getFullEcdhMessageData(
									message.reply_to_message_id,
								)
								if (repliedMessage) {
									if (repliedMessage.is_encrypted) {
										if (
											repliedMessage.encryption_type === 'ECDH-AES-GCM' &&
											repliedMessage.ciphertext &&
											repliedMessage.nonce
										) {
											try {
												const userId = localStorage.getItem('user_id')
												const password = sessionStorage.getItem('user_password')
												if (password) {
													repliedText = await decryptEcdhMessage(
														repliedMessage.ciphertext,
														repliedMessage.nonce,
														userId,
														repliedMessage.sender_id === userId
															? repliedMessage.receiver_id
															: repliedMessage.sender_id,
														password,
														repliedMessage.sender_id === userId,
													)
												} else {
													repliedText = '[Зашифрованное сообщение]'
												}
											} catch (decryptError) {
												console.error(
													'Ошибка дешифрования ответного сообщения:',
													decryptError,
												)
												repliedText = '[Не удалось расшифровать]'
											}
										} else {
											const userPassword =
												sessionStorage.getItem('user_password')
											if (userPassword) {
												repliedText = await MessageEncryption.decryptMessage(
													repliedMessage.text ||
														repliedMessage.ciphertext ||
														'',
													userPassword,
												)
											} else {
												repliedText = '[Зашифрованное сообщение]'
											}
										}
									} else {
										repliedText = repliedMessage.text || '[Сообщение]'
									}
									replyAuthor =
										repliedMessage.sender_id === localStorage.getItem('user_id')
											? 'Вы'
											: document.getElementById('chat-username')?.textContent ||
												'Собеседник'
								}
							} catch (error) {
								console.error('Ошибка получения данных ответа:', error)
								repliedText = '[Не удалось загрузить]'
							}
						}

						const displayRepliedText =
							repliedText.length > 50
								? repliedText.substring(0, 47) + '...'
								: repliedText
						replyPreview.innerHTML = `
                        <div class="reply-author">${escapeHtml(replyAuthor)}</div>
                        <div class="reply-text">${escapeHtml(displayRepliedText)}</div>
                    `
						replyPreview.addEventListener('click', function (e) {
							e.stopPropagation()
							const originalMessage = document.querySelector(
								`.message[data-id="${message.reply_to_message_id}"]`,
							)
							if (originalMessage) {
								originalMessage.scrollIntoView({
									behavior: 'smooth',
									block: 'center',
								})
								originalMessage.style.backgroundColor = isMyMessage
									? '#c8e6c9'
									: '#e3f2fd'
								originalMessage.style.transition = 'background-color 0.3s'
								setTimeout(
									() => (originalMessage.style.backgroundColor = ''),
									1000,
								)
							}
						})
						messageContent.appendChild(replyPreview)
					}

					const textElement = document.createElement('div')
					textElement.className = 'message-text'

					let displayText = message.text || '[Сообщение]'

					if (
						message.is_encrypted &&
						message.ciphertext &&
						message.nonce &&
						message.encryption_type === 'ECDH-AES-GCM'
					) {
						try {
							const userId = localStorage.getItem('user_id')
							const password = sessionStorage.getItem('user_password')
							if (password) {
								displayText = await decryptEcdhMessage(
									message.ciphertext,
									message.nonce,
									userId,
									message.sender_id === userId
										? message.receiver_id
										: message.sender_id,
									password,
									message.sender_id === userId,
								)
							} else {
								displayText = 'Зашифрованное сообщение'
							}
						} catch (decryptError) {
							console.error('Ошибка дешифрования сообщения:', decryptError)
							displayText = ' Не удалось расшифровать'
						}
					} else if (message.is_encrypted && message.text) {
						try {
							const userPassword = sessionStorage.getItem('user_password')
							if (userPassword) {
								displayText = await MessageEncryption.decryptMessage(
									message.text,
									userPassword,
								)
							} else {
								displayText = ' Зашифрованное сообщение'
							}
						} catch (error) {
							console.error('Ошибка дешифрования сообщения:', error)
							displayText = ' Не удалось расшифровать'
						}
					} else if (message.isMedia || message.is_media) {
						displayText =
							message.mediaType === 'video' || message.is_video
								? ' [Видео]'
								: '[Фото]'
					} else if (message.isVoiceMessage || message.is_voice) {
						displayText = ' [Голосовое сообщение]'
					}

					textElement.textContent = displayText
					messageContent.appendChild(textElement)

					const infoElement = document.createElement('div')
					infoElement.className = 'message-info'

					const timeElement = document.createElement('span')
					timeElement.textContent = formatMessageTime(messageTimestamp)
					infoElement.appendChild(timeElement)

					if (isMyMessage) {
						const readStatus = document.createElement('span')
						readStatus.textContent = message.read ? '✓✓' : '✓'
						readStatus.className = 'read-status'
						readStatus.style.color = message.read ? '#4CAF50' : '#999'
						readStatus.style.marginLeft = '5px'
						infoElement.appendChild(readStatus)
					}

					messageContent.appendChild(infoElement)
					messageElement.appendChild(messageContent)

					messageElement.addEventListener('contextmenu', e => {
						e.preventDefault()
						e.stopPropagation()
						currentContextMessage = messageElement
						const isMyMsg =
							message.sender_id === localStorage.getItem('user_id')
						const isMediaMsg = message.isMedia || message.is_media
						const isVoiceMsg = message.isVoiceMessage || message.is_voice
						const contextMenu = document.getElementById('message-context-menu')
						if (contextMenu) {
							const editItem = document.getElementById('message-edit')
							const deleteItem = document.getElementById('message-delete')
							const deleteForMeItem = document.getElementById(
								'message-delete-for-me',
							)
							const pinItem = document.getElementById('message-pin')
							const replyItem = document.getElementById('message-reply')
							const forwardItem = document.getElementById('message-forward')
							const copyItem = document.getElementById('message-copy')
							if (editItem)
								editItem.classList.toggle(
									'hidden',
									!isMyMsg || isMediaMsg || isVoiceMsg,
								)
							if (deleteItem) deleteItem.classList.toggle('hidden', !isMyMsg)
							if (deleteForMeItem)
								deleteForMeItem.classList.toggle('hidden', isMyMsg)
							if (pinItem)
								pinItem.classList.toggle('hidden', !isMyMsg || isVoiceMsg)
							if (replyItem) replyItem.classList.toggle('hidden', false)
							if (forwardItem) forwardItem.classList.toggle('hidden', false)
							if (copyItem) copyItem.classList.toggle('hidden', false)
							showMessageContextMenu(e)
						}
					})

					messageElement.addEventListener('dblclick', () => {
						if (message.sender_id !== localStorage.getItem('user_id')) {
							handleQuickReply(message)
						}
					})

					const existingMessages = Array.from(
						messagesContainer.querySelectorAll('.message'),
					)
					const newMessageTime = messageDate.getTime()
					let inserted = false

					for (let i = 0; i < existingMessages.length; i++) {
						const msg = existingMessages[i]
						if (msg.dataset.timestamp) {
							const msgTime = new Date(msg.dataset.timestamp).getTime()
							if (newMessageTime < msgTime) {
								messagesContainer.insertBefore(messageElement, msg)
								inserted = true
								break
							}
						}
					}

					if (!inserted) messagesContainer.appendChild(messageElement)

					if (message.id) window.messageElements.set(message.id, messageElement)

					if (scrollToBottom || isMyMessage) {
						setTimeout(() => {
							const messagesWrapper = document.getElementById(
								'chat-messages-wrapper',
							)
							if (messagesWrapper) {
								messagesWrapper.scrollTop = messagesWrapper.scrollHeight
								setTimeout(updateStickyDateHeaders, 100)
							}
						}, 0)
					}

					if (message.isVoiceMessage || message.is_voice) {
						await updateVoiceMessageStatus(messageElement, message)
					}

					console.log(
						`Сообщение ${message.id} добавлено в чат, время: ${messageTimestamp}`,
					)
					return messageElement
				}

				async function handleQuickReply(message) {
					const messageInput = document.getElementById('message-input')
					messageInput.focus()
					const replyContainer = document.getElementById('reply-container')
					if (replyContainer) {
						const isMyMessage =
							message.sender_id === localStorage.getItem('user_id')
						const fullMessageData = await getFullEcdhMessageData(message.id)
						let displayText = '[Сообщение]'
						if (fullMessageData) {
							if (fullMessageData.is_encrypted) {
								if (
									fullMessageData.encryption_type === 'ECDH-AES-GCM' &&
									fullMessageData.ciphertext &&
									fullMessageData.nonce
								) {
									try {
										const userId = localStorage.getItem('user_id')
										const password = sessionStorage.getItem('user_password')
										if (password) {
											displayText = await decryptEcdhMessage(
												fullMessageData.ciphertext,
												fullMessageData.nonce,
												userId,
												fullMessageData.sender_id === userId
													? fullMessageData.receiver_id
													: fullMessageData.sender_id,
												password,
												fullMessageData.sender_id === userId,
											)
										} else {
											displayText = '[Зашифрованное сообщение]'
										}
									} catch (decryptError) {
										console.error(
											'Ошибка дешифрования при ответе:',
											decryptError,
										)
										displayText = '[Не удалось расшифровать]'
									}
								} else {
									try {
										const userPassword = sessionStorage.getItem('user_password')
										if (userPassword) {
											displayText = await MessageEncryption.decryptMessage(
												fullMessageData.text,
												userPassword,
											)
										} else {
											displayText = '[Зашифрованное сообщение]'
										}
									} catch (error) {
										console.error('Ошибка дешифрования при ответе:', error)
										displayText = '[Не удалось расшифровать]'
									}
								}
							} else {
								displayText = fullMessageData.text || '[Сообщение]'
							}
						}

						replyContainer.innerHTML = `
                        <div class="reply-header">
                            <div class="reply-author">${isMyMessage ? 'Вы' : 'Собеседник'}</div>
                            <div class="reply-close">×</div>
                        </div>
                        <div class="reply-text">${displayText.length > 50 ? displayText.substring(0, 47) + '...' : displayText}</div>
                    `
						replyContainer.dataset.messageId = message.id
						replyContainer.classList.remove('hidden')
						document
							.querySelector('.message-input-container')
							.classList.add('expanded')
						replyContainer
							.querySelector('.reply-close')
							.addEventListener('click', async () => {
								await clearReplyState()
							})
						await eel.save_reply_state(
							localStorage.getItem('user_id'),
							currentChatUserId,
							message.id,
						)()
					}
				}

				async function clearReplyState() {
					const replyContainer = document.getElementById('reply-container')
					replyContainer.classList.add('hidden')
					document
						.querySelector('.message-input-container')
						.classList.remove('expanded')
					if (currentChatUserId) {
						const clearResult = await eel.clear_reply_state(
							localStorage.getItem('user_id'),
							currentChatUserId,
						)()
						if (!clearResult.success) {
							console.error(
								'Не удалось очистить состояние ответа:',
								clearResult.message,
							)
						} else {
							console.log(
								'Состояние ответа очищено для чата:',
								currentChatUserId,
							)
						}
					}
				}

				async function checkAndRestoreReplyState() {
					if (!currentChatUserId) return
					try {
						const replyState = await eel.get_reply_state(
							localStorage.getItem('user_id'),
							currentChatUserId,
						)()
						if (replyState.success && replyState.message_id) {
							const fullMessageData = await getFullEcdhMessageData(
								replyState.message_id,
							)
							if (fullMessageData) {
								const replyContainer =
									document.getElementById('reply-container')
								const isMyMessage =
									fullMessageData.sender_id === localStorage.getItem('user_id')
								let displayText = '[Сообщение]'
								if (fullMessageData.is_encrypted) {
									if (
										fullMessageData.encryption_type === 'ECDH-AES-GCM' &&
										fullMessageData.ciphertext &&
										fullMessageData.nonce
									) {
										try {
											const userId = localStorage.getItem('user_id')
											const password = sessionStorage.getItem('user_password')
											if (password) {
												displayText = await decryptEcdhMessage(
													fullMessageData.ciphertext,
													fullMessageData.nonce,
													userId,
													fullMessageData.sender_id === userId
														? fullMessageData.receiver_id
														: fullMessageData.sender_id,
													password,
													fullMessageData.sender_id === userId,
												)
											} else {
												displayText = '[Зашифрованное сообщение]'
											}
										} catch (decryptError) {
											console.error(
												'Ошибка дешифрования при восстановлении ответа:',
												decryptError,
											)
											displayText = '[Не удалось расшифровать]'
										}
									} else if (fullMessageData.text) {
										try {
											const userPassword =
												sessionStorage.getItem('user_password')
											if (userPassword) {
												displayText = await MessageEncryption.decryptMessage(
													fullMessageData.text,
													userPassword,
												)
											} else {
												displayText = '[Зашифрованное сообщение]'
											}
										} catch (error) {
											console.error(
												'Ошибка дешифрования старого сообщения при восстановлении:',
												error,
											)
											displayText = '[Не удалось расшифровать]'
										}
									}
								} else {
									displayText = fullMessageData.text || '[Сообщение]'
								}
								replyContainer.dataset.messageId = fullMessageData.id
								replyContainer.innerHTML = `
                                <div class="reply-header">
                                    <div class="reply-author">${isMyMessage ? 'Вы' : document.getElementById('chat-username').textContent}</div>
                                    <div class="reply-close">×</div>
                                </div>
                                <div class="reply-text">${displayText.length > 50 ? displayText.substring(0, 47) + '...' : displayText}</div>
                            `
								replyContainer.classList.remove('hidden')
								document
									.querySelector('.message-input-container')
									.classList.add('expanded')
								replyContainer
									.querySelector('.reply-close')
									.addEventListener('click', async () => {
										await clearReplyState()
									})
								console.log(
									'Состояние ответа восстановлено для чата:',
									currentChatUserId,
								)
							}
						} else {
							console.log(
								'Состояние ответа не найдено или устарело:',
								replyState.message,
							)
						}
					} catch (error) {
						console.error('Ошибка восстановления состояния ответа:', error)
					}
				}

				async function updateVoiceMessageStatus(messageElement, message) {
					const voiceElement = messageElement.querySelector('.voice-message')
					if (voiceElement) {
						const indicator = voiceElement.querySelector('.listen-indicator')
						if (indicator)
							indicator.style.opacity = message.listened ? '0' : '0.7'
					}
				}

				function initMessageContextMenu() {
					console.log('initMessageContextMenu вызвана')
					const messageContextMenu = document.getElementById(
						'message-context-menu',
					)
					window.messageContextMenu = messageContextMenu
					document.addEventListener('click', function (e) {
						if (messageContextMenu && !messageContextMenu.contains(e.target)) {
							messageContextMenu.classList.add('hidden')
						}
					})
					document.addEventListener('contextmenu', function (e) {
						const messageElement = e.target.closest('.message')
						if (messageElement) {
							e.preventDefault()
							currentContextMessage = messageElement
							const isVideoMessage =
								messageElement.querySelector('.video-preview') !== null
							const isVoiceMessage =
								messageElement.querySelector('.voice-message') !== null
							const isMyMessage =
								messageElement.classList.contains('my-message')
							document
								.getElementById('message-edit')
								.classList.toggle(
									'hidden',
									!isMyMessage || isVideoMessage || isVoiceMessage,
								)
							document
								.getElementById('message-delete')
								.classList.toggle('hidden', !isMyMessage)
							document
								.getElementById('message-delete-for-me')
								.classList.toggle('hidden', isMyMessage)
							document
								.getElementById('message-pin')
								.classList.toggle('hidden', !isMyMessage || isVoiceMessage)
							document
								.getElementById('message-reply')
								.classList.toggle('hidden', false)
							document
								.getElementById('message-forward')
								.classList.toggle('hidden', false)
							document
								.getElementById('message-copy')
								.classList.toggle('hidden', false)
							showMessageContextMenu(e)
						}
					})

					document
						.getElementById('message-reply')
						.addEventListener('click', function () {
							handleReply()
							closeMessageContextMenu()
						})
					document
						.getElementById('message-edit')
						.addEventListener('click', function () {
							handleEdit()
							closeMessageContextMenu()
						})
					document
						.getElementById('message-pin')
						.addEventListener('click', function () {
							handlePin()
							closeMessageContextMenu()
						})
					document
						.getElementById('message-delete')
						.addEventListener('click', function () {
							handleDelete()
							closeMessageContextMenu()
						})
					document
						.getElementById('message-forward')
						.addEventListener('click', function () {
							handleForward()
							closeMessageContextMenu()
						})
					document
						.getElementById('message-copy')
						.addEventListener('click', function () {
							handleCopy()
							closeMessageContextMenu()
						})

					function closeMessageContextMenu() {
						if (messageContextMenu) messageContextMenu.classList.add('hidden')
					}
				}

				function showMessageContextMenu(e) {
					const messageContextMenu = document.getElementById(
						'message-context-menu',
					)
					if (!messageContextMenu) return
					messageContextMenu.classList.add('hidden')
					const menuWidth = messageContextMenu.offsetWidth
					const menuHeight = messageContextMenu.offsetHeight
					const windowWidth = window.innerWidth
					const windowHeight = window.innerHeight
					let left = e.clientX
					let top = e.clientY
					if (left + menuWidth > windowWidth) left = windowWidth - menuWidth - 5
					if (top + menuHeight > windowHeight)
						top = windowHeight - menuHeight - 5
					messageContextMenu.style.left = `${left}px`
					messageContextMenu.style.top = `${top}px`
					messageContextMenu.style.display = 'block'
					messageContextMenu.classList.remove('hidden')
					messageContextMenu.style.zIndex = '1000'
				}

				async function handleReply() {
					if (!currentContextMessage) return
					try {
						const messageId = currentContextMessage.dataset.id
						const isMyMessage =
							currentContextMessage.classList.contains('my-message')
						const replyContainer = document.getElementById('reply-container')
						const messageData = await getFullEcdhMessageData(messageId)
						let displayText = '[Сообщение]'
						if (messageData) {
							if (messageData.is_encrypted) {
								if (
									messageData.encryption_type === 'ECDH-AES-GCM' &&
									messageData.ciphertext &&
									messageData.nonce
								) {
									try {
										const userId = localStorage.getItem('user_id')
										const password = sessionStorage.getItem('user_password')
										if (password) {
											displayText = await decryptEcdhMessage(
												messageData.ciphertext,
												messageData.nonce,
												userId,
												messageData.sender_id === userId
													? messageData.receiver_id
													: messageData.sender_id,
												password,
												messageData.sender_id === userId,
											)
										} else {
											displayText = '[Зашифрованное сообщение]'
										}
									} catch (decryptError) {
										console.error(
											'Ошибка дешифрования ECDH сообщения при ответе:',
											decryptError,
										)
										displayText = '[Не удалось расшифровать]'
									}
								} else if (messageData.text) {
									try {
										const userPassword = sessionStorage.getItem('user_password')
										if (userPassword) {
											displayText = await MessageEncryption.decryptMessage(
												messageData.text,
												userPassword,
											)
										} else {
											displayText = '[Зашифрованное сообщение]'
										}
									} catch (error) {
										console.error(
											'Ошибка дешифрования старого сообщения:',
											error,
										)
										displayText = '[Не удалось расшифровать]'
									}
								}
							} else {
								displayText = messageData.text || '[Сообщение]'
							}
						}
						await eel.save_reply_state(
							localStorage.getItem('user_id'),
							currentChatUserId,
							messageId,
						)()
						replyContainer.dataset.messageId = messageId
						replyContainer.innerHTML = `
                        <div class="reply-header">
                            <div class="reply-author">${isMyMessage ? 'Вы' : document.getElementById('chat-username').textContent}</div>
                            <div class="reply-close">×</div>
                        </div>
                        <div class="reply-text">${displayText.length > 50 ? displayText.substring(0, 47) + '...' : displayText}</div>
                    `
						replyContainer.classList.remove('hidden')
						document
							.querySelector('.message-input-container')
							.classList.add('expanded')
						replyContainer
							.querySelector('.reply-close')
							.addEventListener('click', async () => {
								await clearReplyState()
							})
						document.getElementById('message-input').focus()
						document.getElementById('message-input').value = ''
						console.log(
							'Состояние ответа сохранено для чата:',
							currentChatUserId,
						)
					} catch (error) {
						console.error('Ошибка при обработке ответа:', error)
						alert('Ошибка при создании ответа')
					}
				}

				function handleEdit() {
					if (!currentContextMessage) {
						document
							.getElementById('message-context-menu')
							.classList.add('hidden')
						return
					}
					try {
						const messageId = currentContextMessage.dataset.id
						const messageTextElement =
							currentContextMessage.querySelector('.message-text')
						const originalText = messageTextElement.textContent
						const input = document.createElement('input')
						input.type = 'text'
						input.value = originalText
						input.className = 'edit-message-input'
						messageTextElement.replaceWith(input)
						input.focus()
						const finishEditing = async newText => {
							if (newText && newText !== originalText) {
								const result = await eel.edit_message(messageId, newText)()
								if (!result.success)
									throw new Error(
										result.message || 'Не удалось изменить сообщение',
									)
								return newText
							}
							return originalText
						}
						const handleKeyDown = async e => {
							if (e.key === 'Enter') {
								const newText = input.value.trim()
								try {
									const finalText = await finishEditing(newText)
									messageTextElement.textContent = finalText
								} catch (error) {
									alert(error.message)
									messageTextElement.textContent = originalText
								}
								cleanup()
							} else if (e.key === 'Escape') {
								messageTextElement.textContent = originalText
								cleanup()
							}
						}
						const handleBlur = async () => {
							const newText = input.value.trim()
							try {
								const finalText = await finishEditing(newText)
								messageTextElement.textContent = finalText
							} catch (error) {
								alert(error.message)
								messageTextElement.textContent = originalText
							}
							cleanup()
						}
						const cleanup = () => {
							input.replaceWith(messageTextElement)
							input.removeEventListener('keydown', handleKeyDown)
							input.removeEventListener('blur', handleBlur)
							document
								.getElementById('message-context-menu')
								.classList.add('hidden')
						}
						input.addEventListener('keydown', handleKeyDown)
						input.addEventListener('blur', handleBlur)
					} catch (error) {
						console.error('Ошибка при редактировании:', error)
						alert('Ошибка при редактировании сообщения')
						document
							.getElementById('message-context-menu')
							.classList.add('hidden')
					}
				}

				function handlePin() {
					alert('Функция "Закрепить" будет реализована в будущем')
					document
						.getElementById('message-context-menu')
						.classList.add('hidden')
				}

				function handleForward() {
					alert('Функция "Переслать" будет реализована в будущем')
					document
						.getElementById('message-context-menu')
						.classList.add('hidden')
				}

				function handleCopy() {
					if (!currentContextMessage) {
						document
							.getElementById('message-context-menu')
							.classList.add('hidden')
						return
					}
					try {
						const messageText =
							currentContextMessage.querySelector('.message-text').textContent
						navigator.clipboard.writeText(messageText).catch(err => {
							console.error('Ошибка копирования:', err)
							alert('Не удалось скопировать текст')
						})
					} catch (error) {
						console.error('Ошибка при копировании:', error)
						alert('Ошибка при копировании текста')
					} finally {
						document
							.getElementById('message-context-menu')
							.classList.add('hidden')
					}
				}

				async function handleDelete() {
					if (!currentContextMessage) return
					try {
						const messageId = currentContextMessage.dataset.id
						const messageElement = currentContextMessage
						const isMyMessage = messageElement.classList.contains('my-message')
						const chatUserId = isMyMessage
							? messageElement.dataset.receiver_id
							: messageElement.dataset.sender_id

						if (!confirm('Вы уверены, что хотите удалить это сообщение?')) {
							document
								.getElementById('message-context-menu')
								.classList.add('hidden')
							return
						}

						if (isMyMessage) {
							const result = await eel.delete_message(messageId)()
							if (result.success) {
								messageElement.remove()
								if (result.last_message) {
									await updateLastMessageAfterDelete(
										currentChatUserId,
										result.last_message,
									)
								} else {
									await updateLastMessageAfterDelete(currentChatUserId, null)
								}
								console.log('Сообщение удалено, последнее сообщение обновлено')
							}
						} else {
							const userId = localStorage.getItem('user_id')
							const result = await eel.delete_message_for_me(
								userId,
								messageId,
							)()
							if (result.success) {
								messageElement.remove()
								await updateLastMessageAfterDelete(currentChatUserId)
							}
						}
					} catch (error) {
						console.error('Ошибка удаления:', error)
						alert('Ошибка при удалении сообщения')
					} finally {
						document
							.getElementById('message-context-menu')
							.classList.add('hidden')
					}
				}

				async function notify_message_deleted(
					messageId,
					senderId,
					receiverId,
					lastMessageData,
				) {
					console.log('=== ПОЛУЧЕНО УВЕДОМЛЕНИЕ ОБ УДАЛЕНИИ ===', {
						messageId,
						senderId,
						receiverId,
					})
					const currentUserId = localStorage.getItem('user_id')
					if (currentChatUserId === senderId) {
						const messageElement = document.querySelector(
							`.message[data-id="${messageId}"]`,
						)
						if (messageElement) {
							messageElement.remove()
							console.log(`Сообщение ${messageId} удалено из чата`)
						}
					}
					const chatUserId = senderId === currentUserId ? receiverId : senderId
					if (lastMessageData) {
						await updateLastMessageAfterDelete(chatUserId, lastMessageData)
					} else {
						await updateLastMessageAfterDelete(chatUserId)
					}
					console.log('=== УВЕДОМЛЕНИЕ ОБ УДАЛЕНИИ ОБРАБОТАНО ===')
				}

				function get_current_user_id() {
					return localStorage.getItem('user_id')
				}

				async function loadFriends() {
					console.log('=== НАЧАЛО loadFriends ===')
					const user_id = localStorage.getItem('user_id')
					if (!user_id) {
						console.error('User ID не найден в localStorage')
						return
					}
					try {
						currentUser = await eel.get_user_data(user_id)()
						const container = document.getElementById('user-container')
						container.innerHTML = ''
						const selfCard = createUserCard({
							user_id: user_id,
							nickname: 'Избранное',
							isCurrentUser: true,
							isSelfChat: true,
						})
						container.appendChild(selfCard)

						if (currentUser.friends && currentUser.friends.length > 0) {
							const friendPromises = currentUser.friends.map(async friendId => {
								try {
									const friend = await eel.get_user_data(friendId)()
									if (friend) {
										const lastMessage = await eel.get_last_message(
											user_id,
											friendId,
										)()
										let decryptedText = '[Нет сообщений]'
										if (lastMessage) {
											if (lastMessage.is_encrypted) {
												try {
													const userPassword =
														sessionStorage.getItem('user_password')
													if (userPassword) {
														if (
															lastMessage.encryption_type === 'ECDH-AES-GCM' &&
															lastMessage.ciphertext &&
															lastMessage.nonce
														) {
															decryptedText = await decryptEcdhMessage(
																lastMessage.ciphertext,
																lastMessage.nonce,
																user_id,
																lastMessage.sender_id === user_id
																	? friendId
																	: lastMessage.sender_id,
																userPassword,
																lastMessage.sender_id === user_id,
															)
														} else {
															decryptedText =
																await MessageEncryption.decryptMessage(
																	lastMessage.text,
																	userPassword,
																)
														}
													} else {
														decryptedText = 'Зашифрованное сообщение'
													}
												} catch (decryptError) {
													console.error('Ошибка дешифрования:', decryptError)
													decryptedText = 'Зашифрованное сообщение'
												}
											} else {
												decryptedText = lastMessage.text || '[Сообщение]'
											}
										}
										const lastMessageForCard = lastMessage
											? {
													...lastMessage,
													text: decryptedText,
													is_decrypted: true,
												}
											: null
										return {
											user_id: friendId,
											nickname: friend.nickname,
											isFriend: true,
											lastMessage: lastMessageForCard,
										}
									}
								} catch (error) {
									console.error('Ошибка загрузки друга:', friendId, error)
									return null
								}
							})
							const friendsData = await Promise.all(friendPromises)
							friendsData.forEach(friendData => {
								if (friendData) {
									const friendCard = createUserCard(friendData)
									container.appendChild(friendCard)
								}
							})
							updateOnlineStatusInContacts()
						} else {
							const noFriends = document.createElement('div')
							noFriends.className = 'no-friends'
							noFriends.textContent =
								'У вас пока нет друзей. Найдите их через поиск!'
							container.appendChild(noFriends)
						}
					} catch (error) {
						console.error('Error loading friends:', error)
					}
				}

				function createUserCard(userData) {
					const card = document.createElement('div')
					card.className =
						'user-bar' + (userData.isCurrentUser ? ' current-user' : '')
					card.dataset.userId = userData.user_id

					const avatar = document.createElement('div')
					avatar.className = 'avatar-medium'
					if (userData.isSelfChat) {
						avatar.style.backgroundImage =
							'url(https://cdn-icons-png.flaticon.com/512/1077/1077114.png)'
						avatar.style.backgroundColor = '#4CAF50'
					} else {
						avatar.style.backgroundImage =
							'url(https://cdn-icons-png.flaticon.com/512/3135/3135715.png)'
					}

					const contentWrapper = document.createElement('div')
					contentWrapper.className = 'user-content-wrapper'

					const username = document.createElement('div')
					username.className = 'username'
					if (userData.isSelfChat) {
						username.textContent = 'Избранное'
						username.style.fontWeight = 'bold'
						username.style.color = '#4CAF50'
					} else if (userData.isCurrentUser) {
						username.textContent = 'Вы'
					} else {
						username.textContent = userData.nickname
					}
					contentWrapper.appendChild(username)

					if (
						userData.lastMessage &&
						!userData.isCurrentUser &&
						!userData.isSelfChat
					) {
						const lastMsgDiv = document.createElement('div')
						lastMsgDiv.className = 'last-message'
						let messageText = userData.lastMessage.text || '[Сообщение]'
						if (messageText.length > 25)
							messageText = messageText.substring(0, 22) + '...'
						if (
							userData.lastMessage.sender_id === localStorage.getItem('user_id')
						) {
							lastMsgDiv.innerHTML = `<span class="you-indicator">Вы:</span> ${messageText}`
						} else {
							lastMsgDiv.textContent = messageText
						}
						contentWrapper.appendChild(lastMsgDiv)
					}

					card.appendChild(avatar)
					card.appendChild(contentWrapper)

					card.addEventListener('click', function (e) {
						e.stopPropagation()
						const userId = userData.user_id
						if (
							currentChatUserId === userId &&
							!document
								.getElementById('chat-container')
								.classList.contains('hidden')
						) {
							updateUserStatus()
							return
						}
						openChat(userId)
						document
							.querySelectorAll('.user-bar')
							.forEach(el => el.classList.remove('active-chat'))
						card.classList.add('active-chat')
					})

					if (!userData.isSelfChat && !userData.isCurrentUser) {
						card.addEventListener('contextmenu', function (e) {
							e.preventDefault()
							showContextMenu(e, userData)
						})
					}
					return card
				}

				function showContextMenu(e, userData) {
					closeContextMenu()
					contextMenuTarget = userData.user_id
					const addBtn = document.getElementById('context-menu-add')
					const removeBtn = document.getElementById('context-menu-remove')
					if (currentUser.friends.includes(userData.user_id)) {
						addBtn.classList.add('hidden')
						removeBtn.classList.remove('hidden')
					} else {
						addBtn.classList.remove('hidden')
						removeBtn.classList.add('hidden')
					}
					contextMenu.style.display = 'block'
					contextMenu.style.left = `${e.pageX}px`
					contextMenu.style.top = `${e.pageY}px`
				}

				function closeContextMenu() {
					if (contextMenu) contextMenu.style.display = 'none'
					contextMenuTarget = null
				}

				async function handleAddFriend() {
					if (!contextMenuTarget) return
					const user_id = localStorage.getItem('user_id')
					try {
						const response = await eel.add_friend(user_id, contextMenuTarget)()
						if (response.success) await loadFriends()
						alert(response.message)
					} catch (error) {
						alert('Ошибка при добавлении в друзья')
						console.error('Error adding friend:', error)
					}
					closeContextMenu()
				}

				async function handleRemoveFriend() {
					if (!contextMenuTarget) return
					const user_id = localStorage.getItem('user_id')
					try {
						const response = await eel.remove_friend(
							user_id,
							contextMenuTarget,
						)()
						if (response.success) {
							await loadFriends()
							if (currentChatUserId === contextMenuTarget) closeChat()
						}
						alert(response.message)
					} catch (error) {
						alert('Ошибка при удалении из друзей')
						console.error('Error removing friend:', error)
					}
					closeContextMenu()
				}

				async function displaySearchResults(users) {
					const container = document.getElementById('user-container')
					container.innerHTML = ''
					if (users.length === 0) {
						const noResults = document.createElement('div')
						noResults.className = 'no-results'
						noResults.textContent = 'Ничего не найдено'
						container.appendChild(noResults)
						return
					}
					const user_id = localStorage.getItem('user_id')
					for (const user of users) {
						const isFriend = currentUser.friends.includes(user.user_id)
						const lastMessage = await eel.get_last_message(
							user_id,
							user.user_id,
						)()
						if (lastMessage && lastMessage.is_encrypted) {
							try {
								const userPassword = sessionStorage.getItem('user_password')
								if (userPassword) {
									const chatHistory = await eel.get_encrypted_chat_history(
										user_id,
										user.user_id,
									)()
									if (
										chatHistory.success &&
										chatHistory.messages &&
										chatHistory.messages.length > 0
									) {
										const lastMsg =
											chatHistory.messages[chatHistory.messages.length - 1]
										if (lastMsg.is_encrypted && lastMsg.text) {
											lastMessage.text = await MessageEncryption.decryptMessage(
												lastMsg.text,
												userPassword,
											)
										}
									}
								}
							} catch (error) {
								console.error('Ошибка дешифрования при поиске:', error)
							}
						}
						const userCard = createUserCard({
							user_id: user.user_id,
							nickname: user.nickname,
							isFriend: isFriend,
							lastMessage: lastMessage,
						})
						container.appendChild(userCard)
					}
					updateOnlineStatusInContacts()
				}

				function formatMessageTime(timestamp) {
					try {
						if (!timestamp) return '--:--'
						if (/^\d{2}:\d{2}$/.test(timestamp)) return timestamp
						let date
						try {
							if (timestamp.includes('Z') || timestamp.includes('+')) {
								date = new Date(timestamp)
							} else {
								date = new Date(timestamp + 'Z')
							}
						} catch (e) {
							date = new Date(timestamp)
						}
						if (isNaN(date.getTime())) {
							console.warn('Неверный формат времени:', timestamp)
							return '--:--'
						}
						return date.toLocaleTimeString('ru-RU', {
							hour: '2-digit',
							minute: '2-digit',
							hour12: false,
							timeZone: 'Europe/Moscow',
						})
					} catch (error) {
						console.error(
							'Ошибка форматирования времени:',
							error,
							'timestamp:',
							timestamp,
						)
						return '--:--'
					}
				}

				function formatDateForDisplay(dateString) {
					try {
						const date = new Date(dateString)
						if (isNaN(date.getTime())) return dateString
						const now = new Date()
						const today = new Date(
							now.getFullYear(),
							now.getMonth(),
							now.getDate(),
						)
						const messageDate = new Date(
							date.getFullYear(),
							date.getMonth(),
							date.getDate(),
						)
						const diffDays = Math.floor(
							(today - messageDate) / (1000 * 60 * 60 * 24),
						)
						if (diffDays === 0) return 'Сегодня'
						if (diffDays === 1) return 'Вчера'
						if (diffDays < 7) {
							const days = [
								'Воскресенье',
								'Понедельник',
								'Вторник',
								'Среда',
								'Четверг',
								'Пятница',
								'Суббота',
							]
							return days[date.getDay()]
						}
						const months = [
							'янв',
							'фев',
							'мар',
							'апр',
							'мая',
							'июн',
							'июл',
							'авг',
							'сен',
							'окт',
							'ноя',
							'дек',
						]
						return `${date.getDate()} ${months[date.getMonth()]} ${date.getFullYear()}`
					} catch (error) {
						console.error('Ошибка форматирования даты:', error)
						return dateString
					}
				}

				function formatTimeAgo(date) {
					const now = new Date()
					const diff = Math.floor((now - date) / 1000)
					if (diff < 60) return 'только что'
					if (diff < 3600) return `${Math.floor(diff / 60)} мин. назад`
					if (diff < 86400) return `${Math.floor(diff / 3600)} ч. назад`
					const days = Math.floor(diff / 86400)
					if (days === 1) return 'вчера'
					if (days < 7) return `${days} дн. назад`
					return date.toLocaleDateString('ru-RU', {
						day: 'numeric',
						month: 'long',
						year: 'numeric',
					})
				}

				function formatMessageDate(timestamp) {
					const messageDate = new Date(timestamp)
					const today = new Date()
					const yesterday = new Date(today)
					yesterday.setDate(yesterday.getDate() - 1)
					const twoDaysAgo = new Date(today)
					twoDaysAgo.setDate(twoDaysAgo.getDate() - 2)
					const messageDateOnly = new Date(
						messageDate.getFullYear(),
						messageDate.getMonth(),
						messageDate.getDate(),
					)
					const todayOnly = new Date(
						today.getFullYear(),
						today.getMonth(),
						today.getDate(),
					)
					const yesterdayOnly = new Date(
						yesterday.getFullYear(),
						yesterday.getMonth(),
						yesterday.getDate(),
					)
					const twoDaysAgoOnly = new Date(
						twoDaysAgo.getFullYear(),
						twoDaysAgo.getMonth(),
						twoDaysAgo.getDate(),
					)
					if (messageDateOnly.getTime() === todayOnly.getTime())
						return 'Сегодня'
					if (messageDateOnly.getTime() === yesterdayOnly.getTime())
						return 'Вчера'
					if (messageDateOnly.getTime() === twoDaysAgoOnly.getTime())
						return 'Позавчера'
					const startOfWeek = new Date(today)
					startOfWeek.setDate(today.getDate() - today.getDay())
					startOfWeek.setHours(0, 0, 0, 0)
					if (messageDate >= startOfWeek) {
						const days = [
							'Воскресенье',
							'Понедельник',
							'Вторник',
							'Среда',
							'Четверг',
							'Пятница',
							'Суббота',
						]
						return days[messageDate.getDay()]
					} else {
						const months = [
							'января',
							'февраля',
							'марта',
							'апреля',
							'мая',
							'июня',
							'июля',
							'августа',
							'сентября',
							'октября',
							'ноября',
							'декабря',
						]
						return `${messageDate.getDate()} ${months[messageDate.getMonth()]} ${messageDate.getFullYear()}`
					}
				}

				function createDateHeader(dateText, dateKey) {
					const dateHeader = document.createElement('div')
					dateHeader.className = 'date-header'
					dateHeader.dataset.dateKey = dateKey
					const dateContent = document.createElement('div')
					dateContent.className = 'date-header-content'
					dateContent.textContent = dateText
					dateHeader.appendChild(dateContent)
					return dateHeader
				}

				function addDateHeaderToMessage(messageElement, timestamp) {
					const dateKey = new Date(timestamp).toDateString()
					const dateText = formatMessageDate(timestamp)
					if (dateHeaders.has(dateKey)) return
					const dateHeader = createDateHeader(dateText, dateKey)
					dateHeaders.set(dateKey, dateHeader)
					const messagesContainer = document.getElementById('chat-messages')
					messagesContainer.insertBefore(dateHeader, messageElement)
				}

				function updateStickyDateHeaders() {
					const messagesWrapper = document.getElementById(
						'chat-messages-wrapper',
					)
					if (!messagesWrapper) return
					const scrollTop = messagesWrapper.scrollTop
					const dateHeaderElements = Array.from(
						document.querySelectorAll('.date-header'),
					)
					let newStickyDate = null
					for (let i = dateHeaderElements.length - 1; i >= 0; i--) {
						const header = dateHeaderElements[i]
						const rect = header.getBoundingClientRect()
						const messagesWrapperRect = messagesWrapper.getBoundingClientRect()
						if (
							rect.top <= messagesWrapperRect.top + 60 &&
							rect.bottom > messagesWrapperRect.top
						) {
							newStickyDate = header
							break
						}
					}
					if (!newStickyDate && dateHeaderElements.length > 0)
						newStickyDate = dateHeaderElements[0]
					dateHeaderElements.forEach(header =>
						header.classList.remove('sticky'),
					)
					if (newStickyDate && newStickyDate !== currentStickyDate) {
						newStickyDate.classList.add('sticky')
						currentStickyDate = newStickyDate
					} else if (!newStickyDate) currentStickyDate = null
				}

				function initDateHeadersSystem() {
					const messagesWrapper = document.getElementById(
						'chat-messages-wrapper',
					)
					if (!messagesWrapper) return
					messagesWrapper.addEventListener('scroll', updateStickyDateHeaders)
					dateHeadersObserver = new IntersectionObserver(
						entries => {
							entries.forEach(entry => {
								if (
									entry.isIntersecting &&
									entry.target.classList.contains('sticky')
								) {
									entry.target.classList.remove('sticky')
								}
							})
						},
						{ root: messagesWrapper, threshold: 1.0 },
					)
					document
						.querySelectorAll('.date-header')
						.forEach(header => dateHeadersObserver.observe(header))
				}

				function escapeHtml(unsafe) {
					if (!unsafe) return ''
					return unsafe
						.replace(/&/g, '&amp;')
						.replace(/</g, '&lt;')
						.replace(/>/g, '&gt;')
						.replace(/"/g, '&quot;')
						.replace(/'/g, '&#039;')
				}
				function initCustomScroll() {
					const messagesWrapper = document.getElementById(
						'chat-messages-wrapper',
					)
					const scrollbar = document.getElementById('custom-scrollbar')
					const scrollThumb = document.getElementById('custom-scrollbar-thumb')
					if (!messagesWrapper || !scrollbar || !scrollThumb) return

					let isDraggingScroll = false
					let scrollDragStartY = 0
					let scrollThumbStartY = 0

					function updateScrollThumb() {
						const { scrollHeight, clientHeight, scrollTop } = messagesWrapper
						if (scrollHeight <= clientHeight) {
							scrollbar.style.display = 'none'
							return
						}
						scrollbar.style.display = 'block'
						const thumbHeight = Math.max(
							20,
							(clientHeight / scrollHeight) * clientHeight,
						)
						const thumbPosition =
							(scrollTop / (scrollHeight - clientHeight)) *
							(clientHeight - thumbHeight)
						scrollThumb.style.height = `${thumbHeight}px`
						scrollThumb.style.top = `${thumbPosition}px`
					}

					scrollThumb.addEventListener('mousedown', e => {
						isDraggingScroll = true
						scrollThumb.classList.add('dragging')
						scrollDragStartY = e.clientY
						scrollThumbStartY = parseInt(scrollThumb.style.top || '0')
						e.preventDefault()

						function handleScrollMove(e) {
							if (!isDraggingScroll) return
							const deltaY = e.clientY - scrollDragStartY
							let newThumbPosition = scrollThumbStartY + deltaY
							const maxPosition =
								messagesWrapper.clientHeight - scrollThumb.offsetHeight
							newThumbPosition = Math.max(
								0,
								Math.min(maxPosition, newThumbPosition),
							)
							scrollThumb.style.top = `${newThumbPosition}px`
							const scrollRatio = newThumbPosition / maxPosition
							messagesWrapper.scrollTop =
								scrollRatio *
								(messagesWrapper.scrollHeight - messagesWrapper.clientHeight)
						}
						function handleScrollEnd() {
							isDraggingScroll = false
							scrollThumb.classList.remove('dragging')
							document.removeEventListener('mousemove', handleScrollMove)
							document.removeEventListener('mouseup', handleScrollEnd)
						}
						document.addEventListener('mousemove', handleScrollMove)
						document.addEventListener('mouseup', handleScrollEnd)
					})

					scrollbar.addEventListener('click', e => {
						if (e.target === scrollbar) {
							const rect = scrollbar.getBoundingClientRect()
							const clickPosition = e.clientY - rect.top
							const thumbHeight = scrollThumb.offsetHeight
							let newThumbPosition = clickPosition - thumbHeight / 2
							newThumbPosition = Math.max(
								0,
								Math.min(rect.height - thumbHeight, newThumbPosition),
							)
							scrollThumb.style.top = `${newThumbPosition}px`
							const scrollRatio = newThumbPosition / (rect.height - thumbHeight)
							messagesWrapper.scrollTop =
								scrollRatio *
								(messagesWrapper.scrollHeight - messagesWrapper.clientHeight)
						}
					})

					messagesWrapper.addEventListener('scroll', updateScrollThumb)
					window.addEventListener('resize', updateScrollThumb)
					new MutationObserver(updateScrollThumb).observe(messagesWrapper, {
						childList: true,
						subtree: true,
					})
					updateScrollThumb()
				}
				function initImageModal() {
					const imageModalOverlay = document.getElementById(
						'image-modal-overlay',
					)
					const imageModalImg = document.getElementById('image-modal-img')
					const imageModalClose = document.getElementById('image-modal-close')
					if (!imageModalOverlay || !imageModalImg || !imageModalClose) {
						console.error('Image modal elements not found')
						return
					}
					window.openImageModal = function (imageSrc) {
						imageModalImg.src = imageSrc
						imageModalOverlay.classList.remove('hidden')
						document.body.style.overflow = 'hidden'
					}
					window.closeImageModal = function () {
						imageModalOverlay.classList.add('hidden')
						imageModalImg.src = ''
						document.body.style.overflow = ''
					}
					imageModalClose.addEventListener('click', closeImageModal)
					imageModalOverlay.addEventListener('click', function (e) {
						if (e.target === imageModalOverlay) closeImageModal()
					})
					document.addEventListener('keydown', function (e) {
						if (
							e.key === 'Escape' &&
							!imageModalOverlay.classList.contains('hidden')
						) {
							closeImageModal()
						}
					})
					console.log('Image modal initialized')
				}

				function closeImageModal() {
					window.closeImageModal()
				}
				async function getServerTime() {
					try {
						return await eel.get_current_time()()
					} catch (error) {
						console.error('Ошибка получения времени сервера:', error)
						return new Date().toISOString()
					}
				}
				async function getCurrentServerTime() {
					return getServerTime()
				}
				function startOnlineStatusUpdates() {
					updateOnlineStatus()
					onlineStatusInterval = setInterval(updateOnlineStatus, 30000)
					window.addEventListener('beforeunload', updateOnlineStatus)
				}
				async function updateOnlineStatus() {
					try {
						await eel.update_last_online(localStorage.getItem('user_id'))()
					} catch (error) {
						console.error('Ошибка обновления статуса онлайн:', error)
					}
				}
				function showEncryptionIndicator() {
					const chatHeader = document.querySelector('.chat-header')
					if (
						chatHeader &&
						!chatHeader.querySelector('.encryption-indicator')
					) {
						const indicator = document.createElement('div')
						indicator.className = 'encryption-indicator'
						indicator.innerHTML = 'Зашифровано ECDH-AES-GCM'
						indicator.style.color = '#4CAF50'
						indicator.style.fontSize = '12px'
						indicator.style.marginLeft = '10px'
						indicator.style.fontWeight = 'bold'
						chatHeader.appendChild(indicator)
					}
				}
				function hideEncryptionIndicator() {
					const indicator = document.querySelector('.encryption-indicator')
					if (indicator) indicator.remove()
				}
				function closeLogoutModal() {
					document.getElementById('logout-overlay').classList.add('hidden')
					document.getElementById('logout-modal').classList.add('hidden')
				}
				function stopVoiceMessage() {
					if (currentPlayingAudio) {
						currentPlayingAudio.pause()
						currentPlayingAudio = null
					}
					voiceMessagePlaying = false
					if (currentPlayingVoiceElement) {
						currentPlayingVoiceElement.classList.remove('playing')
						const playIcon =
							currentPlayingVoiceElement.querySelector('.voice-play-icon')
						if (playIcon) playIcon.textContent = '▶'
						currentPlayingVoiceElement = null
					}
				}
				function setupVoiceMessageHandlers() {}
				function updateListenIndicators() {
					return Promise.resolve()
				}
				function positionPhotoMenu() {
					const photoBtn = document.getElementById('photo-message-btn')
					const photoOptionsMenu = document.getElementById('photo-options-menu')
					if (!photoBtn || !photoOptionsMenu) return
					const rect = photoBtn.getBoundingClientRect()
					photoOptionsMenu.style.left = `${rect.left}px`
					photoOptionsMenu.style.bottom = `${window.innerHeight - rect.top + 10}px`
				}
				document.addEventListener('DOMContentLoaded', async function () {
					console.log('=== DOMContentLoaded начат ===')
					try {
						const serverTime = await getServerTime()
						console.log(
							'Время сервера:',
							serverTime,
							'Локальное время:',
							new Date().toISOString(),
						)
					} catch (error) {
						console.warn('Не удалось синхронизировать время с сервером:', error)
					}
					if (window.appInitialized) {
						console.log('Приложение уже инициализировано')
						return
					}
					window.appInitialized = true

					const user_id = localStorage.getItem('user_id')
					console.log('User ID из localStorage:', user_id)
					if (!user_id) {
						console.log('User ID не найден, перенаправляем на login')
						window.location.href = 'login.html'
						return
					}

					try {
						console.log('Загружаем данные пользователя...')
						currentUser = await eel.get_user_data(user_id)()
						console.log('Данные пользователя загружены:', currentUser)
						if (!currentUser) {
							console.error('Пользователь не найден в базе данных')
							localStorage.removeItem('user_id')
							sessionStorage.removeItem('user_password')
							window.location.href = 'login.html'
							return
						}

						console.log('Инициализируем систему шифрования...')
						const userPassword = sessionStorage.getItem('user_password')
						if (!userPassword) {
							console.error(
								'Пароль не найден в sessionStorage. Перенаправляем на вход.',
							)
							localStorage.removeItem('user_id')
							window.location.href = 'login.html'
							return
						}
						try {
							const encryptionInit = await eel.initialize_user_encryption(
								user_id,
								userPassword,
							)()
							if (encryptionInit.success) {
								console.log('Система шифрования инициализирована')
							} else {
								console.warn(
									'Не удалось инициализировать шифрование:',
									encryptionInit.message,
								)
							}
						} catch (encryptionError) {
							console.warn(
								'Ошибка при инициализации шифрования:',
								encryptionError,
							)
						}

						console.log('Инициализация UI компонентов...')
						initCustomScroll()
						initImageModal()
						window.messageElements = window.messageElements || new Map()

						document.getElementById('top-avatar').style.backgroundImage =
							'url(https://cdn-icons-png.flaticon.com/512/3135/3135715.png)'

						const searchInput = document.querySelector('.search-input')
						const clearBtn = document.querySelector('.clear-btn')
						if (searchInput && clearBtn) {
							searchInput.addEventListener('input', async function () {
								const searchTerm = this.value.trim()
								if (searchTerm.length > 0) {
									const users = await eel.search_users(searchTerm, user_id)()
									displaySearchResults(users)
								} else {
									await loadFriends()
								}
							})
							clearBtn.addEventListener('click', function () {
								searchInput.value = ''
								searchInput.focus()
								loadFriends()
							})
						}

						contextMenu = document.getElementById('context-menu')
						if (contextMenu) {
							document.addEventListener('click', closeContextMenu)
							document
								.getElementById('context-menu-add')
								.addEventListener('click', handleAddFriend)
							document
								.getElementById('context-menu-remove')
								.addEventListener('click', handleRemoveFriend)
						}

						const menuIcon = document.querySelector('.menu-icon')
						if (menuIcon) {
							menuIcon.addEventListener('click', function () {
								document
									.getElementById('logout-overlay')
									.classList.remove('hidden')
								document
									.getElementById('logout-modal')
									.classList.remove('hidden')
							})
						}

						document
							.getElementById('logout-close-btn')
							?.addEventListener('click', closeLogoutModal)
						document
							.getElementById('logout-cancel-btn')
							?.addEventListener('click', closeLogoutModal)
						document
							.getElementById('logout-overlay')
							?.addEventListener('click', closeLogoutModal)
						document
							.getElementById('logout-confirm-btn')
							?.addEventListener('click', function () {
								localStorage.removeItem('user_id')
								sessionStorage.removeItem('user_password')
								localStorage.removeItem('user_salt')
								window.location.href = 'login.html'
							})

						startOnlineStatusUpdates()
						console.log('Загружаем список друзей...')
						await loadFriends()
						console.log('Начинаем дешифрование всех последних сообщений...')
						setTimeout(async () => {
							await loadAllLastMessages()
						}, 1000)
						initMessageContextMenu()
						initButtonHandlers()

						console.log('=== Приложение инициализировано успешно ===')
						console.log('Система шифрования готова к работе')
					} catch (error) {
						console.error('Ошибка инициализации приложения:', error)
						alert(
							'Ошибка инициализации приложения: ' +
								error.message +
								'\nПопробуйте перезагрузить страницу.',
						)
					}

					window.addEventListener('beforeunload', function () {
						stopMessagePolling()
						stopReadStatusPolling()
					})
					if (currentChatUserId) {
						startMessagePolling(currentChatUserId)
						startReadStatusPolling()
					}
				})

				function initButtonHandlers() {
					const messageInput = document.getElementById('message-input')
					const menuIcon = document.querySelector('.menu-icon')
					if (menuIcon) {
						menuIcon.addEventListener('click', function () {
							document
								.getElementById('logout-overlay')
								.classList.remove('hidden')
							document.getElementById('logout-modal').classList.remove('hidden')
						})
					}
					console.log('Button handlers initialized')
				}
				document.addEventListener('keydown', function (e) {
					if (e.key === 'Escape') {
						if (
							!document
								.getElementById('image-modal-overlay')
								.classList.contains('hidden')
						) {
							closeImageModal()
							return
						}
						if (
							!document
								.getElementById('delete-message-modal')
								.classList.contains('hidden')
						) {
							document
								.getElementById('delete-message-overlay')
								.classList.add('hidden')
							document
								.getElementById('delete-message-modal')
								.classList.add('hidden')
							return
						}
						if (
							!document
								.getElementById('logout-modal')
								.classList.contains('hidden')
						) {
							closeLogoutModal()
							return
						}
						if (
							!document
								.getElementById('chat-container')
								.classList.contains('hidden')
						) {
							closeChatAndReset()
						}
					}
				})

				document
					.getElementById('message-input')
					.addEventListener('keypress', async function (e) {
						if (e.key === 'Enter' && this.value.trim()) {
							const text = this.value.trim()
							if (!text || this.disabled) return
							this.disabled = true
							try {
								const sent = await sendEcdhMessage(text)
								if (!sent) {
									alert('Шифрование недоступно, отправляется обычное сообщение')
								}
							} catch (error) {
								console.error('Error sending message:', error)
								alert('Ошибка отправки сообщения: ' + error.message)
							} finally {
								this.disabled = false
							}
						}
					})
				const photoBtn = document.getElementById('photo-message-btn')
				const photoOptionsMenu = document.getElementById('photo-options-menu')
				const fileInput = document.getElementById('file-input')
				let photoMenuTimeout

				if (photoBtn && photoOptionsMenu) {
					photoBtn.addEventListener('mouseenter', () => {
						clearTimeout(photoMenuTimeout)
						positionPhotoMenu()
						photoOptionsMenu.classList.remove('hidden')
						photoOptionsMenu.classList.add('show')
					})
					photoBtn.addEventListener('mouseleave', () => {
						photoMenuTimeout = setTimeout(() => {
							photoOptionsMenu.classList.remove('show')
						}, 200)
					})
					photoOptionsMenu.addEventListener('mouseenter', () => {
						clearTimeout(photoMenuTimeout)
					})
					photoOptionsMenu.addEventListener('mouseleave', () => {
						photoOptionsMenu.classList.remove('show')
					})
					document.querySelectorAll('.photo-option').forEach(option => {
						option.addEventListener('click', function () {
							const type = this.dataset.type
							if (type === 'photo-video') {
								fileInput.click()
							} else {
								alert(
									`Выбрана опция: ${this.querySelector('span').textContent}`,
								)
							}
							photoOptionsMenu.classList.remove('show')
						})
					})
					window.addEventListener('resize', positionPhotoMenu)
				}
				eel.expose(get_current_user_id)
				eel.expose(notify_message_deleted)
			})()
		</script>
	</body>
</html>
