<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Мессенджер</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>

<!-- Модальное окно отправки медиа -->
<div class="media-send-overlay hidden" id="media-send-overlay"></div>
<div class="media-send-modal hidden" id="media-send-modal">
    <div class="media-send-title" id="media-send-title">Отправить медиа</div>
    
    <!-- Контейнер для превью множества файлов -->
    <div class="media-preview-grid" id="media-preview-grid">
        <!-- Превью будут добавляться динамически -->
    </div>
    
    <input type="text" class="media-caption-input" id="media-caption-input" placeholder="Введите текст">
    
    <div class="media-send-buttons">
        <button class="media-send-button add" id="media-add-button">Добавить</button>
        <button class="media-send-button cancel" id="media-cancel-button">Отмена</button>
        <button class="media-send-button send" id="media-send-button">Отправить все</button>
    </div>
</div>

<!-- Модальное окно для полноэкранного просмотра изображений -->
<div class="image-modal-overlay hidden" id="image-modal-overlay">
    <div class="image-modal-content">
        <button class="image-modal-close" id="image-modal-close">×</button>
        <img src="" alt="Full screen image" class="image-modal-img" id="image-modal-img">
    </div>
</div>

    <!-- Скрытый input для выбора файлов -->
<input type="file" id="file-input" class="file-input" accept="image/*,video/*" onchange="handleFileSelect(event)">

    <div class="top-container">
        <div class="top-row">
            <div class="menu-icon">☰</div>
            <div class="avatar-small" id="top-avatar"></div>
            <div class="search-container">
                <input type="text" class="search-input" placeholder="поиск">
                <span class="clear-btn">×</span>
            </div>
        </div>
        
        <div class="user-container" id="user-container"></div>
    </div>
    
    <div class="right-container">
        <div class="default-content" id="default-content">
            <img src="https://cdn-icons-png.flaticon.com/512/5757/5757765.png" alt="Выберите чат" class="default-image">
        </div>
        
<div class="chat-container hidden" id="chat-container">
    <div class="chat-header">
        <div class="chat-username" id="chat-username"></div>
        <div class="chat-header-info">
            <div class="chat-status" id="chat-status"></div>
        </div>
    </div>
<div class="chat-scroll-container">
    <div class="chat-messages-wrapper" id="chat-messages-wrapper">
        <div class="chat-messages" id="chat-messages">
            <!-- Заголовки дат и сообщения будут добавляться сюда -->
        </div>
    </div>
    <div class="custom-scrollbar" id="custom-scrollbar">
        <div class="custom-scrollbar-thumb" id="custom-scrollbar-thumb"></div>
    </div>
</div>
    <div class="message-input-container">
        <div class="reply-container hidden" id="reply-container"></div>
        <div class="input-row">
    <button class="photo-message-btn" id="photo-message-btn">
        <img src="https://cdn-icons-png.flaticon.com/512/266/266074.png" alt="Фото">
    </button>
    <div class="message-input-wrapper">
        <input type="text" class="message-input" placeholder="Напишите сообщение..." id="message-input">
        <div class="recording-container hidden" id="recording-container">
            Запись: <span id="recording-time">0</span> сек.
        </div>
    </div>
    <button class="voice-message-btn" id="voice-message-btn">
        <img src="https://images.icon-icons.com/2066/PNG/512/mic_icon_125214.png" alt="Запись">
    </button>
</div>
    </div>
</div>

<!-- Всплывающее меню для кнопки фото -->
<div class="photo-options-menu hidden" id="photo-options-menu">
    <button class="photo-option" data-type="photo-video">
        <img src="https://cdn-icons-png.flaticon.com/512/266/266074.png" alt="Фото/Видео">
        <span>Фото и видео</span>
    </button>
    <button class="photo-option" data-type="documents">
        <img src="https://cdn-icons-png.flaticon.com/512/2991/2991112.png" alt="Документы">
        <span>Документы</span>
    </button>
    <button class="photo-option" data-type="poll">
        <img src="https://cdn-icons-png.flaticon.com/512/3034/3034626.png" alt="Опрос">
        <span>Создать опрос</span>
    </button>
    <button class="photo-option" data-type="location">
        <img src="https://cdn-icons-png.flaticon.com/512/535/535137.png" alt="Геолокация">
        <span>Геолокация</span>
    </button>
</div>


<!-- Add this to your HTML -->
<div class="video-message-container hidden" id="video-loading-overlay">
    <div class="video-loading-content">
        <div class="video-loading-spinner"></div>
        <div class="video-loading-text">Загрузка видео...</div>
        <div class="video-loading-progress">0 MB / 0 MB</div>
        <button class="video-loading-cancel">Отмена</button>
    </div>
</div>




    <!-- Контекстное меню -->
    <div class="context-menu" id="context-menu">
        <div class="context-menu-item add-friend hidden" id="context-menu-add">Добавить в друзья</div>
        <div class="context-menu-item remove-friend hidden" id="context-menu-remove">Удалить из друзей</div>
    </div>

    <!-- Модальное окно выхода -->
    <div class="modal-overlay hidden" id="logout-overlay"></div>
    <div class="logout-modal hidden" id="logout-modal">
        <button class="modal-close-btn" id="logout-close-btn">×</button>
        <div class="logout-text">Выйти из аккаунта</div>
        <div class="logout-buttons">
            <button class="logout-button logout-cancel" id="logout-cancel-btn">Отмена</button>
            <button class="logout-button logout-confirm" id="logout-confirm-btn">Выйти</button>
        </div>
    </div>

<div class="message-context-menu hidden" id="message-context-menu">
    <div class="message-context-item" id="message-reply">Ответить</div>
    <div class="message-context-item" id="message-edit">Изменить</div>
    <div class="message-context-item" id="message-pin">Закрепить</div>
    <div class="message-context-item" id="message-delete">Удалить</div>
    <div class="message-context-item" id="message-delete-for-me" style="display: none;">Удалить у меня</div>
    <div class="message-context-item" id="message-forward">Переслать</div>
    <div class="message-context-item" id="message-copy">Копировать</div>
</div>

    <script src="eel.js"></script>
    <script>
        let currentUser = null;
        let contextMenu = null;
        let contextMenuTarget = null;
        let currentChatUserId = null;
        let lastMessageId = null;
        let activeChats = {};
        let readStatusInterval = null;
        let statusUpdateInterval = null;
        let onlineStatusInterval = null;
        let mediaRecorder = null;
        let audioChunks = [];
        let recordingStartTime = 0;
        let audioContext = null;
        let analyser = null;
        let visualizationInterval = null;
        let currentPlayingAudio = null;
        let voiceMessagePlaying = false;
        let currentPlayingVoiceElement = null;
        let currentContextMessage = null; 
        let chatInputs = {};
        let scrollPositions = {};
    let isDraggingScroll = false;
    let scrollDragStartY = 0;
    let scrollThumbStartY = 0;
    let selectedFiles = [];
    const MAX_FILES = 16;
    
let dateHeaders = new Map();
let currentStickyDate = null;
let dateHeadersObserver = null;    

async function updateLastMessageAfterDelete(chatUserId) {
    try {
        const lastMessage = await eel.get_last_message(localStorage.getItem('user_id'), chatUserId)();
        const userCard = document.querySelector(`.user-bar[data-user-id="${chatUserId}"]`);
        
        if (!userCard) return;
        
        const lastMsgDiv = userCard.querySelector('.last-message');
        const contentWrapper = userCard.querySelector('.user-content-wrapper');
        
        if (lastMessage) {
            let displayText = lastMessage.text;
            if (displayText.length > 25) {
                displayText = displayText.substring(0, 22) + '...';
            }
            
            if (lastMessage.sender_id === localStorage.getItem('user_id')) {
                if (lastMsgDiv) {
                    lastMsgDiv.innerHTML = `<span class="you-indicator">Вы:</span> ${displayText}`;
                } else if (contentWrapper) {
                    const newLastMsgDiv = document.createElement('div');
                    newLastMsgDiv.className = 'last-message';
                    newLastMsgDiv.innerHTML = `<span class="you-indicator">Вы:</span> ${displayText}`;
                    contentWrapper.appendChild(newLastMsgDiv);
                }
            } else {
                if (lastMsgDiv) {
                    lastMsgDiv.textContent = displayText;
                } else if (contentWrapper) {
                    const newLastMsgDiv = document.createElement('div');
                    newLastMsgDiv.className = 'last-message';
                    newLastMsgDiv.textContent = displayText;
                    contentWrapper.appendChild(newLastMsgDiv);
                }
            }
        } else {
            // Если сообщений нет, удаляем блок last-message
            if (lastMsgDiv) {
                lastMsgDiv.remove();
            }
        }
    } catch (error) {
        console.error('Ошибка при обновлении последнего сообщения:', error);
    }
}


function initImageModal() {
    const imageModalOverlay = document.getElementById('image-modal-overlay');
    const imageModalClose = document.getElementById('image-modal-close');
    const imageModalImg = document.getElementById('image-modal-img');
    
    if (imageModalClose) {
        imageModalClose.addEventListener('click', closeImageModal);
    }
    
    if (imageModalOverlay) {
        imageModalOverlay.addEventListener('click', function(e) {
            if (e.target === imageModalOverlay) {
                closeImageModal();
            }
        });
    }
    
    // Обработчик ESC для модального окна изображения
    document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape' && !imageModalOverlay.classList.contains('hidden')) {
            closeImageModal();
        }
    });
}

function closeImageModal() {
    const imageModalOverlay = document.getElementById('image-modal-overlay');
    const imageModalImg = document.getElementById('image-modal-img');
    
    if (imageModalOverlay) {
        imageModalOverlay.classList.add('hidden');
    }
    if (imageModalImg) {
        imageModalImg.src = '';
    }
}

// Функция для открытия изображения в полноэкранном режиме
function openImageModal(imageSrc) {
    const imageModalOverlay = document.getElementById('image-modal-overlay');
    const imageModalImg = document.getElementById('image-modal-img');
    
    if (imageModalOverlay && imageModalImg) {
        imageModalImg.src = imageSrc;
        imageModalOverlay.classList.remove('hidden');
    }
}

// Также добавьте обработчик для кликов по изображениям в чате
document.addEventListener('click', function(e) {
    if (e.target.classList.contains('media-preview')) {
        openImageModal(e.target.src);
    }
});
class ZKEncryption {
    static async deriveKey(password, salt) {
        const encoder = new TextEncoder();
        const keyMaterial = await crypto.subtle.importKey(
            'raw',
            encoder.encode(password),
            'PBKDF2',
            false,
            ['deriveKey']
        );

        return await crypto.subtle.deriveKey(
            {
                name: 'PBKDF2',
                salt: salt,
                iterations: 100000,
                hash: 'SHA-256'
            },
            keyMaterial,
            { name: 'AES-GCM', length: 256 },
            false,
            ['encrypt', 'decrypt']
        );
    }

static async encryptText(text, key) {
    try {
        const encoder = new TextEncoder();
        const data = encoder.encode(text);
        
        const iv = crypto.getRandomValues(new Uint8Array(12));
        
        const encrypted = await crypto.subtle.encrypt(
            {
                name: 'AES-GCM',
                iv: iv
            },
            key,
            data
        );

        const combined = new Uint8Array(iv.length + encrypted.byteLength);
        combined.set(iv);
        combined.set(new Uint8Array(encrypted), iv.length);

        return this.arrayBufferToBase64(combined);
    } catch (error) {
        console.error('Error in encryptText:', error);
        throw error;
    }
}

    static async decryptText(encryptedData, key) {
        try {
            const combined = this.base64ToArrayBuffer(encryptedData);
            
            const iv = combined.slice(0, 12);
            const data = combined.slice(12);
            
            const decrypted = await crypto.subtle.decrypt(
                {
                    name: 'AES-GCM',
                    iv: iv
                },
                key,
                data
            );

            const decoder = new TextDecoder();
            return decoder.decode(decrypted);
        } catch (error) {
            console.error('Decryption error:', error);
            throw new Error('Failed to decrypt data');
        }
    }

    static async encryptFile(file, key) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            
            reader.onload = async (event) => {
                try {
                    const arrayBuffer = event.target.result;
                    
                    // Проверка размера файла
                    if (arrayBuffer.byteLength > 10 * 1024 * 1024) {
                        reject(new Error('File too large (max 10MB)'));
                        return;
                    }
                    
                    const iv = crypto.getRandomValues(new Uint8Array(12));
                    
                    const encrypted = await crypto.subtle.encrypt(
                        {
                            name: 'AES-GCM',
                            iv: iv
                        },
                        key,
                        arrayBuffer
                    );

                    const combined = new Uint8Array(iv.length + encrypted.byteLength);
                    combined.set(iv);
                    combined.set(new Uint8Array(encrypted), iv.length);
                    
                    const base64 = this.arrayBufferToBase64(combined);
                    resolve(base64);
                    
                } catch (error) {
                    console.error('Ошибка при шифровании файла:', error);
                    reject(error);
                }
            };
            
            reader.onerror = () => {
                reject(new Error('Failed to read file'));
            };
            
            reader.readAsArrayBuffer(file);
        });
    }

    static async decryptFile(encryptedData, key) {
        try {
            const combined = this.base64ToArrayBuffer(encryptedData);
            
            const iv = combined.slice(0, 12);
            const data = combined.slice(12);
            
            const decrypted = await crypto.subtle.decrypt(
                {
                    name: 'AES-GCM',
                    iv: iv
                },
                key,
                data
            );

            return decrypted;
        } catch (error) {
            console.error('Decryption error:', error);
            throw new Error('Failed to decrypt data');
        }
    }

    // Эффективные методы для конвертации base64
    static arrayBufferToBase64(buffer) {
        let binary = '';
        const bytes = new Uint8Array(buffer);
        const len = bytes.byteLength;
        for (let i = 0; i < len; i++) {
            binary += String.fromCharCode(bytes[i]);
        }
        return btoa(binary);
    }

    static base64ToArrayBuffer(base64) {
        const binaryString = atob(base64);
        const len = binaryString.length;
        const bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binaryString.charCodeAt(i);
        }
        return bytes;
    }
}



const zkCrypto = ZKEncryption;
let userEncryptionKey = null;



// Функции для отображения прогресса загрузки медиа
function showMediaUploadProgress(text, progress) {
    // Создаем или находим элемент для отображения прогресса
    let progressElement = document.getElementById('media-upload-progress');
    
    if (!progressElement) {
        progressElement = document.createElement('div');
        progressElement.id = 'media-upload-progress';
        progressElement.className = 'media-upload-progress';
        progressElement.innerHTML = `
            <div class="media-upload-progress-content">
                <div class="media-upload-progress-text">${text}</div>
                <div class="media-upload-progress-bar">
                    <div class="media-upload-progress-fill" style="width: ${progress}%"></div>
                </div>
                <div class="media-upload-progress-percent">${Math.round(progress)}%</div>
            </div>
        `;
        document.body.appendChild(progressElement);
    } else {
        progressElement.querySelector('.media-upload-progress-text').textContent = text;
        progressElement.querySelector('.media-upload-progress-fill').style.width = `${progress}%`;
        progressElement.querySelector('.media-upload-progress-percent').textContent = `${Math.round(progress)}%`;
    }
    
    progressElement.style.display = 'block';
}

function updateMediaUploadProgress(text, progress) {
    const progressElement = document.getElementById('media-upload-progress');
    if (progressElement) {
        progressElement.querySelector('.media-upload-progress-text').textContent = text;
        progressElement.querySelector('.media-upload-progress-fill').style.width = `${progress}%`;
        progressElement.querySelector('.media-upload-progress-percent').textContent = `${Math.round(progress)}%`;
    }
}

function hideMediaUploadProgress() {
    const progressElement = document.getElementById('media-upload-progress');
    if (progressElement) {
        progressElement.style.display = 'none';
        // Удаляем элемент через некоторое время
        setTimeout(() => {
            if (progressElement && progressElement.parentNode) {
                progressElement.parentNode.removeChild(progressElement);
            }
        }, 1000);
    }
}
  document.addEventListener('DOMContentLoaded', async function() {
        const user_id = localStorage.getItem('user_id');
        if (!user_id) {
            window.location.href = 'login.html';
            return;
        }

        // Инициализируем ZK систему
        const zkInitialized = await initializeZKSystem();
        if (!zkInitialized) {
            alert("Ошибка инициализации системы безопасности");
            return;
        }

        // Продолжаем остальную инициализацию...
        initCustomScroll();
        initImageModal();

    // Добавляем обработчик перед выгрузкой страницы
    window.addEventListener('beforeunload', function() {
        stopVoiceMessage();
        if (mediaRecorder && mediaRecorder.state !== 'inactive') {
            mediaRecorder.stop();
        }
    });

    // Запускаем отправку статуса онлайн
    startOnlineStatusUpdates();

    // Загружаем данные пользователя
    try {
        currentUser = await eel.get_user_data(user_id)();
        if (!currentUser) {
            localStorage.removeItem('user_id');
            window.location.href = 'login.html';
            return;
        }
    } catch (error) {
        localStorage.removeItem('user_id');
        window.location.href = 'login.html';
        return;
    }

    // Устанавливаем аватар текущего пользователя
    document.getElementById('top-avatar').style.backgroundImage = 'url(https://cdn-icons-png.flaticon.com/512/3135/3135715.png)';

    // Инициализация поиска
    const searchInput = document.querySelector('.search-input');
    const clearBtn = document.querySelector('.clear-btn');
    
    searchInput.addEventListener('input', async function() {
        const searchTerm = this.value.trim();
        if (searchTerm.length > 0) {
            const users = await eel.search_users(searchTerm, user_id)();
            displaySearchResults(users);
        } else {
            loadFriends();
        }
    });

    clearBtn.addEventListener('click', function() {
        searchInput.value = '';
        searchInput.focus();
        loadFriends();
    });

    // Инициализация контекстного меню
    contextMenu = document.getElementById('context-menu');
    document.addEventListener('click', closeContextMenu);
    document.getElementById('context-menu-add').addEventListener('click', handleAddFriend);
    document.getElementById('context-menu-remove').addEventListener('click', handleRemoveFriend);

    // Обработчики для меню выхода
    document.querySelector('.menu-icon').addEventListener('click', function() {
        document.getElementById('logout-overlay').classList.remove('hidden');
        document.getElementById('logout-modal').classList.remove('hidden');
    });

    document.getElementById('logout-close-btn').addEventListener('click', closeLogoutModal);
    document.getElementById('logout-cancel-btn').addEventListener('click', closeLogoutModal);
    document.getElementById('logout-overlay').addEventListener('click', closeLogoutModal);
document.getElementById('logout-confirm-btn').addEventListener('click', function() {
    // Очищаем ZK данные при выходе
    userEncryptionKey = null;
    localStorage.removeItem('zk_initialized');
    localStorage.removeItem('user_salt');
    sessionStorage.removeItem('user_password');
    localStorage.removeItem('user_id');
    
    eel.update_last_online(localStorage.getItem('user_id'))();
    window.location.href = 'login.html';
});
    // Обработчик нажатия ESC
    document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape') {
            // Если открыто модальное окно изображения - закрываем только его
            if (!document.getElementById('image-modal-overlay').classList.contains('hidden')) {
                closeImageModal();
                return;
            }
            
            // Если открыто модальное окно удаления - закрываем его
            if (!document.getElementById('delete-message-modal').classList.contains('hidden')) {
                document.getElementById('delete-message-overlay').classList.add('hidden');
                document.getElementById('delete-message-modal').classList.add('hidden');
                return;
            }
            
            // Если открыт чат - обрабатываем закрытие (оригинальная логика)
            if (!document.getElementById('chat-container').classList.contains('hidden')) {
                // Сбрасываем currentChatUserId только если это не чат с самим собой
                if (currentChatUserId !== localStorage.getItem('user_id')) {
                    currentChatUserId = null;
                }
                
                // Скрываем контейнер чата и показываем дефолтный экран
                document.getElementById('default-content').classList.remove('hidden');
                document.getElementById('chat-container').classList.add('hidden');
                
                // Убираем выделение активного чата
                document.querySelectorAll('.user-bar').forEach(el => {
                    el.classList.remove('active-chat');
                });
                
                // Останавливаем воспроизведение голосовых сообщений
                stopVoiceMessage();
                currentPlayingAudio = null;
                voiceMessagePlaying = false;
                currentPlayingVoiceElement = null;
                
                // Очищаем интервалы
                if (readStatusInterval) {
                    clearInterval(readStatusInterval);
                    readStatusInterval = null;
                }
                if (statusUpdateInterval) {
                    clearInterval(statusUpdateInterval);
                    statusUpdateInterval = null;
                }
                
                // Для чата с самим собой сохраняем возможность открыть его снова
                if (currentChatUserId === localStorage.getItem('user_id')) {
                    const selfChat = document.querySelector(`.user-bar[data-user-id="${currentChatUserId}"]`);
                    if (selfChat) {
                        selfChat.classList.add('active-chat');
                    }
                }
            }
        }
    });

    // Обработчик клика по карточке пользователя
    document.addEventListener('click', function(e) {
        let userBar = e.target.closest('.user-bar');
        if (userBar) {
            const userId = userBar.dataset.userId;
            openChat(userId);
            
            document.querySelectorAll('.user-bar').forEach(el => {
                el.classList.remove('active-chat');
            });
            userBar.classList.add('active-chat');
        }
    });
    
document.getElementById('message-input').addEventListener('keypress', async function(e) {
    if (e.key === 'Enter' && this.value.trim()) {
        if (userEncryptionKey) {
            await sendZKMessage(this.value.trim());
        } else {
            alert('Система безопасности не инициализирована');
        }
    }
});

    // Инициализация голосовых сообщений
    document.getElementById('voice-message-btn').addEventListener('mousedown', startRecording);
    document.getElementById('voice-message-btn').addEventListener('touchstart', startRecording);
    document.getElementById('voice-message-btn').addEventListener('mouseup', stopRecording);
    document.getElementById('voice-message-btn').addEventListener('touchend', stopRecording);
    document.getElementById('voice-message-btn').addEventListener('mouseleave', stopRecording);

    // Проверка новых сообщений каждые 2 секунды
    setInterval(checkForNewMessages, 2000);

    // Инициализация контекстного меню сообщений
    initMessageContextMenu();

    // Инициализация элементов для работы с медиа
    const mediaAddButton = document.getElementById('media-add-button');
    const mediaCancelButton = document.getElementById('media-cancel-button');
    const mediaSendButton = document.getElementById('media-send-button');
    const mediaSendOverlay = document.getElementById('media-send-overlay');
    const mediaSendModal = document.getElementById('media-send-modal');
    const mediaCaptionInput = document.getElementById('media-caption-input');
    const photoBtn = document.getElementById('photo-message-btn');

    // Обработчики для модального окна медиа
    if (mediaAddButton) {
        mediaAddButton.addEventListener('click', function() {
            if (selectedFiles.length >= MAX_FILES) {
                alert(`Максимальное количество файлов: ${MAX_FILES}`);
                return;
            }
            openFileSelector();
        });
    }

    if (mediaSendButton) {
        mediaSendButton.addEventListener('click', sendAllMedia);
    }

    if (mediaCancelButton) {
        mediaCancelButton.addEventListener('click', closeMediaModal);
    }

    if (mediaSendOverlay) {
        mediaSendOverlay.addEventListener('click', closeMediaModal);
    }

    // Обработчик для кнопки фото
    if (photoBtn) {
        photoBtn.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopPropagation();
            openFileSelector();
        });
    }

    // Обработчик для выбора файлов
    const fileInput = document.getElementById('file-input');
    if (fileInput) {
        fileInput.addEventListener('change', handleFileSelect);
    }

    // Первоначальная загрузка друзей
    await loadFriends();
});



function initCustomScroll() {
    const messagesWrapper = document.getElementById('chat-messages-wrapper');
    const scrollbar = document.getElementById('custom-scrollbar');
    const scrollThumb = document.getElementById('custom-scrollbar-thumb');
    const rightContainer = document.querySelector('.right-container');
    
    let isDraggingScroll = false;
    let scrollDragStartY = 0;
    let scrollThumbStartY = 0;

    // Функция обновления позиции и размера ползунка
    function updateScrollThumb() {
        if (!messagesWrapper) return;
        
        const { scrollHeight, clientHeight, scrollTop } = messagesWrapper;
        
        // Не показывать скроллбар если контент помещается
        if (scrollHeight <= clientHeight) {
            scrollbar.style.display = 'none';
            return;
        }
        
        scrollbar.style.display = 'block';
        const thumbHeight = Math.max(20, (clientHeight / scrollHeight) * clientHeight);
        const thumbPosition = (scrollTop / (scrollHeight - clientHeight)) * (clientHeight - thumbHeight);
        
        scrollThumb.style.height = `${thumbHeight}px`;
        scrollThumb.style.top = `${thumbPosition}px`;
    }
    
    // Обработчики для перетаскивания ползунка
    scrollThumb.addEventListener('mousedown', (e) => {
        isDraggingScroll = true;
        scrollThumb.classList.add('dragging'); // Добавляем класс при начале перетаскивания
        scrollDragStartY = e.clientY;
        scrollThumbStartY = parseInt(scrollThumb.style.top || '0');
        e.preventDefault();
        
        document.addEventListener('mousemove', handleScrollMove);
        document.addEventListener('mouseup', handleScrollEnd);
    });
    
    const handleScrollMove = (e) => {
        if (!isDraggingScroll) return;
        
        const deltaY = e.clientY - scrollDragStartY;
        let newThumbPosition = scrollThumbStartY + deltaY;
        
        // Ограничиваем позицию ползунка
        const maxPosition = messagesWrapper.clientHeight - scrollThumb.offsetHeight;
        newThumbPosition = Math.max(0, Math.min(maxPosition, newThumbPosition));
        
        // Обновляем позицию ползунка
        scrollThumb.style.top = `${newThumbPosition}px`;
        
        // Прокручиваем контент
        const scrollRatio = newThumbPosition / maxPosition;
        messagesWrapper.scrollTop = scrollRatio * (messagesWrapper.scrollHeight - messagesWrapper.clientHeight);
    };
    
    const handleScrollEnd = () => {
        isDraggingScroll = false;
        scrollThumb.classList.remove('dragging'); // Убираем класс при окончании перетаскивания
        document.removeEventListener('mousemove', handleScrollMove);
        document.removeEventListener('mouseup', handleScrollEnd);
    };
    
    // Прокрутка при клике на область скроллбара
    scrollbar.addEventListener('click', (e) => {
        if (e.target === scrollbar) {
            const rect = scrollbar.getBoundingClientRect();
            const clickPosition = e.clientY - rect.top;
            const thumbHeight = scrollThumb.offsetHeight;
            
            // Позиционируем ползунок по центру клика
            let newThumbPosition = clickPosition - thumbHeight / 2;
            newThumbPosition = Math.max(0, Math.min(rect.height - thumbHeight, newThumbPosition));
            scrollThumb.style.top = `${newThumbPosition}px`;
            
            // Прокручиваем контент
            const scrollRatio = newThumbPosition / (rect.height - thumbHeight);
            messagesWrapper.scrollTop = scrollRatio * (messagesWrapper.scrollHeight - messagesWrapper.clientHeight);
        }
    });
    
    // Обновляем ползунок при прокрутке колесом
    messagesWrapper.addEventListener('scroll', updateScrollThumb);
    
    // Инициализируем ползунок
    updateScrollThumb();
    
    // Обновляем ползунок при изменении размера окна
    window.addEventListener('resize', updateScrollThumb);
    
    // Обновляем ползунок при изменении содержимого
    const observer = new MutationObserver(updateScrollThumb);
    observer.observe(messagesWrapper, { childList: true, subtree: true });
}
        function startOnlineStatusUpdates() {
            updateOnlineStatus();
            onlineStatusInterval = setInterval(updateOnlineStatus, 30000);
            window.addEventListener('beforeunload', updateOnlineStatus);
        }

        async function updateOnlineStatus() {
            try {
                await eel.update_last_online(localStorage.getItem('user_id'))();
            } catch (error) {
                console.error('Ошибка обновления статуса онлайн:', error);
            }
        }

        function closeLogoutModal() {
            document.getElementById('logout-overlay').classList.add('hidden');
            document.getElementById('logout-modal').classList.add('hidden');
        }


        function closeChat(softClose = false) {
    document.getElementById('default-content').classList.remove('hidden');
    document.getElementById('chat-container').classList.add('hidden');
    document.querySelectorAll('.user-bar').forEach(el => {
        el.classList.remove('active-chat');
    });
    
    stopVoiceMessage();
    currentPlayingAudio = null;
    voiceMessagePlaying = false;
    currentPlayingVoiceElement = null;
    
    // Сбрасываем currentChatUserId только если это не softClose
    if (!softClose) {
        currentChatUserId = null;
    }
    
    lastMessageId = null;
    
    if (readStatusInterval) {
        clearInterval(readStatusInterval);
        readStatusInterval = null;
    }
    if (statusUpdateInterval) {
        clearInterval(statusUpdateInterval);
        statusUpdateInterval = null;
    }
}




// Add this to your script
function formatFileSize(bytes) {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat(bytes / Math.pow(k, i)).toFixed(2) + ' ' + sizes[i];
}

// Add this to your DOMContentLoaded event
document.addEventListener('click', function(e) {
    const videoLoadElement = e.target.closest('.video-loading');
    if (videoLoadElement) {
        const messageId = videoLoadElement.dataset.messageId;
        loadVideoMessage(messageId);
    }
});

async function loadVideoMessage(messageId) {
    try {
        const videoElement = document.querySelector(`.video-preview[data-message-id="${messageId}"]`);
        const loadingElement = document.querySelector(`.video-loading[data-message-id="${messageId}"]`);
        
        if (!videoElement || !loadingElement) return;
        
        // Показываем индикатор загрузки
        const loadingOverlay = document.createElement('div');
        loadingOverlay.className = 'video-loading-overlay';
        loadingOverlay.innerHTML = `
            <div class="video-loading-content">
                <div class="video-loading-spinner"></div>
                <div class="video-loading-text">Загрузка видео...</div>
                <div class="video-loading-progress">0%</div>
                <button class="video-loading-cancel">Отмена</button>
            </div>
        `;
        
        document.body.appendChild(loadingOverlay);
        
        // Получаем данные видео
        const response = await eel.get_media_message(messageId)();
        if (!response.success) {
            throw new Error(response.message || 'Failed to get video data');
        }
        
        // Устанавливаем источник видео
        videoElement.src = `data:video/mp4;base64,${response.media_data}`;
        
        // Скрываем элемент загрузки и показываем видео
        loadingElement.classList.add('hidden');
        videoElement.classList.remove('hidden');
        
        // Удаляем оверлей загрузки
        loadingOverlay.remove();
        
        // Помечаем как прочитанное, если это не мое сообщение
        if (!videoElement.closest('.my-message')) {
            await eel.mark_messages_as_read(
                videoElement.closest('.message').dataset.sender_id,
                localStorage.getItem('user_id')
            )();
        }
        
        // Обработчик отмены загрузки
        const cancelBtn = loadingOverlay.querySelector('.video-loading-cancel');
        if (cancelBtn) {
            cancelBtn.addEventListener('click', () => {
                loadingOverlay.remove();
            });
        }
    } catch (error) {
        console.error('Ошибка загрузки видео:', error);
        
        // Обновляем элемент загрузки с сообщением об ошибке
        const loadingElement = document.querySelector(`.video-loading[data-message-id="${messageId}"]`);
        if (loadingElement) {
            loadingElement.innerHTML = `
                <div class="video-load-error">Ошибка загрузки</div>
                <button class="video-retry-btn">Повторить</button>
            `;
            
            loadingElement.querySelector('.video-retry-btn').addEventListener('click', () => {
                loadVideoMessage(messageId);
            });
        }
        
        document.querySelector('.video-loading-overlay')?.remove();
    }
}



async function restoreUserKey() {
    try {
        const storedSalt = localStorage.getItem('user_salt');
        if (!storedSalt) {
            console.log('Соль не найдена в localStorage');
            return false;
        }
        
        // Получаем пароль из sessionStorage
        let userPassword = sessionStorage.getItem('user_password');
        if (!userPassword) {
            // Если пароля нет, запрашиваем его
            userPassword = prompt("Введите ваш пароль для расшифровки сообщений:");
            if (!userPassword) {
                return false;
            }
            // Сохраняем пароль в sessionStorage
            sessionStorage.setItem('user_password', userPassword);
        }
        
        // Правильная конвертация base64 в Uint8Array
        const saltBytes = Uint8Array.from(atob(storedSalt), c => c.charCodeAt(0));
        
        // Генерируем ключ
        userEncryptionKey = await zkCrypto.deriveKey(userPassword, saltBytes);
        
        // Тестируем ключ
        const testResult = await testEncryptionKey();
        if (!testResult) {
            throw new Error('Ключ не прошел проверку');
        }
        
        console.log('ZK система восстановлена успешно');
        return true;
        
    } catch (error) {
        console.error('Error restoring user key:', error);
        // При ошибке очищаем данные и запрашиваем пароль заново
        sessionStorage.removeItem('user_password');
        userEncryptionKey = null;
        return false;
    }
}







async function loadZKVideoMessage(messageId) {
    try {
        const videoElement = document.querySelector(`.video-preview[data-message-id="${messageId}"]`);
        const loadingElement = document.querySelector(`.video-loading[data-message-id="${messageId}"]`);
        
        if (!videoElement || !loadingElement) return;
        
        // Показываем индикатор загрузки
        loadingElement.innerHTML = '<div class="video-load-spinner">Загрузка...</div>';
        
        const response = await eel.get_media_message(messageId)();
        if (response.success && userEncryptionKey) {
            // Расшифровываем видео
            const decryptedData = await zkCrypto.decryptFile(response.encrypted_media_data, userEncryptionKey);
            const blob = new Blob([decryptedData], { type: 'video/mp4' });
            videoElement.src = URL.createObjectURL(blob);
            
            loadingElement.classList.add('hidden');
            videoElement.classList.remove('hidden');
        } else {
            throw new Error('Failed to load video');
        }
    } catch (error) {
        console.error('Ошибка загрузки ZK видео:', error);
        const loadingElement = document.querySelector(`.video-loading[data-message-id="${messageId}"]`);
        if (loadingElement) {
            loadingElement.innerHTML = `
                <div class="video-load-error">Ошибка загрузки</div>
                <button class="video-retry-btn">Повторить</button>
            `;
            
            loadingElement.querySelector('.video-retry-btn').addEventListener('click', () => {
                loadZKVideoMessage(messageId);
            });
        }
    }
}


async function checkAndRestoreReplyState() {
    if (!currentChatUserId) return;
    
    try {
        const replyState = await eel.get_reply_state(localStorage.getItem('user_id'), currentChatUserId)();
        if (replyState.success) {
            const message = await eel.get_message_data(replyState.message_id)();
            if (message) {
                const replyContainer = document.getElementById('reply-container');
                const isMyMessage = message.sender_id === localStorage.getItem('user_id');
                
                replyContainer.dataset.messageId = message.id;
                replyContainer.innerHTML = `
                    <div class="reply-header">
                        <div class="reply-author">${isMyMessage ? 'Вы' : document.getElementById('chat-username').textContent}</div>
                        <div class="reply-close">×</div>
                    </div>
                    <div class="reply-text">${message.text.length > 50 ? message.text.substring(0, 47) + '...' : message.text}</div>
                `;
                
                replyContainer.classList.remove('hidden');
                document.querySelector('.message-input-container').classList.add('expanded');
                
                // Обработчик закрытия ответа
                replyContainer.querySelector('.reply-close').addEventListener('click', async () => {
                    replyContainer.classList.add('hidden');
                    document.querySelector('.message-input-container').classList.remove('expanded');
                    await eel.clear_reply_state(localStorage.getItem('user_id'), currentChatUserId)();
                });
            }
        }
    } catch (error) {
        console.error('Ошибка восстановления состояния ответа:', error);
    }
}



async function openChat(userId) {
    // Сохраняем текущую позицию прокрутки перед переключением
    if (currentChatUserId) {
        const messagesWrapper = document.getElementById('chat-messages-wrapper');
        if (messagesWrapper) {
            scrollPositions[currentChatUserId] = messagesWrapper.scrollTop;
        }
        
        const currentText = document.getElementById('message-input').value;
        if (currentText.trim()) {
            await eel.save_draft_message(localStorage.getItem('user_id'), currentChatUserId, currentText)();
        }
        chatInputs[currentChatUserId] = currentText;
    }
    
    // Если чат уже открыт, просто прокручиваем сообщения
    if (currentChatUserId === userId && !document.getElementById('chat-container').classList.contains('hidden')) {
        const messagesWrapper = document.getElementById('chat-messages-wrapper');
        if (messagesWrapper) {
            messagesWrapper.scrollTop = scrollPositions[userId] || messagesWrapper.scrollHeight;
        }
        return;
    }

    // Полностью останавливаем текущее воспроизведение
    stopVoiceMessage();
    currentPlayingAudio = null;
    voiceMessagePlaying = false;
    currentPlayingVoiceElement = null;
    
    // Сбрасываем контейнер ответа при переходе в другой чат
    const replyContainer = document.getElementById('reply-container');
    if (replyContainer && !replyContainer.classList.contains('hidden')) {
        replyContainer.classList.add('hidden');
        document.querySelector('.message-input-container').classList.remove('expanded');
    }
    
    // Сбрасываем систему дат
    dateHeaders.clear();
    currentStickyDate = null;
    if (dateHeadersObserver) {
        dateHeadersObserver.disconnect();
        dateHeadersObserver = null;
    }
    
    if (readStatusInterval) clearInterval(readStatusInterval);
    if (statusUpdateInterval) clearInterval(statusUpdateInterval);

    currentChatUserId = userId;
    const user = await eel.get_user_data(userId)();
    
    if (user) {
        document.getElementById('default-content').classList.add('hidden');
        document.getElementById('chat-container').classList.remove('hidden');
        document.getElementById('chat-username').textContent = 
            userId === localStorage.getItem('user_id') ? 'Избранное' : user.nickname;
        await updateUserStatus();
        
        // Инициализируем кастомный скроллбар
        initCustomScroll();
        
        if (activeChats[userId]) {
            document.getElementById('chat-messages').innerHTML = activeChats[userId].messages;
            lastMessageId = activeChats[userId].lastMessageId;
            
            // Восстанавливаем позицию прокрутки или прокручиваем вниз
            setTimeout(() => {
                const messagesWrapper = document.getElementById('chat-messages-wrapper');
                if (messagesWrapper) {
                    if (scrollPositions[userId] !== undefined) {
                        messagesWrapper.scrollTop = scrollPositions[userId];
                    } else {
                        messagesWrapper.scrollTop = messagesWrapper.scrollHeight;
                    }
                    // Инициализируем систему дат после восстановления позиции
                    initDateHeadersSystem();
                    updateStickyDateHeaders();
                }
            }, 0);
            
            // Обновляем индикаторы перед установкой обработчиков
            await updateListenIndicators();
            setupVoiceMessageHandlers();
        } else {
            await loadZKChatHistory(userId); 
        }
        
        // Восстанавливаем текст из черновика или из кеша
        const draftText = await eel.get_draft_message(localStorage.getItem('user_id'), userId)();
        document.getElementById('message-input').value = draftText || chatInputs[userId] || '';
        
        // Восстанавливаем состояние ответа
        await checkAndRestoreReplyState();
        
        readStatusInterval = setInterval(updateReadStatus, 2000);
        updateReadStatus();
        
        statusUpdateInterval = setInterval(updateUserStatus, 5000);
        
        // Помечаем карточку пользователя как активную
        document.querySelectorAll('.user-bar').forEach(el => {
            el.classList.remove('active-chat');
        });
        const userCard = document.querySelector(`.user-bar[data-user-id="${userId}"]`);
        if (userCard) {
            userCard.classList.add('active-chat');
        }
    } else {
        console.error('User data not found for ID:', userId);
        document.getElementById('chat-messages').innerHTML = 
            '<div class="error-message">Ошибка загрузки данных пользователя</div>';
    }
}


async function preloadMediaForChat(userId) {
    if (!activeChats[userId]?.messagesData) return;
    
    for (const message of activeChats[userId].messagesData) {
        if (message.isMedia && !message.mediaData) {
            try {
                const response = await eel.get_media_message(message.id)();
                if (response.success) {
                    message.mediaData = response.media_data;
                }
            } catch (error) {
                console.error('Error preloading media:', error);
            }
        }
    }
}


async function updateListenIndicators() {
    if (!currentChatUserId) return;
    
    try {
        const messages = Array.from(document.querySelectorAll('.message'))
            .map(el => ({id: el.dataset.id, isVoice: !!el.querySelector('.voice-message')}))
            .filter(msg => msg.id && msg.isVoice);
        
        if (messages.length === 0) return;
        
        // Проверяем localStorage
        const listenedMessages = JSON.parse(localStorage.getItem('listenedVoiceMessages') || '{}');
        
        // Сначала обновляем индикаторы на основе localStorage
        messages.forEach(msg => {
            const messageElement = document.querySelector(`.message[data-id="${msg.id}"]`);
            if (messageElement) {
                const voiceMessage = messageElement.querySelector('.voice-message');
                if (voiceMessage) {
                    const indicator = voiceMessage.querySelector('.listen-indicator');
                    if (indicator) {
                        const isMyMessage = messageElement.classList.contains('my-message');
                        
                        // Если сообщение уже прослушано (по данным localStorage), скрываем индикатор
                        if (listenedMessages[msg.id] && !isMyMessage) {
                            indicator.style.opacity = '0';
                        }
                    }
                }
            }
        });
        
        // Затем проверяем статус на сервере
        const listenedStatus = await eel.check_voice_messages_listened_status(messages.map(m => m.id))();
        
        messages.forEach(msg => {
            const messageElement = document.querySelector(`.message[data-id="${msg.id}"]`);
            if (messageElement) {
                const voiceMessage = messageElement.querySelector('.voice-message'); // Исправлено здесь
                if (voiceMessage) {
                    const indicator = voiceMessage.querySelector('.listen-indicator');
                    if (indicator) {
                        const isListened = listenedStatus[msg.id] || false;
                        const isMyMessage = messageElement.classList.contains('my-message');
                        
                        if (!isMyMessage && isListened) {
                            indicator.style.opacity = '0';
                            
                            // Сохраняем в localStorage
                            const listenedMessages = JSON.parse(localStorage.getItem('listenedVoiceMessages') || '{}');
                            listenedMessages[msg.id] = true;
                            localStorage.setItem('listenedVoiceMessages', JSON.stringify(listenedMessages));
                        }
                    }
                }
            }
        });
    } catch (error) {
        console.error('Ошибка при обновлении индикаторов прослушивания:', error);
    }
}


function setupVoiceMessageHandlers() {
    const voiceMessages = document.querySelectorAll('.voice-message');
    voiceMessages.forEach((voiceMessage) => {
        const playBtn = voiceMessage.querySelector('.play-voice-btn');
        playBtn.addEventListener('click', async () => {
            const isPlaying = voiceMessage.classList.contains('playing');
            const messageElement = voiceMessage.closest('.message');
            const isMyMessage = messageElement.classList.contains('my-message');
            
            if (isPlaying) {
                stopVoiceMessage(voiceMessage);
            } else {
                // Для своих сообщений используем данные из кеша
                if (isMyMessage) {
                    const messageId = messageElement.dataset.id;
                    const cachedMessage = activeChats[currentChatUserId]?.messagesData?.find(m => m.id === messageId);
                    if (cachedMessage && cachedMessage.voiceData && userEncryptionKey) {
                        try {
                            const decryptedData = await zkCrypto.decryptFile(cachedMessage.voiceData, userEncryptionKey);
                            const audioBlob = new Blob([decryptedData], { type: 'audio/wav' });
                            playZKVoiceMessage(audioBlob, voiceMessage, cachedMessage.duration);
                            return;
                        } catch (error) {
                            console.error('Error decrypting cached voice message:', error);
                        }
                    }
                }
                
                // Для чужих сообщений запрашиваем данные с сервера
                const messageId = messageElement.dataset.id;
                const response = await eel.get_voice_message(messageId)();
                if (response.success && userEncryptionKey) {
                    try {
                        const decryptedData = await zkCrypto.decryptFile(response.encrypted_voice_data, userEncryptionKey);
                        const audioBlob = new Blob([decryptedData], { type: 'audio/wav' });
                        playZKVoiceMessage(audioBlob, voiceMessage, response.duration);
                    } catch (error) {
                        console.error('Error decrypting voice message:', error);
                        alert('Не удалось расшифровать голосовое сообщение');
                    }
                } else {
                    alert('Не удалось загрузить голосовое сообщение');
                }
            }
        });
    });
}









        async function updateUserStatus() {
            if (!currentChatUserId) return;

            try {
                const user = await eel.get_user_data(currentChatUserId)();
                if (!user) return;

                const statusElement = document.getElementById('chat-status');
                const now = new Date();
                const lastOnline = new Date(user.last_online + ' UTC');

                const diffMinutes = Math.floor((now - lastOnline) / (1000 * 60));

                if (currentChatUserId === localStorage.getItem('user_id')) {
                    statusElement.textContent = '';
                    statusElement.classList.remove('online');
                } else if (diffMinutes < 5) {
                    statusElement.textContent = 'В сети';
                    statusElement.classList.add('online');
                } else {
                    statusElement.textContent = `Был(а) в сети ${formatTimeAgo(lastOnline)}`;
                    statusElement.classList.remove('online');
                }

                updateOnlineStatusInContacts();
            } catch (error) {
                console.error('Ошибка при обновлении статуса:', error);
            }
        }

        function updateOnlineStatusInContacts() {
            const userBars = document.querySelectorAll('.user-bar:not(.current-user)');
            userBars.forEach(async bar => {
                const userId = bar.dataset.userId;
                try {
                    const user = await eel.get_user_data(userId)();
                    if (user) {
                        const now = new Date();
                        const lastOnline = new Date(user.last_online + ' UTC');
                        const diffMinutes = Math.floor((now - lastOnline) / (1000 * 60));

                        const avatar = bar.querySelector('.avatar-medium');
                        if (diffMinutes < 5) {
                            avatar.classList.add('online');
                        } else {
                            avatar.classList.remove('online');
                        }
                    }
                } catch (error) {
                    console.error('Ошибка при обновлении статуса контакта:', error);
                }
            });
        }

        function formatTimeAgo(date) {
            const now = new Date();
            const diff = Math.floor((now - date) / 1000);
            
            if (diff < 60) return 'только что';
            if (diff < 3600) return `${Math.floor(diff / 60)} мин. назад`;
            if (diff < 86400) return `${Math.floor(diff / 3600)} ч. назад`;
            
            const days = Math.floor(diff / 86400);
            if (days === 1) return 'вчера';
            if (days < 7) return `${days} дн. назад`;
            
            return date.toLocaleDateString('ru-RU', {
                day: 'numeric',
                month: 'long',
                year: 'numeric'
            });
        }

        async function updateReadStatus() {
    if (!currentChatUserId) return;
    
    try {
        const myMessages = Array.from(document.querySelectorAll('.my-message'))
            .map(el => el.dataset.id)
            .filter(id => id);
        
        if (myMessages.length === 0) return;
        
        const readStatus = await eel.check_message_read_status(myMessages)();
        const listenedStatus = await eel.check_voice_messages_listened_status(myMessages)();
        
        for (const [messageId, isRead] of Object.entries(readStatus)) {
            const messageElement = document.querySelector(`.message[data-id="${messageId}"]`);
            if (messageElement) {
                // Обновляем статус прочтения только для текстовых сообщений
                const voiceMessage = messageElement.querySelector('.voice-message');
                if (!voiceMessage) {
                    const infoElement = messageElement.querySelector('.message-info');
                    if (infoElement) {
                        const timeElement = infoElement.querySelector('span');
                        if (timeElement) {
                            infoElement.innerHTML = `${timeElement.outerHTML}${isRead ? '✓✓' : '✓'}`;
                        }
                    }
                }
                
                // Обновляем индикатор прослушивания для голосовых сообщений
                if (voiceMessage) {
                    const indicator = voiceMessage.querySelector('.listen-indicator');
                    if (indicator) {
                        const isListened = listenedStatus[messageId] || false;
                        indicator.style.opacity = isListened ? '0' : '0.7';
                    }
                }
            }
        }
    } catch (error) {
        console.error('Ошибка при обновлении статуса прочтения:', error);
    }
}

async function loadChatHistory(userId) {
    try {
        const messages = await eel.get_chat_history(localStorage.getItem('user_id'), userId)();
        const messagesContainer = document.getElementById('chat-messages');
        messagesContainer.innerHTML = '';

        // Сбрасываем карту заголовков
        dateHeaders.clear();
        currentStickyDate = null;

        if (!activeChats[userId]) {
            activeChats[userId] = {
                messages: '',
                lastMessageId: null,
                messagesData: []
            };
        }

        if (messages && Array.isArray(messages) && messages.length > 0) {
            messages.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
            
            const messagesData = [];
            let currentDateKey = null;
            
            for (const msg of messages) {
                const isMyMessage = msg.sender_id === localStorage.getItem('user_id');
                
                // Проверяем, нужно ли добавить заголовок даты
                const messageDate = new Date(msg.timestamp);
                const messageDateKey = messageDate.toDateString();
                
                if (messageDateKey !== currentDateKey) {
                    const dateText = formatMessageDate(msg.timestamp);
                    const dateHeader = createDateHeader(dateText, messageDateKey);
                    messagesContainer.appendChild(dateHeader);
                    dateHeaders.set(messageDateKey, dateHeader);
                    currentDateKey = messageDateKey;
                }
                
                const messageElement = await addMessageToChat(msg, isMyMessage, false);
                
                // Сохраняем данные сообщения
                if (msg.isMedia || msg.is_media) {
                    messagesData.push({
                        id: msg.id,
                        isMedia: true,
                        mediaType: msg.media_type,
                        file_id: msg.file_id,
                        filename: msg.filename,
                        text: msg.text,
                        mediaData: msg.mediaData
                    });
                } else if (msg.isVoiceMessage || msg.is_voice) {
                    messagesData.push({
                        id: msg.id,
                        voiceData: msg.voice_data,
                        duration: msg.duration,
                        isVoiceMessage: true,
                        listened: msg.listened || false
                    });
                } else {
                    messagesData.push({
                        id: msg.id,
                        text: msg.text,
                        sender_id: msg.sender_id,
                        timestamp: msg.timestamp
                    });
                }
            }
            
            lastMessageId = messages[messages.length - 1].id;
            
            activeChats[userId] = {
                messages: messagesContainer.innerHTML,
                lastMessageId: lastMessageId,
                messagesData: messagesData
            };
            
            // Инициализируем систему заголовков после загрузки истории
            setTimeout(() => {
                initDateHeadersSystem();
                updateStickyDateHeaders();
                
                const messagesWrapper = document.getElementById('chat-messages-wrapper');
                if (messagesWrapper) {
                    if (scrollPositions[userId] !== undefined) {
                        messagesWrapper.scrollTop = scrollPositions[userId];
                    } else {
                        messagesWrapper.scrollTop = messagesWrapper.scrollHeight;
                    }
                }
            }, 0);
            
            setupVoiceMessageHandlers();
        } else {
            messagesContainer.innerHTML = '<div class="no-messages">Нет сообщений</div>';
            lastMessageId = null;
            activeChats[userId] = {
                messages: messagesContainer.innerHTML,
                lastMessageId: null,
                messagesData: []
            };
        }
    } catch (error) {
        console.error('Error loading chat history:', error);
        document.getElementById('chat-messages').innerHTML = 
            '<div class="error-message">Ошибка загрузки истории сообщений</div>';
    }
}



async function sendMessage(text) {
    if (!currentChatUserId || !text) return;
    
    try {
        const replyContainer = document.getElementById('reply-container');
        const isReplying = !replyContainer.classList.contains('hidden');
        const replyToId = isReplying ? replyContainer.dataset.messageId : null;
        
        const result = await eel.send_message(
            localStorage.getItem('user_id'),
            currentChatUserId,
            text,
            replyToId
        )();
        
        if (result.success) {
            const message = {
                id: result.message_id,
                sender_id: localStorage.getItem('user_id'),
                receiver_id: currentChatUserId,
                text: text,
                timestamp: result.timestamp,
                read: result.read,
                reply_to: result.reply_to,
                reply_text: result.reply_text,
                reply_sender_id: result.reply_sender_id
            };
            
            addMessageToChat(message, true, true);
            lastMessageId = message.id;
            
            if (activeChats[currentChatUserId]) {
                const messagesContainer = document.getElementById('chat-messages');
                activeChats[currentChatUserId] = {
                    messages: messagesContainer.innerHTML,
                    lastMessageId: lastMessageId
                };
            }
            
            // Обновляем последнее сообщение на карточке пользователя
            updateLastMessageOnUserCard(currentChatUserId, text, true);
            
            // Сбрасываем контейнер ответа и очищаем состояние в БД
            if (replyContainer) {
                replyContainer.classList.add('hidden');
                replyContainer.innerHTML = '';
                document.querySelector('.message-input-container').classList.remove('expanded');
                await eel.clear_reply_state(localStorage.getItem('user_id'), currentChatUserId)();
            }
            
            // Очищаем черновик после успешной отправки
            await eel.clear_draft_message(localStorage.getItem('user_id'), currentChatUserId)();
            chatInputs[currentChatUserId] = '';
        } else {
            console.error("Ошибка при отправке:", result.message);
        }
    } catch (error) {
        console.error('Error sending message:', error);
    }
}

        function updateLastMessageOnUserCard(userId, messageText, isMyMessage) {
            const userCard = document.querySelector(`.user-bar[data-user-id="${userId}"]`);
            if (!userCard) return;
            
            const lastMsgDiv = userCard.querySelector('.last-message');
            let displayText = messageText;
            
            if (displayText.length > 25) {
                displayText = displayText.substring(0, 22) + '...';
            }
            
            if (isMyMessage) {
                if (lastMsgDiv) {
                    lastMsgDiv.innerHTML = `<span class="you-indicator">Вы:</span> ${displayText}`;
                } else {
                    // Если элемента еще нет, создаем его
                    const contentWrapper = userCard.querySelector('.user-content-wrapper');
                    if (contentWrapper) {
                        const newLastMsgDiv = document.createElement('div');
                        newLastMsgDiv.className = 'last-message';
                        newLastMsgDiv.innerHTML = `<span class="you-indicator">Вы:</span> ${displayText}`;
                        contentWrapper.appendChild(newLastMsgDiv);
                    }
                }
            } else {
                if (lastMsgDiv) {
                    lastMsgDiv.textContent = displayText;
                } else {
                    const contentWrapper = userCard.querySelector('.user-content-wrapper');
                    if (contentWrapper) {
                        const newLastMsgDiv = document.createElement('div');
                        newLastMsgDiv.className = 'last-message';
                        newLastMsgDiv.textContent = displayText;
                        contentWrapper.appendChild(newLastMsgDiv);
                    }
                }
            }
        }

async function addMessageToChat(message, isMyMessage, scrollToBottom = true) {
    const messagesContainer = document.getElementById('chat-messages');
    
    if (!messagesContainer) {
        console.error('Messages container not found');
        return null;
    }
    
    // Удаляем сообщение "Нет сообщений", если оно есть
    const noMessagesDiv = messagesContainer.querySelector('.no-messages');
    if (noMessagesDiv) {
        noMessagesDiv.remove();
    }
    
    if (!message) {
        console.error('Message is null or undefined');
        return null;
    }
    
    // Создаем элемент сообщения
    const messageElement = document.createElement('div');
    messageElement.className = `message ${isMyMessage ? 'my-message' : 'their-message'}`;
    messageElement.dataset.id = message.id || '';
    messageElement.dataset.sender_id = message.sender_id || '';
    messageElement.dataset.timestamp = message.timestamp || new Date().toISOString();
    
    // Добавляем заголовок даты для этого сообщения (если нужно)
    const messageTimestamp = message.timestamp || new Date().toISOString();
    const dateKey = new Date(messageTimestamp).toDateString();
    const dateText = formatMessageDate(messageTimestamp);
    
    // Если заголовок для этой даты еще не существует, создаем его
    if (!dateHeaders.has(dateKey)) {
        const dateHeader = createDateHeader(dateText, dateKey);
        
        try {
            messagesContainer.appendChild(dateHeader);
            dateHeaders.set(dateKey, dateHeader);
        } catch (error) {
            console.error('Error adding date header:', error);
        }
    }
    
    // Добавляем контент в зависимости от типа сообщения
    if (message.isMedia || message.is_media) {
        const mediaContainer = document.createElement('div');
        mediaContainer.className = 'media-message';
        
        const mediaType = message.mediaType || (message.is_media ? message.media_type : null);
        
        if (mediaType === 'image') {
            const img = document.createElement('img');
            img.className = 'media-preview';
            img.alt = 'Фото';
            img.loading = 'lazy';

            // Для изображений загружаем и расшифровываем данные
            const loadingElement = document.createElement('div');
            loadingElement.className = 'media-loading';
            loadingElement.textContent = 'Загрузка...';
            mediaContainer.appendChild(loadingElement);

            try {
                const response = await eel.get_media_message(message.id)();
                if (response.success && userEncryptionKey) {
                    const decryptedData = await zkCrypto.decryptFile(response.encrypted_media_data, userEncryptionKey);
                    const blob = new Blob([decryptedData], { type: 'image/jpeg' });
                    img.src = URL.createObjectURL(blob);
                    
                    loadingElement.remove();
                    mediaContainer.appendChild(img);
                } else {
                    throw new Error('Failed to load image');
                }
            } catch (error) {
                console.error('Error loading image:', error);
                loadingElement.textContent = 'Ошибка загрузки';
                loadingElement.classList.add('error');
            }
        } else if (mediaType === 'video') {
            // Обработка видео
            const videoContainer = document.createElement('div');
            videoContainer.className = 'video-message-container';
            
            const videoElement = document.createElement('video');
            videoElement.className = 'video-preview hidden';
            videoElement.controls = true;
            videoElement.dataset.messageId = message.id;
            
            const loadingElement = document.createElement('div');
            loadingElement.className = 'video-loading';
            loadingElement.dataset.messageId = message.id;
            loadingElement.innerHTML = `
                <div class="video-load-icon"></div>
                <div class="video-load-text">Загрузить видео</div>
            `;
            
            loadingElement.addEventListener('click', () => loadZKVideoMessage(message.id));
            
            videoContainer.appendChild(loadingElement);
            videoContainer.appendChild(videoElement);
            mediaContainer.appendChild(videoContainer);
        }
        
        if (message.text && message.text !== '[Видео]' && message.text !== '[Фото]') {
            const caption = document.createElement('div');
            caption.className = 'media-caption';
            caption.textContent = message.text;
            mediaContainer.appendChild(caption);
        }
        
        messageElement.appendChild(mediaContainer);
    }else if (message.isVoiceMessage || message.is_voice) {
        // Голосовое сообщение
        const voiceMessage = createVoiceMessageElement(message);
        messageElement.appendChild(voiceMessage);
    } else if (message.text) {
        // Текстовое сообщение
        const textElement = document.createElement('div');
        textElement.className = 'message-text';
        textElement.textContent = message.text;
        messageElement.appendChild(textElement);
        
        // Обработка ответов на сообщения
        if (message.reply_to) {
            const replyElement = document.createElement('div');
            replyElement.className = 'message-reply';
            
            const isReplyMyMessage = message.reply_sender_id === localStorage.getItem('user_id');
            const replyAuthor = isReplyMyMessage ? 'Вы' : document.getElementById('chat-username').textContent;
            
            replyElement.innerHTML = `
                <div class="reply-header">
                    <div class="reply-author">${replyAuthor}</div>
                </div>
                <div class="reply-text">${message.reply_text && message.reply_text.length > 50 ? 
                    message.reply_text.substring(0, 47) + '...' : message.reply_text || ''}</div>
            `;
            
            messageElement.insertBefore(replyElement, textElement);
        }
    }
    
    // Добавляем информацию о сообщении
    const infoElement = document.createElement('div');
    infoElement.className = 'message-info';
    
    const timeElement = document.createElement('span');
    timeElement.textContent = formatMessageTime(message.timestamp || new Date().toISOString());
    infoElement.appendChild(timeElement);
    
    if (isMyMessage && !(message.isVoiceMessage || message.is_voice)) {
        const readStatus = document.createElement('span');
        readStatus.textContent = message.read ? '✓✓' : '✓';
        infoElement.appendChild(readStatus);
    }
    
    messageElement.appendChild(infoElement);
    
    // Добавляем контекстное меню для сообщения
    messageElement.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        currentContextMessage = messageElement;
        
        const isVideoMessage = (message.isMedia || message.is_media) && 
                              (message.mediaType === 'video' || message.media_type === 'video');
        const isVoiceMessage = message.isVoiceMessage || message.is_voice;
        const isMyMessage = message.sender_id === localStorage.getItem('user_id');
        
        document.getElementById('message-edit').classList.toggle('hidden', !isMyMessage || isVideoMessage || isVoiceMessage);
        document.getElementById('message-delete').classList.toggle('hidden', !isMyMessage);
        document.getElementById('message-delete-for-me').classList.toggle('hidden', isMyMessage);
        
        window.showMessageContextMenu(e);
    });
    
    // Безопасное добавление сообщения в контейнер
    try {
        messagesContainer.appendChild(messageElement);
    } catch (error) {
        console.error('Error adding message to container:', error);
        return null;
    }
    
    // Сохраняем данные сообщения в кеш активного чата
    if ((message.isMedia || message.is_media) && activeChats[currentChatUserId]?.messagesData) {
        if (!activeChats[currentChatUserId].messagesData.find(m => m.id === message.id)) {
            if (!activeChats[currentChatUserId]) {
                activeChats[currentChatUserId] = {
                    messages: '',
                    lastMessageId: null,
                    messagesData: []
                };
            }
            
            if (!activeChats[currentChatUserId].messagesData) {
                activeChats[currentChatUserId].messagesData = [];
            }
            
            // Для медиафайлов сохраняем данные
            if (message.isMedia || message.is_media) {
                const mediaData = {
                    id: message.id,
                    isMedia: true,
                    mediaType: message.mediaType || message.media_type,
                    text: message.text,
                    mediaData: message.mediaData // Сохраняем данные медиа
                };
                
                activeChats[currentChatUserId].messagesData.push(mediaData);
            }
        }
    } else if ((message.isVoiceMessage || message.is_voice) && activeChats[currentChatUserId]?.messagesData) {
        // Сохраняем данные голосового сообщения
        if (!activeChats[currentChatUserId].messagesData.find(m => m.id === message.id)) {
            if (!activeChats[currentChatUserId]) {
                activeChats[currentChatUserId] = {
                    messages: '',
                    lastMessageId: null,
                    messagesData: []
                };
            }
            
            if (!activeChats[currentChatUserId].messagesData) {
                activeChats[currentChatUserId].messagesData = [];
            }
            
            activeChats[currentChatUserId].messagesData.push({
                id: message.id,
                voiceData: message.voiceData,
                duration: message.duration,
                isVoiceMessage: true,
                listened: message.listened || false,
                visualization: message.visualization || []
            });
        }
    } else if (!message.isMedia && !message.is_media && !message.isVoiceMessage && !message.is_voice) {
        // Сохраняем текстовые сообщения
        if (activeChats[currentChatUserId] && !activeChats[currentChatUserId].messagesData.find(m => m.id === message.id)) {
            if (!activeChats[currentChatUserId].messagesData) {
                activeChats[currentChatUserId].messagesData = [];
            }
            
            activeChats[currentChatUserId].messagesData.push({
                id: message.id,
                text: message.text,
                sender_id: message.sender_id,
                timestamp: message.timestamp
            });
        }
    }
    
    // Инициализируем систему заголовков после добавления сообщения
    if (!dateHeadersObserver) {
        setTimeout(() => {
            initDateHeadersSystem();
            updateStickyDateHeaders();
        }, 0);
    }
    
    // Прокручиваем вниз, если нужно
    if (scrollToBottom) {
        setTimeout(() => {
            const messagesWrapper = document.getElementById('chat-messages-wrapper');
            if (messagesWrapper) {
                messagesWrapper.scrollTop = messagesWrapper.scrollHeight;
                // Обновляем sticky заголовки после прокрутки
                setTimeout(updateStickyDateHeaders, 100);
            }
        }, 0);
    }
    
    return messageElement;
}







async function loadVideoFromServer(messageId, container) {
    try {
        // Показываем индикатор загрузки
        container.innerHTML = '<div class="video-load-spinner">Загрузка...</div>';
        
        // Получаем данные видео с сервера
        const response = await eel.get_media_message(messageId)();
        if (!response.success) {
            throw new Error(response.message || 'Failed to get video data');
        }
        
        // Создаем элемент видео
        const videoElement = document.createElement('video');
        videoElement.className = 'video-preview';
        videoElement.controls = true;
        videoElement.dataset.messageId = messageId;
        videoElement.src = `data:video/mp4;base64,${response.media_data}`;
        
        // Заменяем индикатор загрузки на видео
        container.innerHTML = '';
        container.appendChild(videoElement);
        
        return true;
    } catch (error) {
        console.error('Error loading video:', error);
        container.innerHTML = `
            <div class="video-load-error">
                Ошибка загрузки
                <button class="video-retry-btn">Повторить</button>
            </div>
        `;
        
        // Добавляем обработчик для кнопки повтора
        container.querySelector('.video-retry-btn').addEventListener('click', () => {
            loadVideoFromServer(messageId, container);
        });
        
        return false;
    }
}


// Вспомогательная функция для сохранения видео в локальное хранилище
async function saveVideoToLocalStorage(messageId, videoData) {
    try {
        // Создаем папку для хранения медиа, если ее нет
        const mediaDir = await eel.create_video_cache_folder()();
        if (!mediaDir) throw new Error("Не удалось создать папку для медиа");
        
        // Сохраняем видео в файл
        const result = await eel.save_video_to_cache(messageId, videoData)();
        return result.success;
    } catch (error) {
        console.error('Ошибка сохранения видео:', error);
        return false;
    }
}

function formatMessageTime(timestamp) {
    const date = new Date(timestamp);
    return date.toLocaleTimeString('ru-RU', { hour: '2-digit', minute: '2-digit' });
}

// Добавим обработчик для загрузки видео
document.addEventListener('click', function(e) {
    const videoLoadElement = e.target.closest('.video-loading');
    if (videoLoadElement) {
        const messageId = videoLoadElement.dataset.messageId;
        loadVideoMessage(messageId);
    }
});

async function loadVideoMessage(messageId, container) {
    try {
        // Показываем индикатор загрузки
        const loadingOverlay = document.createElement('div');
        loadingOverlay.className = 'video-loading-overlay';
        loadingOverlay.innerHTML = `
            <div class="video-loading-content">
                <div class="video-loading-spinner"></div>
                <div class="video-loading-text">Загрузка видео...</div>
                <div class="video-loading-progress">0%</div>
                <button class="video-loading-cancel">Отмена</button>
            </div>
        `;
        
        document.body.appendChild(loadingOverlay);
        
        // Получаем данные видео
        const response = await eel.get_media_message(messageId)();
        if (!response.success) {
            throw new Error(response.message || 'Failed to get video data');
        }
        
        // Находим элементы в DOM
        const videoElement = document.querySelector(`.video-preview[data-message-id="${messageId}"]`);
        const loadingElement = document.querySelector(`.video-loading[data-message-id="${messageId}"]`);
        
        if (!videoElement || !loadingElement) {
            throw new Error('Video elements not found');
        }
        
        // Устанавливаем источник видео
        videoElement.src = `data:video/mp4;base64,${response.media_data}`;
        
        // Скрываем элемент загрузки и показываем видео
        loadingElement.classList.add('hidden');
        videoElement.classList.remove('hidden');
        
        // Удаляем оверлей загрузки
        loadingOverlay.remove();
        
        // Помечаем как прочитанное, если это не мое сообщение
        if (!videoElement.closest('.my-message')) {
            await eel.mark_messages_as_read(
                videoElement.closest('.message').dataset.sender_id,
                localStorage.getItem('user_id')
            )();
        }
        
        // Обработчик отмены загрузки
        const cancelBtn = loadingOverlay.querySelector('.video-loading-cancel');
        if (cancelBtn) {
            cancelBtn.addEventListener('click', () => {
                loadingOverlay.remove();
            });
        }
    } catch (error) {
        console.error('Ошибка загрузки видео:', error);
        
        // Обновляем элемент загрузки с сообщением об ошибке
        const loadingElement = document.querySelector(`.video-loading[data-message-id="${messageId}"]`);
        if (loadingElement) {
            loadingElement.innerHTML = `
                <div class="video-load-error">Ошибка загрузки</div>
                <button class="video-retry-btn">Повторить</button>
            `;
            
            loadingElement.querySelector('.video-retry-btn').addEventListener('click', () => {
                loadVideoMessage(messageId, container);
            });
        }
        
        document.querySelector('.video-loading-overlay')?.remove();
    }
}



async function checkForNewMessages() {
    if (!currentChatUserId) return;
    
    try {
        const newMessages = await eel.check_new_messages(
            localStorage.getItem('user_id'),
            lastMessageId
        )();
        
        if (newMessages && newMessages.length > 0) {
            for (const msg of newMessages) {
                if (msg.sender_id === currentChatUserId) {
                    await addMessageToChat(msg, false, true);
                    // Обновляем последнее сообщение на карточке
                    updateLastMessageOnUserCard(currentChatUserId, msg.text, false);
                }
            }
            
            lastMessageId = newMessages[newMessages.length - 1].id;
            
            const messagesContainer = document.getElementById('chat-messages');
            activeChats[currentChatUserId] = {
                messages: messagesContainer.innerHTML,
                lastMessageId: lastMessageId
            };
            
            updateOnlineStatusInContacts();
            
            // Устанавливаем обработчики для новых голосовых сообщений
            setupVoiceMessageHandlers();
        }
    } catch (error) {
        console.error('Error checking new messages:', error);
    }
}
        
 async function loadFriends() {
    const user_id = localStorage.getItem('user_id');
    try {
        currentUser = await eel.get_user_data(user_id)();
        
        const container = document.getElementById('user-container');
        container.innerHTML = '';
        
        // Добавляем карточку текущего пользователя
        const selfCard = createUserCard({
            user_id: user_id,
            nickname: currentUser.nickname,
            isCurrentUser: true
        });
        container.appendChild(selfCard);
        
        // Добавляем друзей
        if (currentUser.friends && currentUser.friends.length > 0) {
            for (const friendId of currentUser.friends) {
                const friend = await eel.get_user_data(friendId)();
                if (friend) {
                    // Получаем последнее сообщение
                    const lastMessage = await eel.get_last_message(user_id, friendId)();
                    const friendCard = createUserCard({
                        user_id: friendId,
                        nickname: friend.nickname, // Используем nickname из user_data
                        isFriend: true,
                        lastMessage: lastMessage
                    });
                    container.appendChild(friendCard);
                }
            }
            
            updateOnlineStatusInContacts();
        } else {
            const noFriends = document.createElement('div');
            noFriends.className = 'no-friends';
            noFriends.textContent = 'У вас пока нет друзей. Найдите их через поиск!';
            container.appendChild(noFriends);
        }
    } catch (error) {
        console.error('Error loading friends:', error);
    }
}

function createUserCard(userData) {
    const card = document.createElement('div');
    card.className = 'user-bar' + (userData.isCurrentUser ? ' current-user' : '');
    card.dataset.userId = userData.user_id;
    
    const avatar = document.createElement('div');
    avatar.className = 'avatar-medium';
    avatar.style.backgroundImage = 'url(https://cdn-icons-png.flaticon.com/512/3135/3135715.png)';
    
    const contentWrapper = document.createElement('div');
    contentWrapper.className = 'user-content-wrapper';
    
    const username = document.createElement('div');
    username.className = 'username';
    // Для ZK архитектуры используем ID как отображаемое имя
    username.textContent = userData.isCurrentUser ? 'Вы' : `Пользователь ${userData.user_id.substring(0, 8)}`;
    
    contentWrapper.appendChild(username);
    
    // Добавляем последнее сообщение, если оно есть
    if (userData.lastMessage && !userData.isCurrentUser) {
        const lastMsgDiv = document.createElement('div');
        lastMsgDiv.className = 'last-message';
        
        let messageText = userData.lastMessage.text;
        if (messageText.length > 25) {
            messageText = messageText.substring(0, 22) + '...';
        }
        
        if (userData.lastMessage.sender_id === localStorage.getItem('user_id')) {
            lastMsgDiv.innerHTML = `<span class="you-indicator">Вы:</span> ${messageText}`;
        } else {
            lastMsgDiv.textContent = messageText;
        }
        
        contentWrapper.appendChild(lastMsgDiv);
    }
    
    card.appendChild(avatar);
    card.appendChild(contentWrapper);
    
    if (!userData.isCurrentUser) {
        card.addEventListener('contextmenu', function(e) {
            e.preventDefault();
            showContextMenu(e, userData);
        });
    }
    
    return card;
}

        function showContextMenu(e, userData) {
            closeContextMenu();
            
            contextMenuTarget = userData.user_id;
            
            const addBtn = document.getElementById('context-menu-add');
            const removeBtn = document.getElementById('context-menu-remove');
            
            if (currentUser.friends.includes(userData.user_id)) {
                addBtn.classList.add('hidden');
                removeBtn.classList.remove('hidden');
            } else {
                addBtn.classList.remove('hidden');
                removeBtn.classList.add('hidden');
            }
            
            contextMenu.style.display = 'block';
            contextMenu.style.left = `${e.pageX}px`;
            contextMenu.style.top = `${e.pageY}px`;
        }

        function closeContextMenu() {
            if (contextMenu) {
                contextMenu.style.display = 'none';
            }
            contextMenuTarget = null;
        }

        async function handleAddFriend() {
            if (!contextMenuTarget) return;
            
            const user_id = localStorage.getItem('user_id');
            try {
                const response = await eel.add_friend(user_id, contextMenuTarget)();
                
                if (response.success) {
                    await loadFriends();
                }
                alert(response.message);
            } catch (error) {
                alert('Ошибка при добавлении в друзья');
                console.error('Error adding friend:', error);
            }
            
            closeContextMenu();
        }

        async function handleRemoveFriend() {
            if (!contextMenuTarget) return;
            
            const user_id = localStorage.getItem('user_id');
            try {
                const response = await eel.remove_friend(user_id, contextMenuTarget)();
                
                if (response.success) {
                    await loadFriends();
                    if (currentChatUserId === contextMenuTarget) {
                        closeChat();
                    }
                }
                alert(response.message);
            } catch (error) {
                alert('Ошибка при удалении из друзей');
                console.error('Error removing friend:', error);
            }
            
            closeContextMenu();
        }

        async function displaySearchResults(users) {
            const container = document.getElementById('user-container');
            container.innerHTML = '';
            
            if (users.length === 0) {
                const noResults = document.createElement('div');
                noResults.className = 'no-results';
                noResults.textContent = 'Ничего не найдено';
                container.appendChild(noResults);
                return;
            }
            
            for (const user of users) {
                const isFriend = currentUser.friends.includes(user.user_id);
                // Получаем последнее сообщение для результатов поиска
                const lastMessage = await eel.get_last_message(localStorage.getItem('user_id'), user.user_id)();
                const userCard = createUserCard({
                    user_id: user.user_id,
                    nickname: user.nickname,
                    isFriend: isFriend,
                    lastMessage: lastMessage
                });
                container.appendChild(userCard);
            }
            
            updateOnlineStatusInContacts();
        }

        // Функции для работы с голосовыми сообщениями
        async function startRecording(e) {
    e.preventDefault();
    
    try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        mediaRecorder = new MediaRecorder(stream);
        audioChunks = [];
        recordingStartTime = Date.now();
        
        mediaRecorder.ondataavailable = (e) => {
            if (e.data.size > 0) audioChunks.push(e.data);
        };
        
        mediaRecorder.onstop = async () => {
            const recordingTime = (Date.now() - recordingStartTime) / 1000;
            if (recordingTime < 0.5) {
                alert('Сообщение слишком короткое');
                return;
            }
            
            const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
            await sendZKVoiceMessage(audioBlob, recordingTime);
        };
        
        mediaRecorder.start(100);
        document.getElementById('message-input').classList.add('hidden');
        document.getElementById('recording-container').classList.remove('hidden');
        updateRecordingTime();
    } catch (error) {
        console.error('Ошибка записи:', error);
        alert('Не удалось получить доступ к микрофону');
    }
}

        function stopRecording(e) {
            e.preventDefault();
            
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
                mediaRecorder.stream.getTracks().forEach(track => track.stop());
                
                // Скрываем индикатор записи
                document.getElementById('recording-container').classList.add('hidden');
                document.getElementById('message-input').classList.remove('hidden');
            }
        }

        function updateRecordingTime() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                const recordingTime = ((Date.now() - recordingStartTime) / 1000).toFixed(1);
                document.getElementById('recording-time').textContent = recordingTime;
                setTimeout(updateRecordingTime, 100);
            }
        }

async function sendVoiceMessage(audioBlob, duration, oldVisualizationData = null) {
    if (!currentChatUserId || !audioBlob) return;
    
    try {
        const reader = new FileReader();
        reader.readAsDataURL(audioBlob);
        
        reader.onload = async () => {
            const audioData = reader.result.split(',')[1];
            
            // Анализируем аудио и создаем визуализацию
            const visualizationData = await analyzeAudioAndCreateVisualization(audioBlob, duration);
            
            const result = await eel.send_voice_message(
                localStorage.getItem('user_id'),
                currentChatUserId,
                audioData,
                duration,
                visualizationData
            )();
            
            if (result.success) {
                const message = {
                    id: result.message_id,
                    sender_id: localStorage.getItem('user_id'),
                    receiver_id: currentChatUserId,
                    text: '[Голосовое сообщение]',
                    timestamp: result.timestamp,
                    read: result.read,
                    isVoiceMessage: true,
                    voiceData: audioData,
                    duration: duration,
                    visualization: visualizationData,
                    listened: currentChatUserId === localStorage.getItem('user_id')
                };
                
                // Инициализируем messagesData, если его нет
                if (!activeChats[currentChatUserId]) {
                    activeChats[currentChatUserId] = {
                        messages: '',
                        lastMessageId: null,
                        messagesData: []
                    };
                } else if (!activeChats[currentChatUserId].messagesData) {
                    activeChats[currentChatUserId].messagesData = [];
                }
                
                addMessageToChat(message, true, true);
                lastMessageId = message.id;
                
                // Сохраняем состояние чата
                const messagesContainer = document.getElementById('chat-messages');
                activeChats[currentChatUserId].messages = messagesContainer.innerHTML;
                activeChats[currentChatUserId].lastMessageId = lastMessageId;
                
                // Добавляем данные сообщения в кеш
                activeChats[currentChatUserId].messagesData.push({
                    id: message.id,
                    voiceData: message.voiceData,
                    duration: message.duration,
                    isVoiceMessage: true,
                    listened: message.listened,
                    visualization: visualizationData
                });
                
                // Обновляем последнее сообщение на карточке
                updateLastMessageOnUserCard(currentChatUserId, 'Голосовое сообщение', true);
                
                // Устанавливаем обработчики для голосовых сообщений
                setupVoiceMessageHandlers();
            }
        };
    } catch (error) {
        console.error('Ошибка отправки голосового сообщения:', error);
    }
}

function createVoiceMessageElement(message) {
    const voiceMessage = document.createElement('div');
    voiceMessage.className = 'voice-message';
    voiceMessage.dataset.messageId = message.id;
    
    const playBtn = document.createElement('button');
    playBtn.className = 'play-voice-btn';
    playBtn.innerHTML = '<img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTdnax9muCZwZsJujMzKiWx8tnQXgbwNaX39A&s" alt="Play">';
    
    const isMyMessage = message.sender_id === localStorage.getItem('user_id');
    
    // Проверяем localStorage перед установкой opacity
    const listenedMessages = JSON.parse(localStorage.getItem('listenedVoiceMessages') || '{}');
    const isListened = listenedMessages[message.id] || message.listened;
    
    // Создаем индикатор прослушивания
    const listenIndicator = document.createElement('div');
    listenIndicator.className = 'listen-indicator';
    
    if (isMyMessage) {
        listenIndicator.style.opacity = isListened ? '0' : '0.7';
    } else {
        listenIndicator.style.opacity = isListened ? '0' : '0.7';
    }
    
    voiceMessage.appendChild(listenIndicator);
    
    const visualizationContainer = document.createElement('div');
    visualizationContainer.className = 'voice-visualization-container';
    
    const visualization = document.createElement('div');
    visualization.className = 'voice-visualization';
    
    // Получаем данные визуализации из сообщения
    const visualizationData = message.visualization || Array(20).fill(0.3);
    
    // Создаем полоски визуализации
// Создаем полоски визуализации
for (let i = 0; i < 20; i++) {
    const bar = document.createElement('div');
    bar.className = 'voice-bar';
    bar.style.setProperty('--i', i);
    
    // Нормализуем значение (0-1) и масштабируем до высоты (3-30px)
    const height = Math.max(3, visualizationData[i] * 30);
    bar.style.height = `${height}px`;
    
    if (isMyMessage) {
        bar.style.backgroundColor = `rgba(0, 0, 0, ${0.2 + visualizationData[i] * 0.8})`;
    } else {
        bar.style.backgroundColor = `rgba(255, 255, 255, ${0.5 + visualizationData[i] * 0.5})`;
    }
    
    visualization.appendChild(bar);
}
    
    // Добавляем ползунок прогресса
    const progressBar = document.createElement('div');
    progressBar.className = 'voice-progress';
    progressBar.style.display = 'none';
    
    visualizationContainer.appendChild(visualization);
    visualizationContainer.appendChild(progressBar);
    
    const time = document.createElement('div');
    time.className = 'voice-time';
    time.dataset.duration = message.duration;
    time.textContent = `${message.duration.toFixed(1)} сек.`;
    
    voiceMessage.appendChild(playBtn);
    voiceMessage.appendChild(visualizationContainer);
    voiceMessage.appendChild(time);
    
    return voiceMessage;
}




function openFileSelector() {
    const fileInput = document.getElementById('file-input');
    if (fileInput) {
        fileInput.value = '';
        fileInput.setAttribute('multiple', 'multiple');
        fileInput.click();
    }
}



function initMessageContextMenu() {
    console.log('initMessageContextMenu вызвана');
    const messageContextMenu = document.getElementById('message-context-menu');
    window.messageContextMenu = messageContextMenu; // Делаем глобальной для доступа из других функций
    

    // Закрытие меню при клике вне его
    document.addEventListener('click', function(e) {
        if (messageContextMenu && !messageContextMenu.contains(e.target)) {
            messageContextMenu.classList.add('hidden');
        }
    });

// В функции initMessageContextMenu обновляем обработчик правого клика:
document.addEventListener('contextmenu', function(e) {
    const messageElement = e.target.closest('.message');
    if (messageElement) {
        e.preventDefault();
        currentContextMessage = messageElement;
        
        const isVideoMessage = messageElement.querySelector('.video-preview') !== null;
        const isVoiceMessage = messageElement.querySelector('.voice-message') !== null;
        const isMyMessage = messageElement.classList.contains('my-message');
        
        // Настраиваем видимость пунктов меню
        document.getElementById('message-edit').classList.toggle('hidden', !isMyMessage || isVideoMessage || isVoiceMessage);
        document.getElementById('message-delete').classList.toggle('hidden', !isMyMessage);
        document.getElementById('message-delete-for-me').classList.toggle('hidden', isMyMessage);
        document.getElementById('message-pin').classList.toggle('hidden', !isMyMessage || isVoiceMessage);
        document.getElementById('message-reply').classList.toggle('hidden', false);
        document.getElementById('message-forward').classList.toggle('hidden', false);
        document.getElementById('message-copy').classList.toggle('hidden', false);
        
        // Позиционируем меню
        const menuWidth = messageContextMenu.offsetWidth;
        const menuHeight = messageContextMenu.offsetHeight;
        const windowWidth = window.innerWidth;
        const windowHeight = window.innerHeight;
        
        let left = e.clientX;
        let top = e.clientY;
        
        // Проверяем, чтобы меню не выходило за границы экрана
        if (left + menuWidth > windowWidth) {
            left = windowWidth - menuWidth - 5;
        }
        
        if (top + menuHeight > windowHeight) {
            top = windowHeight - menuHeight - 5;
        }
        
        messageContextMenu.style.left = `${left}px`;
        messageContextMenu.style.top = `${top}px`;
        messageContextMenu.style.display = 'block';
        messageContextMenu.classList.remove('hidden');
        
        // Убедимся, что меню поверх других элементов
        messageContextMenu.style.zIndex = '1000';
    }
});

    // Общая функция для закрытия меню
    function closeMessageContextMenu() {
        if (messageContextMenu) {
            messageContextMenu.classList.add('hidden');
        }
    }

    // Обработчики пунктов меню
    document.getElementById('message-reply').addEventListener('click', function() {
        handleReply();
        closeMessageContextMenu();
    });
    
    document.getElementById('message-edit').addEventListener('click', function() {
        handleEdit();
        closeMessageContextMenu();
    });
    
    document.getElementById('message-pin').addEventListener('click', function() {
        handlePin();
        closeMessageContextMenu();
    });
    
    document.getElementById('message-delete').addEventListener('click', function() {
        handleDelete();
        closeMessageContextMenu();
    });
    
    document.getElementById('message-forward').addEventListener('click', function() {
        handleForward();
        closeMessageContextMenu();
    });
    
    document.getElementById('message-copy').addEventListener('click', function() {
        handleCopy();
        closeMessageContextMenu();
    });

async function handleReply() {
    if (!currentContextMessage) return;
    
    try {
        const messageText = currentContextMessage.querySelector('.message-text')?.textContent || '[Голосовое сообщение]';
        const isMyMessage = currentContextMessage.classList.contains('my-message');
        const replyContainer = document.getElementById('reply-container');
        const messageId = currentContextMessage.dataset.id;
        
        // Сохраняем состояние ответа в БД для текущего чата
        await eel.save_reply_state(
            localStorage.getItem('user_id'),
            currentChatUserId,
            messageId
        )();
        
        // Устанавливаем ID сообщения, на которое отвечаем
        replyContainer.dataset.messageId = messageId;
        
        replyContainer.innerHTML = `
            <div class="reply-header">
                <div class="reply-author">${isMyMessage ? 'Вы' : document.getElementById('chat-username').textContent}</div>
                <div class="reply-close">×</div>
            </div>
            <div class="reply-text">${messageText.length > 50 ? messageText.substring(0, 47) + '...' : messageText}</div>
        `;
        
        replyContainer.classList.remove('hidden');
        document.querySelector('.message-input-container').classList.add('expanded');
        
        // Обработчик закрытия ответа
        replyContainer.querySelector('.reply-close').addEventListener('click', async () => {
            replyContainer.classList.add('hidden');
            document.querySelector('.message-input-container').classList.remove('expanded');
            // Очищаем состояние ответа в БД для текущего чата
            await eel.clear_reply_state(localStorage.getItem('user_id'), currentChatUserId)();
        });
        
        const messageInput = document.getElementById('message-input');
        messageInput.focus();
        
    } catch (error) {
        console.error('Ошибка при обработке ответа:', error);
    }
}






    function handleEdit() {
        if (!currentContextMessage) {
            messageContextMenu.classList.add('hidden');
            return;
        }
        
        try {
            const messageId = currentContextMessage.dataset.id;
            const messageTextElement = currentContextMessage.querySelector('.message-text');
            const originalText = messageTextElement.textContent;
            
            // Создаем поле ввода для редактирования
            const input = document.createElement('input');
            input.type = 'text';
            input.value = originalText;
            input.className = 'edit-message-input';
            
            // Заменяем текст на поле ввода
            messageTextElement.replaceWith(input);
            input.focus();
            
            // Функция завершения редактирования
            const finishEditing = async (newText) => {
                if (newText && newText !== originalText) {
                    const result = await eel.edit_message(messageId, newText)();
                    if (!result.success) {
                        throw new Error(result.message || 'Не удалось изменить сообщение');
                    }
                    return newText;
                }
                return originalText;
            };
            
            // Обработчики событий
            const handleKeyDown = async (e) => {
                if (e.key === 'Enter') {
                    const newText = input.value.trim();
                    try {
                        const finalText = await finishEditing(newText);
                        messageTextElement.textContent = finalText;
                    } catch (error) {
                        alert(error.message);
                        messageTextElement.textContent = originalText;
                    }
                    cleanup();
                } else if (e.key === 'Escape') {
                    messageTextElement.textContent = originalText;
                    cleanup();
                }
            };
            
            const handleBlur = async () => {
                const newText = input.value.trim();
                try {
                    const finalText = await finishEditing(newText);
                    messageTextElement.textContent = finalText;
                } catch (error) {
                    alert(error.message);
                    messageTextElement.textContent = originalText;
                }
                cleanup();
            };
            
            const cleanup = () => {
                input.replaceWith(messageTextElement);
                input.removeEventListener('keydown', handleKeyDown);
                input.removeEventListener('blur', handleBlur);
                messageContextMenu.classList.add('hidden');
            };
            
            input.addEventListener('keydown', handleKeyDown);
            input.addEventListener('blur', handleBlur);
            
        } catch (error) {
            console.error('Ошибка при редактировании:', error);
            alert('Ошибка при редактировании сообщения');
            messageContextMenu.classList.add('hidden');
        }
    }

    function handlePin() {
        alert('Функция "Закрепить" будет реализована в будущем');
        messageContextMenu.classList.add('hidden');
    }

    eel.expose(get_current_user_id);
function get_current_user_id() {
    return localStorage.getItem('user_id');
}





    function handleForward() {
        alert('Функция "Переслать" будет реализована в будущем');
        messageContextMenu.classList.add('hidden');
    }

    function handleCopy() {
        if (!currentContextMessage) {
            messageContextMenu.classList.add('hidden');
            return;
        }
        
        try {
            const messageText = currentContextMessage.querySelector('.message-text').textContent;
            navigator.clipboard.writeText(messageText)
                .then(() => {
                    console.log('Текст скопирован в буфер обмена');
                })
                .catch(err => {
                    console.error('Ошибка копирования:', err);
                    alert('Не удалось скопировать текст');
                });
        } catch (error) {
            console.error('Ошибка при копировании:', error);
            alert('Ошибка при копировании текста');
        } finally {
            messageContextMenu.classList.add('hidden');
        }
    }
}


function showMessageContextMenu(e) {
    const messageContextMenu = document.getElementById('message-context-menu');
    if (!messageContextMenu) return;
    
    messageContextMenu.classList.add('hidden');
    
    const menuWidth = messageContextMenu.offsetWidth;
    const menuHeight = messageContextMenu.offsetHeight;
    const windowWidth = window.innerWidth;
    const windowHeight = window.innerHeight;
    
    let left = e.clientX;
    let top = e.clientY;
    
    if (left + menuWidth > windowWidth) {
        left = windowWidth - menuWidth - 5;
    }
    
    if (top + menuHeight > windowHeight) {
        top = windowHeight - menuHeight - 5;
    }
    
    messageContextMenu.style.left = `${left}px`;
    messageContextMenu.style.top = `${top}px`;
    messageContextMenu.style.display = 'block';
    messageContextMenu.classList.remove('hidden');
    messageContextMenu.style.zIndex = '1000';
}

// Сделаем функцию глобально доступной
window.showMessageContextMenu = showMessageContextMenu;

// Вызов инициализации после загрузки DOM
document.addEventListener('DOMContentLoaded', function() {
    initMessageContextMenu();
});

function playZKVoiceMessage(audioBlob, voiceMessageElement, duration) {
    // Останавливаем текущее воспроизведение, если есть
    if (currentPlayingAudio) {
        currentPlayingAudio.pause();
        currentPlayingAudio = null;
        
        if (currentPlayingVoiceElement) {
            stopVoiceMessage(currentPlayingVoiceElement, true);
        }
    }

    // Устанавливаем класс playing для текущего элемента
    voiceMessageElement.classList.add('playing');
    voiceMessagePlaying = true;
    currentPlayingVoiceElement = voiceMessageElement;
    
    // Создаем URL для аудио blob
    const audioUrl = URL.createObjectURL(audioBlob);
    const audio = new Audio(audioUrl);
    currentPlayingAudio = audio;
    
    const playBtn = voiceMessageElement.querySelector('.play-voice-btn img');
    playBtn.src = 'https://png.klev.club/uploads/posts/2024-05/png-klev-club-uejr-p-ikonka-pauzi-png-30.png';
    
    const progressBar = voiceMessageElement.querySelector('.voice-progress');
    progressBar.style.display = 'block';
    progressBar.style.left = '0%';
    
    const timeElement = voiceMessageElement.querySelector('.voice-time');
    timeElement.dataset.duration = duration;
    
    // Функция обновления прогресса
    const updateProgress = () => {
        if (!voiceMessagePlaying) return;
        
        const currentPos = audio.currentTime;
        const progressPercent = (currentPos / duration) * 100;
        
        progressBar.style.left = `${progressPercent}%`;
        
        const bars = voiceMessageElement.querySelectorAll('.voice-bar');
        bars.forEach((bar, i) => {
            const barPos = (i / bars.length) * 100;
            if (barPos < progressPercent) {
                bar.style.opacity = '0.7';
            } else {
                bar.style.opacity = '0.3';
            }
        });
        
        timeElement.textContent = `${currentPos.toFixed(1)} / ${duration.toFixed(1)} сек.`;
        
        if (currentPos >= duration) {
            handleVoiceMessagePlayed(voiceMessageElement);
        } else if (voiceMessagePlaying) {
            requestAnimationFrame(updateProgress);
        }
    };
        
    // Обработчики событий аудио
    audio.addEventListener('ended', () => {
        handleVoiceMessagePlayed(voiceMessageElement);
    });
    
    audio.addEventListener('pause', () => {
        voiceMessagePlaying = false;
        const currentTime = audio.currentTime;
        const progressPercent = (currentTime / duration) * 100;
        progressBar.style.left = `${progressPercent}%`;
        timeElement.textContent = `${currentTime.toFixed(1)} / ${duration.toFixed(1)} сек.`;
        
        playBtn.src = 'https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTdnax9muCZwZsJujMzKiWx8tnQXgbwNaX39A&s';
    });
    
    audio.addEventListener('error', (e) => {
        console.error('Audio error:', e);
        stopVoiceMessage(voiceMessageElement, true);
        alert('Ошибка воспроизведения голосового сообщения');
        
        // Освобождаем URL
        URL.revokeObjectURL(audioUrl);
    });
    
    audio.addEventListener('canplaythrough', () => {
        // Запускаем воспроизведение когда аудио готово
        audio.play().then(() => {
            updateProgress();
        }).catch(error => {
            console.error('Ошибка воспроизведения:', error);
            stopVoiceMessage(voiceMessageElement, true);
            URL.revokeObjectURL(audioUrl);
        });
    });
    
    audio.addEventListener('load', () => {
        // Освобождаем URL после загрузки
        URL.revokeObjectURL(audioUrl);
    });
    
    // Обработчик для очистки при завершении
    const cleanup = () => {
        URL.revokeObjectURL(audioUrl);
        audio.removeEventListener('ended', cleanup);
        audio.removeEventListener('error', cleanup);
    };
    
    audio.addEventListener('ended', cleanup);
    audio.addEventListener('error', cleanup);
}











function handleVoiceMessagePlayed(voiceMessageElement) {
    const messageElement = voiceMessageElement.closest('.message');
    const messageId = messageElement?.dataset.id;
    const timeElement = voiceMessageElement.querySelector('.voice-time');
    const duration = parseFloat(timeElement.dataset.duration) || 0;
    
    // Скрываем ползунок
    const progressBar = voiceMessageElement.querySelector('.voice-progress');
    progressBar.style.display = 'none';
    
    timeElement.textContent = `${duration.toFixed(1)} сек.`;
    stopVoiceMessage(voiceMessageElement, true);
    
    const isMyMessage = messageElement.classList.contains('my-message');
    const indicator = voiceMessageElement.querySelector('.listen-indicator');
    
    // Для своих сообщений НЕ изменяем состояние индикатора
    if (!isMyMessage && indicator) {
        indicator.style.opacity = '0';
        
        // Сохраняем в localStorage, что сообщение прослушано
        if (messageId) {
            const listenedMessages = JSON.parse(localStorage.getItem('listenedVoiceMessages') || '{}');
            listenedMessages[messageId] = true;
            localStorage.setItem('listenedVoiceMessages', JSON.stringify(listenedMessages));
        }
    }
    
    // Обновляем состояние в кеше только для чужих сообщений
    if (!isMyMessage && currentChatUserId && activeChats[currentChatUserId]?.messagesData) {
        const messageIndex = activeChats[currentChatUserId].messagesData.findIndex(m => m.id === messageId);
        if (messageIndex !== -1) {
            activeChats[currentChatUserId].messagesData[messageIndex].listened = true;
        }
    }
    
    // Отправляем на сервер информацию о прослушивании (только для чужих сообщений)
    if (messageId && !isMyMessage) {
        const userId = localStorage.getItem('user_id');
        eel.mark_voice_message_as_listened(messageId, userId)();
    }
}

async function analyzeAudioAndCreateVisualization(audioBlob, duration) {
    try {
        // Создаем аудиоконтекст
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const arrayBuffer = await audioBlob.arrayBuffer();
        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
        
        // Получаем данные канала (берем первый канал)
        const channelData = audioBuffer.getChannelData(0);
        const sampleRate = audioBuffer.sampleRate;
        
        // Количество полосок
        const barsCount = 20;
        // Длительность одного сегмента в секундах
        const segmentDuration = duration / barsCount;
        // Количество семплов в одном сегменте
        const samplesPerSegment = Math.floor(segmentDuration * sampleRate);
        
        const visualizationData = [];
        
        // Анализируем каждый сегмент
        for (let i = 0; i < barsCount; i++) {
            const startSample = i * samplesPerSegment;
            const endSample = Math.min((i + 1) * samplesPerSegment, channelData.length);
            
            let maxAmplitude = 0;
            
            // Находим максимальную амплитуду в сегменте
            for (let j = startSample; j < endSample; j++) {
                const amplitude = Math.abs(channelData[j]);
                if (amplitude > maxAmplitude) {
                    maxAmplitude = amplitude;
                }
            }
            
            // Нормализуем значение от 0 до 1
            visualizationData.push(maxAmplitude);
        }
        
        return visualizationData;
    } catch (error) {
        console.error('Ошибка анализа аудио:', error);
        // Возвращаем массив нулей в случае ошибки
        return Array(20).fill(0);
    }
}



// Обработчики для пунктов меню
document.getElementById('message-reply').addEventListener('click', () => {
    if (currentContextMessage) {
        const messageText = currentContextMessage.querySelector('.message-text').textContent;
        const messageInput = document.getElementById('message-input');
        messageInput.value = `Ответ на: "${messageText}" `;
        messageInput.focus();
    }
    messageContextMenu.classList.add('hidden');
});

document.getElementById('message-edit').addEventListener('click', async () => {
    if (currentContextMessage) {
        const messageId = currentContextMessage.dataset.id;
        const messageText = currentContextMessage.querySelector('.message-text');
        const originalText = messageText.textContent;
        
        // Создаем поле ввода для редактирования
        const input = document.createElement('input');
        input.type = 'text';
        input.value = originalText;
        input.className = 'edit-message-input';
        
        // Заменяем текст на поле ввода
        messageText.replaceWith(input);
        input.focus();
        
        // Обработчик завершения редактирования
        const handleEdit = async (e) => {
            if (e.key === 'Enter' || e.type === 'blur') {
                const newText = input.value.trim();
                if (newText && newText !== originalText) {
                    try {
                        const result = await eel.edit_message(messageId, newText)();
                        if (result.success) {
                            messageText.textContent = newText;
                        } else {
                            alert(result.message);
                            messageText.textContent = originalText;
                        }
                    } catch (error) {
                        console.error('Ошибка редактирования:', error);
                        messageText.textContent = originalText;
                    }
                } else {
                    messageText.textContent = originalText;
                }
                
                input.replaceWith(messageText);
                input.removeEventListener('keydown', handleEdit);
                input.removeEventListener('blur', handleEdit);
            } else if (e.key === 'Escape') {
                messageText.textContent = originalText;
                input.replaceWith(messageText);
                input.removeEventListener('keydown', handleEdit);
                input.removeEventListener('blur', handleEdit);
            }
        };
        
        input.addEventListener('keydown', handleEdit);
        input.addEventListener('blur', handleEdit);
    }
    messageContextMenu.classList.add('hidden');
});

document.getElementById('message-pin').addEventListener('click', () => {
    if (currentContextMessage) {
        alert('Функция "Закрепить" будет реализована в будущем');
    }
    messageContextMenu.classList.add('hidden');
});

document.getElementById('message-delete').addEventListener('click', async () => {
    if (currentContextMessage) {
        if (confirm('Вы уверены, что хотите удалить это сообщение?')) {
            const messageId = currentContextMessage.dataset.id;
            try {
                const result = await eel.delete_message(messageId)();
                if (result.success) {
                    currentContextMessage.remove();
                } else {
                    alert(result.message);
                }
            } catch (error) {
                console.error('Ошибка удаления:', error);
                alert('Ошибка при удалении сообщения');
            }
        }
    }
    messageContextMenu.classList.add('hidden');
});

document.getElementById('message-forward').addEventListener('click', () => {
    if (currentContextMessage) {
        alert('Функция "Переслать" будет реализована в будущем');
    }
    messageContextMenu.classList.add('hidden');
});

document.getElementById('message-copy').addEventListener('click', () => {
    if (currentContextMessage) {
        const messageText = currentContextMessage.querySelector('.message-text').textContent;
        navigator.clipboard.writeText(messageText)
            .then(() => {
                // Можно добавить уведомление о успешном копировании
                console.log('Текст скопирован');
            })
            .catch(err => {
                console.error('Ошибка копирования:', err);
            });
    }
    messageContextMenu.classList.add('hidden');
});

// Стиль для поля редактирования
const style = document.createElement('style');
style.textContent = `
    .edit-message-input {
        width: 100%;
        padding: 5px;
        border: 1px solid #4CAF50;
        border-radius: 4px;
        font-size: 14px;
    }
`;
document.head.appendChild(style);  

function stopVoiceMessage(voiceMessageElement = null, reset = false) {
    if (!voiceMessageElement) {
        voiceMessageElement = currentPlayingVoiceElement;
    }
    
    if (currentPlayingAudio) {
        currentPlayingAudio.pause();
        if (reset) {
            currentPlayingAudio.currentTime = 0;
            currentPlayingAudio = null;
        }
        voiceMessagePlaying = false;
    }
    
    if (voiceMessageElement) {
        voiceMessageElement.classList.remove('playing');
        const playBtn = voiceMessageElement.querySelector('.play-voice-btn img');
        playBtn.src = 'https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTdnax9muCZwZsJujMzKiWx8tnQXgbwNaX39A&s';
        
        const timeElement = voiceMessageElement.querySelector('.voice-time');
        const duration = parseFloat(timeElement.dataset.duration) || 0;
        const progressBar = voiceMessageElement.querySelector('.voice-progress');
        
        if (reset) {
            progressBar.style.display = 'none';
            timeElement.textContent = `${duration.toFixed(1)} сек.`;
            currentPlayingVoiceElement = null;
        } else {
            // При паузе сохраняем текущее состояние прогресса
            const currentTime = currentPlayingAudio?.currentTime || 0;
            const progressPercent = (currentTime / duration) * 100;
            progressBar.style.left = `${progressPercent}%`;
            timeElement.textContent = `${currentTime.toFixed(1)} / ${duration.toFixed(1)} сек.`;
        }
    }
}

// Обработчики для меню фото
const photoBtn = document.getElementById('photo-message-btn');
const photoOptionsMenu = document.getElementById('photo-options-menu');
const fileInput = document.getElementById('file-input');
const mediaSendModal = document.getElementById('media-send-modal');
const mediaSendOverlay = document.getElementById('media-send-overlay');
const mediaSendTitle = document.getElementById('media-send-title');
const imagePreview = document.getElementById('image-preview');
const videoPreview = document.getElementById('video-preview');
const mediaCaptionInput = document.getElementById('media-caption-input');
const mediaAddButton = document.getElementById('media-add-button');
const mediaCancelButton = document.getElementById('media-cancel-button');
const mediaSendButton = document.getElementById('media-send-button');

let currentMediaType = 'photo';
let photoMenuTimeout;

// Показываем меню при наведении на кнопку
photoBtn.addEventListener('mouseenter', () => {
    clearTimeout(photoMenuTimeout);
    positionPhotoMenu();
    photoOptionsMenu.classList.remove('hidden');
    photoOptionsMenu.classList.add('show');
});

// Скрываем меню при уходе с кнопки (с задержкой)
photoBtn.addEventListener('mouseleave', () => {
    photoMenuTimeout = setTimeout(() => {
        photoOptionsMenu.classList.remove('show');
    }, 200);
});

// Отменяем скрытие при наведении на меню
photoOptionsMenu.addEventListener('mouseenter', () => {
    clearTimeout(photoMenuTimeout);
});

// Скрываем меню при уходе с него
photoOptionsMenu.addEventListener('mouseleave', () => {
    photoOptionsMenu.classList.remove('show');
});

// Обработчики для кнопок меню
document.querySelectorAll('.photo-option').forEach(option => {
    option.addEventListener('click', function() {
        const type = this.dataset.type;
        if (type === 'photo-video') {
            openFileSelector();
        } else {
            alert(`Выбрана опция: ${this.querySelector('span').textContent}`);
        }
        photoOptionsMenu.classList.remove('show');
    });
});

function openFileSelector() {
    const fileInput = document.getElementById('file-input');
    if (fileInput) {
        fileInput.value = '';
        fileInput.setAttribute('multiple', 'multiple');
        fileInput.click();
    }
}

function handleFileSelect(e) {
    const files = Array.from(e.target.files);
    const MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB
    const MAX_TOTAL_SIZE = 50 * 1024 * 1024; // 50MB
    
    // Проверяем размер отдельных файлов
    const oversizedFiles = files.filter(file => file.size > MAX_FILE_SIZE);
    if (oversizedFiles.length > 0) {
        alert(`Следующие файлы превышают максимальный размер 10MB: ${oversizedFiles.map(f => f.name).join(', ')}`);
        return;
    }
    
    // Проверяем общий размер
    const totalSize = files.reduce((sum, file) => sum + file.size, 0);
    if (totalSize > MAX_TOTAL_SIZE) {
        alert(`Общий размер файлов превышает ${MAX_TOTAL_SIZE / 1024 / 1024}MB`);
        return;
    }

    // Проверяем общее количество файлов
    if (selectedFiles.length + files.length > MAX_FILES) {
        alert(`Можно добавить не более ${MAX_FILES} файлов. У вас уже ${selectedFiles.length} файлов.`);
        return;
    }
    
    // Добавляем только новые, не дублирующиеся файлы
    let newFilesAdded = 0;
    files.forEach(file => {
        if (!isFileDuplicate(file, selectedFiles) && selectedFiles.length + newFilesAdded < MAX_FILES) {
            selectedFiles.push(file);
            newFilesAdded++;
        }
    });
    
    // Обновляем превью только если были добавлены новые файлы
    if (newFilesAdded > 0) {
        updateMediaPreview();
        
        // Показываем модальное окно, если оно скрыто
        if (mediaSendOverlay.classList.contains('hidden')) {
            mediaSendOverlay.classList.remove('hidden');
            mediaSendModal.classList.remove('hidden');
        }
        
        // Обновляем заголовок
        updateMediaTitle();
    }
    
    // Сбрасываем значение input, чтобы можно было выбрать те же файлы снова
    e.target.value = '';
}


function isFileDuplicate(newFile, existingFiles) {
    return existingFiles.some(existingFile => 
        existingFile.name === newFile.name &&
        existingFile.size === newFile.size &&
        existingFile.type === newFile.type &&
        existingFile.lastModified === newFile.lastModified
    );
}



function updateMediaPreview() {
    const previewGrid = document.getElementById('media-preview-grid');
    previewGrid.innerHTML = '';
    
    selectedFiles.forEach((file, index) => {
        const previewItem = createPreviewItem(file, index);
        previewGrid.appendChild(previewItem);
    });
    
    // Обновляем индикатор количества
    updateCountIndicator();
}


function createPreviewItem(file, index) {
    const previewItem = document.createElement('div');
    previewItem.className = 'media-preview-item';
    previewItem.title = `${file.name} (${formatFileSize(file.size)})`;
    
    const isVideo = file.type.startsWith('video/');
    const mediaType = isVideo ? 'video' : 'image';
    
    if (isVideo) {
        const video = document.createElement('video');
        video.src = URL.createObjectURL(file);
        video.controls = false;
        video.muted = true;
        previewItem.appendChild(video);
    } else {
        const img = document.createElement('img');
        img.src = URL.createObjectURL(file);
        previewItem.appendChild(img);
    }
    
    // Индикатор типа медиа
    const typeIndicator = document.createElement('div');
    typeIndicator.className = 'media-type-indicator';
    typeIndicator.textContent = isVideo ? 'VIDEO' : 'IMG';
    previewItem.appendChild(typeIndicator);
    
    // Кнопка удаления
    const removeBtn = document.createElement('button');
    removeBtn.className = 'remove-media';
    removeBtn.textContent = '×';
    removeBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        removeFile(index);
    });
    previewItem.appendChild(removeBtn);
    
    return previewItem;
}


function removeFile(index) {
    selectedFiles.splice(index, 1);
    updateMediaPreview();
    updateMediaTitle();
}


function updateMediaTitle() {
    const title = document.getElementById('media-send-title');
    const fileCount = selectedFiles.length;
    
    if (fileCount === 0) {
        title.textContent = 'Отправить медиа';
    } else {
        const imageCount = selectedFiles.filter(f => f.type.startsWith('image/')).length;
        const videoCount = selectedFiles.filter(f => f.type.startsWith('video/')).length;
        
        let typeText = '';
        if (imageCount > 0 && videoCount > 0) {
            typeText = `${imageCount} фото, ${videoCount} видео`;
        } else if (imageCount > 0) {
            typeText = `${imageCount} фото`;
        } else if (videoCount > 0) {
            typeText = `${videoCount} видео`;
        }
        
        title.innerHTML = `Отправить медиа <span style="font-size: 14px; color: #666;">(${typeText})</span>`;
    }
}

function updateCountIndicator() {
    let countIndicator = document.getElementById('media-count-indicator');
    
    if (!countIndicator) {
        countIndicator = document.createElement('div');
        countIndicator.id = 'media-count-indicator';
        countIndicator.className = 'media-count-indicator';
        mediaSendModal.insertBefore(countIndicator, mediaSendModal.querySelector('.media-caption-input'));
    }
    
    if (selectedFiles.length > 0) {
        countIndicator.textContent = `Выбрано файлов: ${selectedFiles.length}/${MAX_FILES}`;
        countIndicator.style.display = 'block';
    } else {
        countIndicator.style.display = 'none';
    }
}


async function sendAllMedia() {
    if (selectedFiles.length === 0) {
        alert('Пожалуйста, выберите файлы для отправки');
        return;
    }
    
    const caption = document.getElementById('media-caption-input').value.trim();
    
    try {
        // Показываем индикатор загрузки
        showMediaUploadProgress(`Подготовка ${selectedFiles.length} файлов...`, 0);
        
        let successCount = 0;
        let failedFiles = [];
        
        // Отправляем файлы последовательно с ограничением
        for (let i = 0; i < selectedFiles.length; i++) {
            const file = selectedFiles[i];
            
            // Проверяем размер файла перед отправкой
            if (file.size > 5 * 1024 * 1024) { // 5MB предупреждение
                if (!confirm(`Файл "${file.name}" довольно большой (${(file.size / 1024 / 1024).toFixed(1)}MB). Продолжить отправку?`)) {
                    failedFiles.push({file: file.name, reason: 'Пользователь отменил'});
                    continue;
                }
            }
            
            // Передаем caption только для первого файла
            const fileCaption = (i === 0 && caption) ? caption : '';
            
            console.log(`Отправка файла ${i + 1}/${selectedFiles.length}:`, file.name);
            
            // Обновляем прогресс
            updateMediaUploadProgress(`Отправка: ${file.name} (${i + 1}/${selectedFiles.length})`, 
                (i / selectedFiles.length) * 100);
            
            try {
                const success = await sendZKMediaMessage(file, fileCaption);
                if (success) {
                    successCount++;
                } else {
                    failedFiles.push({file: file.name, reason: 'Ошибка отправки'});
                }
            } catch (error) {
                console.error(`Ошибка отправки файла ${file.name}:`, error);
                failedFiles.push({file: file.name, reason: error.message});
            }
            
            // Задержка между отправками для уменьшения нагрузки
            if (i < selectedFiles.length - 1) {
                await new Promise(resolve => setTimeout(resolve, 1000));
            }
        }
        
        hideMediaUploadProgress();
        
        // Показываем результаты отправки
        if (successCount > 0) {
            if (successCount === selectedFiles.length) {
                alert(`✅ Все ${successCount} файлов успешно отправлены`);
            } else {
                let message = `✅ Отправлено ${successCount} из ${selectedFiles.length} файлов`;
                if (failedFiles.length > 0) {
                    message += `\n❌ Не отправлено: ${failedFiles.map(f => f.file).join(', ')}`;
                }
                alert(message);
            }
            closeMediaModal(); // ВАЖНО: закрываем модальное окно при успехе
        } else {
            let errorMessage = '❌ Не удалось отправить ни один файл';
            if (failedFiles.length > 0) {
                errorMessage += `\nПричины: ${failedFiles.map(f => `${f.file} (${f.reason})`).join(', ')}`;
            }
            alert(errorMessage);
            // Не закрываем модальное окно при ошибке, чтобы пользователь мог попробовать снова
        }
        
    } catch (error) {
        console.error('Ошибка отправки файлов:', error);
        hideMediaUploadProgress();
        alert('Критическая ошибка при отправке файлов: ' + error.message);
    }
}

async function sendZKMediaMessage(file, caption = '') {
    if (!currentChatUserId || !userEncryptionKey) {
        throw new Error('Система безопасности не инициализирована');
    }
    
    try {
        // Показываем индикатор загрузки
        showMediaUploadProgress(`Шифрование: ${file.name}`, 10);
        
        // Ограничиваем размер файла
        const MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB
        if (file.size > MAX_FILE_SIZE) {
            hideMediaUploadProgress();
            alert(`Файл слишком большой. Максимальный размер: ${MAX_FILE_SIZE / 1024 / 1024}MB`);
            return false;
        }
        
        console.log('Начало шифрования файла:', file.name, 'размер:', file.size);
        
        // Обновляем прогресс
        updateMediaUploadProgress(`Шифрование: ${file.name}`, 30);
        
        // Шифруем файл с обработкой ошибок
        let encryptedMediaData;
        try {
            encryptedMediaData = await zkCrypto.encryptFile(file, userEncryptionKey);
        } catch (encryptError) {
            console.error('Ошибка шифрования:', encryptError);
            throw new Error(`Ошибка шифрования файла: ${encryptError.message}`);
        }
        
        console.log('Файл зашифрован, отправка на сервер...');
        
        // Обновляем прогресс
        updateMediaUploadProgress(`Отправка: ${file.name}`, 70);
        
        const fileType = file.type.startsWith('video/') ? 'video' : 'image';
        
        const result = await eel.send_media_message(
            localStorage.getItem('user_id'),
            currentChatUserId,
            encryptedMediaData,
            fileType,
            file.name,
            caption
        )();
        
        if (result.success) {
            console.log('Файл успешно отправлен');
            
            // Добавляем сообщение в чат
            const message = {
                id: result.message_id,
                sender_id: localStorage.getItem('user_id'),
                receiver_id: currentChatUserId,
                text: caption || (fileType === 'video' ? '[Видео]' : '[Фото]'),
                timestamp: result.timestamp,
                read: result.read,
                isMedia: true,
                mediaType: fileType,
                is_encrypted: true
            };
            
            await addMessageToChat(message, true, true);
            lastMessageId = message.id;
            
            // Обновляем кеш активного чата
            if (activeChats[currentChatUserId]) {
                const messagesContainer = document.getElementById('chat-messages');
                activeChats[currentChatUserId].messages = messagesContainer.innerHTML;
                activeChats[currentChatUserId].lastMessageId = lastMessageId;
                
                if (!activeChats[currentChatUserId].messagesData) {
                    activeChats[currentChatUserId].messagesData = [];
                }
                
                activeChats[currentChatUserId].messagesData.push({
                    id: message.id,
                    isMedia: true,
                    mediaType: fileType,
                    text: message.text,
                    filename: file.name
                });
            }
            
            // Обновляем последнее сообщение на карточке (только для первого файла)
            if (selectedFiles.length > 0 && file === selectedFiles[0]) {
                updateLastMessageOnUserCard(
                    currentChatUserId, 
                    selectedFiles.length > 1 ? `${selectedFiles.length} медиа` : (fileType === 'video' ? 'Видео' : 'Фото'), 
                    true
                );
            }
            
            // Обновляем прогресс до 100% и скрываем
            updateMediaUploadProgress(file.name, 100);
            setTimeout(hideMediaUploadProgress, 1000);
            
            return true;
        } else {
            throw new Error(result.message || 'Ошибка при отправке файла');
        }
    } catch (error) {
        console.error('Error sending ZK media message:', error);
        hideMediaUploadProgress();
        
        if (error.message && error.message.includes('File too large')) {
            alert('Файл слишком большой. Максимальный размер: 10MB');
        } else if (error.message.includes('Maximum call stack')) {
            alert('Файл слишком большой для обработки. Попробуйте файл меньшего размера.');
        } else {
            alert('Ошибка при отправке файла: ' + (error.message || 'Неизвестная ошибка'));
        }
        return false;
    }
}   




mediaCancelButton.addEventListener('click', closeMediaModal);
mediaSendOverlay.addEventListener('click', closeMediaModal);

function closeMediaModal() {
    const mediaSendOverlay = document.getElementById('media-send-overlay');
    const mediaSendModal = document.getElementById('media-send-modal');
    
    if (mediaSendOverlay) mediaSendOverlay.classList.add('hidden');
    if (mediaSendModal) mediaSendModal.classList.add('hidden');
    
    // Очищаем выбранные файлы
    selectedFiles = [];
    const mediaCaptionInput = document.getElementById('media-caption-input');
    if (mediaCaptionInput) mediaCaptionInput.value = '';
    
    // Сбрасываем input file
    const fileInput = document.getElementById('file-input');
    if (fileInput) {
        fileInput.value = '';
        fileInput.removeAttribute('multiple');
    }
    
    // Очищаем превью
    const previewGrid = document.getElementById('media-preview-grid');
    if (previewGrid) previewGrid.innerHTML = '';
    
    // Сбрасываем заголовок
    const title = document.getElementById('media-send-title');
    if (title) title.textContent = 'Отправить медиа';
}



function formatMessageDate(timestamp) {
    const messageDate = new Date(timestamp);
    const today = new Date();
    const yesterday = new Date(today);
    yesterday.setDate(yesterday.getDate() - 1);
    const twoDaysAgo = new Date(today);
    twoDaysAgo.setDate(twoDaysAgo.getDate() - 2);
    
    // Сбрасываем время для сравнения только дат
    const messageDateOnly = new Date(messageDate.getFullYear(), messageDate.getMonth(), messageDate.getDate());
    const todayOnly = new Date(today.getFullYear(), today.getMonth(), today.getDate());
    const yesterdayOnly = new Date(yesterday.getFullYear(), yesterday.getMonth(), yesterday.getDate());
    const twoDaysAgoOnly = new Date(twoDaysAgo.getFullYear(), twoDaysAgo.getMonth(), twoDaysAgo.getDate());
    
    if (messageDateOnly.getTime() === todayOnly.getTime()) {
        return 'Сегодня';
    } else if (messageDateOnly.getTime() === yesterdayOnly.getTime()) {
        return 'Вчера';
    } else if (messageDateOnly.getTime() === twoDaysAgoOnly.getTime()) {
        return 'Позавчера';
    } else {
        // Проверяем, была ли дата на этой неделе
        const startOfWeek = new Date(today);
        startOfWeek.setDate(today.getDate() - today.getDay());
        startOfWeek.setHours(0, 0, 0, 0);
        
        if (messageDate >= startOfWeek) {
            // Возвращаем день недели
            const days = ['Воскресенье', 'Понедельник', 'Вторник', 'Среда', 'Четверг', 'Пятница', 'Суббота'];
            return days[messageDate.getDay()];
        } else {
            // Форматируем полную дату
            const months = [
                'января', 'февраля', 'марта', 'апреля', 'мая', 'июня',
                'июля', 'августа', 'сентября', 'октября', 'ноября', 'декабря'
            ];
            return `${messageDate.getDate()} ${months[messageDate.getMonth()]} ${messageDate.getFullYear()}`;
        }
    }
}


function createDateHeader(dateText, dateKey) {
    const dateHeader = document.createElement('div');
    dateHeader.className = 'date-header';
    dateHeader.dataset.dateKey = dateKey;
    
    const dateContent = document.createElement('div');
    dateContent.className = 'date-header-content';
    dateContent.textContent = dateText;
    
    dateHeader.appendChild(dateContent);
    return dateHeader;
}

function addDateHeaderToMessage(messageElement, timestamp) {
    const dateKey = new Date(timestamp).toDateString(); // Уникальный ключ для каждой даты
    const dateText = formatMessageDate(timestamp);
    
    // Если заголовок для этой даты уже существует, не создаем новый
    if (dateHeaders.has(dateKey)) {
        return;
    }
    
    const dateHeader = createDateHeader(dateText, dateKey);
    dateHeaders.set(dateKey, dateHeader);
    
    // Вставляем заголовок перед сообщением
    const messagesContainer = document.getElementById('chat-messages');
    messagesContainer.insertBefore(dateHeader, messageElement);
}


function updateStickyDateHeaders() {
    const messagesWrapper = document.getElementById('chat-messages-wrapper');
    if (!messagesWrapper) return;
    
    const scrollTop = messagesWrapper.scrollTop;
    const dateHeaderElements = Array.from(document.querySelectorAll('.date-header'));
    
    let newStickyDate = null;
    
    // Находим текущий активный заголовок (последний видимый в верхней части)
    for (let i = dateHeaderElements.length - 1; i >= 0; i--) {
        const header = dateHeaderElements[i];
        const rect = header.getBoundingClientRect();
        const messagesWrapperRect = messagesWrapper.getBoundingClientRect();
        
        // Если заголовок находится в верхней части видимой области
        if (rect.top <= messagesWrapperRect.top + 60 && rect.bottom > messagesWrapperRect.top) {
            newStickyDate = header;
            break;
        }
    }
    
    // Если не нашли заголовок в видимой области, берем первый
    if (!newStickyDate && dateHeaderElements.length > 0) {
        newStickyDate = dateHeaderElements[0];
    }
    
    // Сбрасываем все sticky классы
    dateHeaderElements.forEach(header => {
        header.classList.remove('sticky');
    });
    
    // Устанавливаем новый sticky заголовок
    if (newStickyDate && newStickyDate !== currentStickyDate) {
        newStickyDate.classList.add('sticky');
        currentStickyDate = newStickyDate;
    } else if (!newStickyDate) {
        currentStickyDate = null;
    }
}




function initDateHeadersSystem() {
    const messagesWrapper = document.getElementById('chat-messages-wrapper');
    if (!messagesWrapper) return;
    
    // Обработчик прокрутки
    messagesWrapper.addEventListener('scroll', updateStickyDateHeaders);
    
    // Intersection Observer для отслеживания видимости заголовков
    dateHeadersObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                // Если заголовок становится полностью видимым, снимаем sticky
                if (entry.target.classList.contains('sticky')) {
                    entry.target.classList.remove('sticky');
                }
            }
        });
    }, {
        root: messagesWrapper,
        threshold: 1.0
    });
    
    // Наблюдаем за всеми заголовками
    document.querySelectorAll('.date-header').forEach(header => {
        dateHeadersObserver.observe(header);
    });
}



function sendMedia() {
    if (selectedFiles.length === 0) {
        alert('Пожалуйста, выберите файл');
        return;
    }
    
    const caption = mediaCaptionInput.value.trim();
    const file = selectedFiles[0];
    
    console.log('Отправка файла:', file, 'с текстом:', caption);
    
    closeMediaModal();
}

document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape' && !mediaSendOverlay.classList.contains('hidden')) {
        closeMediaModal();
    }
});




// Позиционируем меню относительно кнопки
function positionPhotoMenu() {
    const rect = photoBtn.getBoundingClientRect();
    photoOptionsMenu.style.left = `${rect.left}px`;
    photoOptionsMenu.style.bottom = `${window.innerHeight - rect.top + 10}px`;
}

// Обновляем позицию при изменении размера окна
window.addEventListener('resize', positionPhotoMenu);






    const KEY_STORAGE_KEY = 'user_encryption_key';
    const KEY_EXPIRY_TIME = 24 * 60 * 60 * 1000; // 24 часа

async function initializeZKSystem() {
    try {
        const user_id = localStorage.getItem('user_id');
        if (!user_id) {
            console.log('User ID not found in localStorage');
            return false;
        }

        // Получаем пароль из sessionStorage
        let userPassword = sessionStorage.getItem('user_password');
        if (!userPassword) {
            console.log('Password not found in sessionStorage');
            return false;
        }

        // Получаем соль из localStorage
        const storedSalt = localStorage.getItem('user_salt');
        if (!storedSalt) {
            console.log('Salt not found in localStorage');
            return false;
        }

        console.log('Password length:', userPassword.length);
        console.log('Salt (base64):', storedSalt);

        // Конвертируем соль из base64
        const saltBytes = Uint8Array.from(atob(storedSalt), c => c.charCodeAt(0));
        console.log('Salt bytes length:', saltBytes.length);
        
        // Генерируем ключ из пароля и соли
        console.log('Generating encryption key...');
        userEncryptionKey = await ZKEncryption.deriveKey(userPassword, saltBytes);
        console.log('Encryption key generated successfully');
        
        // Тестируем ключ
        console.log('Testing encryption key...');
        const testResult = await testEncryptionKey();
        if (!testResult) {
            console.error('Encryption key test failed');
            return false;
        }

        console.log('ZK система инициализирована успешно');
        return true;
        
    } catch (error) {
        console.error('Error initializing ZK system:', error);
        return false;
    }
}



async function testEncryptionKey() {
    try {
        const testText = "test message";
        console.log('Testing encryption key with text:', testText);
        
        // Шифруем тестовое сообщение - используем ZKEncryption, а не zkCrypto
        const encrypted = await ZKEncryption.encryptText(testText, userEncryptionKey);
        console.log('Text encrypted successfully');
        
        // Дешифруем обратно
        const decrypted = await ZKEncryption.decryptText(encrypted, userEncryptionKey);
        console.log('Text decrypted successfully:', decrypted);
        
        const result = decrypted === testText;
        console.log('Key test result:', result);
        
        return result;
    } catch (error) {
        console.error('Key test failed:', error);
        return false;
    }
}

    async function requestPasswordAndInitialize() {
        try {
            const userPassword = prompt("Введите ваш пароль для расшифровки сообщений:");
            if (!userPassword) {
                alert("Пароль обязателен для работы мессенджера");
                return false;
            }
            
            const success = await initializeUserKey(userPassword);
            if (success) {
                // Сохраняем ключ в localStorage
                await saveEncryptionKey();
                return true;
            }
            return false;
            
        } catch (error) {
            console.error('Error in password initialization:', error);
            return false;
        }
    }

    async function saveEncryptionKey() {
        try {
            if (!userEncryptionKey) return false;
            
            // Экспортируем ключ в raw формат
            const exportedKey = await crypto.subtle.exportKey('raw', userEncryptionKey);
            const keyBytes = new Uint8Array(exportedKey);
            const keyBase64 = btoa(String.fromCharCode(...keyBytes));
            
            const keyData = {
                userId: localStorage.getItem('user_id'),
                key: keyBase64,
                timestamp: Date.now()
            };
            
            localStorage.setItem(KEY_STORAGE_KEY, JSON.stringify(keyData));
            return true;
            
        } catch (error) {
            console.error('Error saving encryption key:', error);
            return false;
        }
    }

    async function initializeUserKey(password) {
        try {
            const user_id = localStorage.getItem('user_id');
            if (!user_id) {
                throw new Error('User ID not found');
            }

            // Получаем соль с сервера
            const saltResponse = await eel.get_user_salt(user_id)();
            if (!saltResponse.success) {
                throw new Error('Не удалось получить соль пользователя');
            }

            // Конвертируем соль
            const saltBytes = Uint8Array.from(atob(saltResponse.salt), c => c.charCodeAt(0));
            
            // Генерируем ключ с помощью Web Crypto API
            const encoder = new TextEncoder();
            const keyMaterial = await crypto.subtle.importKey(
                'raw',
                encoder.encode(password),
                'PBKDF2',
                false,
                ['deriveKey']
            );

            userEncryptionKey = await crypto.subtle.deriveKey(
                {
                    name: 'PBKDF2',
                    salt: saltBytes,
                    iterations: 100000,
                    hash: 'SHA-256'
                },
                keyMaterial,
                { name: 'AES-GCM', length: 256 },
                false,
                ['encrypt', 'decrypt']
            );

            // Тестируем ключ
            const testResult = await testEncryptionKey();
            if (!testResult) {
                throw new Error('Ключ не прошел проверку');
            }

            console.log('ZK система инициализирована успешно');
            return true;
            
        } catch (error) {
            console.error('Error initializing user key:', error);
            userEncryptionKey = null;
            return false;
        }
    }





async function sendZKMessage(text) {
    if (!currentChatUserId || !text || !userEncryptionKey) return;
    
    try {
        // Шифруем сообщение - используем ZKEncryption
        const encryptedText = await ZKEncryption.encryptText(text, userEncryptionKey);
        
        const result = await eel.send_message(
            localStorage.getItem('user_id'),
            currentChatUserId,
            encryptedText
        )();
        
        if (result.success) {
            // Добавляем сообщение в чат (расшифрованное, т.к. это наше сообщение)
            const message = {
                id: result.message_id,
                sender_id: localStorage.getItem('user_id'),
                receiver_id: currentChatUserId,
                text: text,
                timestamp: result.timestamp,
                read: result.read,
                is_encrypted: true
            };
            
            await addMessageToChat(message, true, true);
            lastMessageId = message.id;
            
            // Обновляем UI
            updateLastMessageOnUserCard(currentChatUserId, text, true);
            
            // Очищаем поле ввода
            document.getElementById('message-input').value = '';
        }
    } catch (error) {
        console.error('Error sending ZK message:', error);
    }
}


async function loadZKChatHistory(userId) {
    try {
        const messages = await eel.get_chat_history(localStorage.getItem('user_id'), userId)();
        const messagesContainer = document.getElementById('chat-messages');
        messagesContainer.innerHTML = '';

        dateHeaders.clear();
        currentStickyDate = null;
        if (dateHeadersObserver) {
            dateHeadersObserver.disconnect();
            dateHeadersObserver = null;
        }

        if (messages && Array.isArray(messages) && messages.length > 0) {
            messages.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
            
            let currentDateKey = null;
            
            for (const msg of messages) {
                let displayText = msg.text || '[Сообщение]';
                let isEncrypted = false;
                
                // Обрабатываем зашифрованные сообщения
                if (msg.is_encrypted && msg.encrypted_text && userEncryptionKey) {
                    isEncrypted = true;
                    try {
                        // Пропускаем слишком длинные зашифрованные тексты (вероятно бинарные данные медиа)
                        if (msg.encrypted_text.length > 100000) {
                            if (msg.is_media) {
                                displayText = msg.media_type === 'video' ? '[Видео]' : '[Фото]';
                            } else if (msg.is_voice) {
                                displayText = '[Голосовое сообщение]';
                            } else {
                                displayText = '[Зашифрованное сообщение]';
                            }
                        } else {
                            const decryptedText = await zkCrypto.decryptText(msg.encrypted_text, userEncryptionKey);
                            displayText = decryptedText;
                        }
                    } catch (error) {
                        console.error('Failed to decrypt message:', error);
                        // Для медиафайлов показываем специальный текст
                        if (msg.is_media) {
                            displayText = msg.media_type === 'video' ? '[Видео]' : '[Фото]';
                        } else if (msg.is_voice) {
                            displayText = '[Голосовое сообщение]';
                        } else {
                            displayText = '[Не удалось расшифровать]';
                        }
                    }
                }
                
                const isMyMessage = msg.sender_id === localStorage.getItem('user_id');
                const messageWithText = {
                    ...msg,
                    text: displayText,
                    isMedia: msg.is_media,
                    isVoiceMessage: msg.is_voice,
                    mediaType: msg.media_type,
                    duration: msg.duration,
                    is_encrypted: isEncrypted
                };
                
                // Проверяем, нужно ли добавить заголовок даты
                const messageDate = new Date(msg.timestamp);
                const messageDateKey = messageDate.toDateString();
                
                if (messageDateKey !== currentDateKey) {
                    const dateText = formatMessageDate(msg.timestamp);
                    const dateHeader = createDateHeader(dateText, messageDateKey);
                    messagesContainer.appendChild(dateHeader);
                    dateHeaders.set(messageDateKey, dateHeader);
                    currentDateKey = messageDateKey;
                }
                
                await addMessageToChat(messageWithText, isMyMessage, false);
            }
            
            lastMessageId = messages[messages.length - 1].id;
            
            // Сохраняем состояние чата
            activeChats[userId] = {
                messages: messagesContainer.innerHTML,
                lastMessageId: lastMessageId,
                messagesData: messages.map(msg => ({
                    id: msg.id,
                    text: msg.text,
                    sender_id: msg.sender_id,
                    timestamp: msg.timestamp,
                    isMedia: msg.is_media,
                    isVoiceMessage: msg.is_voice,
                    mediaType: msg.media_type,
                    duration: msg.duration,
                    is_encrypted: msg.is_encrypted,
                    encrypted_text: msg.encrypted_text
                }))
            };
            
            setTimeout(() => {
                initDateHeadersSystem();
                updateStickyDateHeaders();
                
                const messagesWrapper = document.getElementById('chat-messages-wrapper');
                if (messagesWrapper) {
                    messagesWrapper.scrollTop = messagesWrapper.scrollHeight;
                }
            }, 0);
            
            setupVoiceMessageHandlers();
        } else {
            messagesContainer.innerHTML = '<div class="no-messages">Нет сообщений</div>';
            lastMessageId = null;
            activeChats[userId] = {
                messages: messagesContainer.innerHTML,
                lastMessageId: null,
                messagesData: []
            };
        }
    } catch (error) {
        console.error('Error loading ZK chat history:', error);
        document.getElementById('chat-messages').innerHTML = 
            '<div class="error-message">Ошибка загрузки истории сообщений</div>';
    }
}








async function sendZKMediaMessage(file, caption = '') {
    if (!currentChatUserId || !userEncryptionKey) {
        throw new Error('Система безопасности не инициализирована');
    }
    
    try {
        // Показываем индикатор загрузки
        showMediaUploadProgress(`Шифрование: ${file.name}`, 10);
        
        // Ограничиваем размер файла
        const MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB
        if (file.size > MAX_FILE_SIZE) {
            hideMediaUploadProgress();
            alert(`Файл слишком большой. Максимальный размер: ${MAX_FILE_SIZE / 1024 / 1024}MB`);
            return false;
        }
        
        console.log('Начало шифрования файла:', file.name, 'размер:', file.size);
        
        // Обновляем прогресс
        updateMediaUploadProgress(`Шифрование: ${file.name}`, 30);
        
        // Шифруем файл с обработкой ошибок
        let encryptedMediaData;
        try {
            encryptedMediaData = await zkCrypto.encryptFile(file, userEncryptionKey);
        } catch (encryptError) {
            console.error('Ошибка шифрования:', encryptError);
            throw new Error(`Ошибка шифрования файла: ${encryptError.message}`);
        }
        
        console.log('Файл зашифрован, отправка на сервер...');
        
        // Обновляем прогресс
        updateMediaUploadProgress(`Отправка: ${file.name}`, 70);
        
        const fileType = file.type.startsWith('video/') ? 'video' : 'image';
        
        const result = await eel.send_media_message(
            localStorage.getItem('user_id'),
            currentChatUserId,
            encryptedMediaData,
            fileType,
            file.name,
            caption
        )();
        
        if (result.success) {
            console.log('Файл успешно отправлен');
            
            // Добавляем сообщение в чат
            const message = {
                id: result.message_id,
                sender_id: localStorage.getItem('user_id'),
                receiver_id: currentChatUserId,
                text: caption || (fileType === 'video' ? '[Видео]' : '[Фото]'),
                timestamp: result.timestamp,
                read: result.read,
                isMedia: true,
                mediaType: fileType,
                is_encrypted: true
            };
            
            await addMessageToChat(message, true, true);
            lastMessageId = message.id;
            
            // Обновляем кеш активного чата
            if (activeChats[currentChatUserId]) {
                const messagesContainer = document.getElementById('chat-messages');
                activeChats[currentChatUserId].messages = messagesContainer.innerHTML;
                activeChats[currentChatUserId].lastMessageId = lastMessageId;
                
                if (!activeChats[currentChatUserId].messagesData) {
                    activeChats[currentChatUserId].messagesData = [];
                }
                
                activeChats[currentChatUserId].messagesData.push({
                    id: message.id,
                    isMedia: true,
                    mediaType: fileType,
                    text: message.text,
                    filename: file.name
                });
            }
            
            // Обновляем прогресс до 100% и скрываем
            updateMediaUploadProgress(file.name, 100);
            setTimeout(hideMediaUploadProgress, 1000);
            
            return true; // ВАЖНО: возвращаем true при успехе
        } else {
            throw new Error(result.message || 'Ошибка при отправке файла');
        }
    } catch (error) {
        console.error('Error sending ZK media message:', error);
        hideMediaUploadProgress();
        
        if (error.message && error.message.includes('File too large')) {
            alert('Файл слишком большой. Максимальный размер: 10MB');
        } else if (error.message.includes('Maximum call stack')) {
            alert('Файл слишком большой для обработки. Попробуйте файл меньшего размера.');
        } else {
            alert('Ошибка при отправке файла: ' + (error.message || 'Неизвестная ошибка'));
        }
        return false; // ВАЖНО: возвращаем false при ошибке
    }
}

async function sendZKVoiceMessage(audioBlob, duration) {
    if (!currentChatUserId || !userEncryptionKey) return;
    
    try {
        const encryptedVoiceData = await zkCrypto.encryptFile(audioBlob, userEncryptionKey);
        
        const result = await eel.send_voice_message(
            localStorage.getItem('user_id'),
            currentChatUserId,
            encryptedVoiceData,
            duration
        )();
        
        if (result.success) {
            const message = {
                id: result.message_id,
                sender_id: localStorage.getItem('user_id'),
                receiver_id: currentChatUserId,
                text: '[Голосовое сообщение]',
                timestamp: result.timestamp,
                read: result.read,
                isVoiceMessage: true,
                duration: duration,
                is_encrypted: true
            };
            
            // Сохраняем зашифрованные данные в кеш для своих сообщений
            if (!activeChats[currentChatUserId]) {
                activeChats[currentChatUserId] = {
                    messages: '',
                    lastMessageId: null,
                    messagesData: []
                };
            }
            
            if (!activeChats[currentChatUserId].messagesData) {
                activeChats[currentChatUserId].messagesData = [];
            }
            
            activeChats[currentChatUserId].messagesData.push({
                id: message.id,
                voiceData: encryptedVoiceData, // Сохраняем зашифрованные данные
                duration: duration,
                isVoiceMessage: true,
                listened: true
            });
            
            addMessageToChat(message, true, true);
            lastMessageId = message.id;
            
            // Обновляем состояние чата
            const messagesContainer = document.getElementById('chat-messages');
            activeChats[currentChatUserId].messages = messagesContainer.innerHTML;
            activeChats[currentChatUserId].lastMessageId = lastMessageId;
            
            // Обновляем последнее сообщение на карточке
            updateLastMessageOnUserCard(currentChatUserId, 'Голосовое сообщение', true);
            
            // Устанавливаем обработчики для голосовых сообщений
            setupVoiceMessageHandlers();
        }
    } catch (error) {
        console.error('Error sending ZK voice message:', error);
    }
}

async function initializeUserKey(password) {
    try {
        const user_id = localStorage.getItem('user_id');
        if (!user_id) {
            throw new Error('User ID not found');
        }

        // Получаем соль с сервера
        const saltResponse = await eel.get_user_salt(user_id)();
        if (!saltResponse.success) {
            throw new Error('Не удалось получить соль пользователя');
        }

        // Сохраняем соль в localStorage
        localStorage.setItem('user_salt', saltResponse.salt);
        
        // Сохраняем пароль в sessionStorage
        sessionStorage.setItem('user_password', password);
        
        // Конвертируем соль
        const saltBytes = Uint8Array.from(atob(saltResponse.salt), c => c.charCodeAt(0));
        
        // Генерируем ключ
        userEncryptionKey = await zkCrypto.deriveKey(password, saltBytes);
        
        // Тестируем ключ
        const testResult = await testEncryptionKey();
        if (!testResult) {
            throw new Error('Ключ не работает');
        }

        localStorage.setItem('zk_initialized', 'true');
        console.log('ZK система инициализирована успешно');
        return true;
        
    } catch (error) {
        console.error('Error initializing user key:', error);
        // Очищаем при ошибке
        localStorage.removeItem('zk_initialized');
        localStorage.removeItem('user_salt');
        sessionStorage.removeItem('user_password');
        userEncryptionKey = null;
        return false;
    }
}




// Функция для тестирования ключа
async function testEncryptionKey() {
    try {
        // Создаем тестовое сообщение и пытаемся его зашифровать/расшифровать
        const testText = "test message";
        const encrypted = await zkCrypto.encryptText(testText, userEncryptionKey);
        const decrypted = await zkCrypto.decryptText(encrypted, userEncryptionKey);
        
        return decrypted === testText;
    } catch (error) {
        console.error('Key test failed:', error);
        return false;
    }
}






    </script>
<!-- Модальное окно удаления сообщения -->
<div class="modal-overlay hidden" id="delete-message-overlay"></div>
<div class="delete-message-modal hidden" id="delete-message-modal">
    <button class="modal-close-btn" id="delete-message-close-btn">×</button>
    <div class="delete-message-text">Удалить сообщение</div>
    <div class="delete-message-buttons">
        <button class="delete-message-button delete-for-all" id="delete-for-all-btn">Удалить у всех</button>
        <button class="delete-message-button delete-for-me" id="delete-for-me-btn">Только у меня</button>
    </div>
    <button class="delete-message-cancel" id="delete-message-cancel-btn">Отмена</button>
</div>






</body>
</html>