<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Мессенджер</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="top-container">
        <div class="top-row">
            <div class="menu-icon">☰</div>
            <div class="avatar-small" id="top-avatar"></div>
            <div class="search-container">
                <input type="text" class="search-input" placeholder="поиск">
                <span class="clear-btn">×</span>
            </div>
        </div>
        
        <div class="user-container" id="user-container"></div>
    </div>
    
    <div class="right-container">
        <div class="default-content" id="default-content">
            <img src="https://cdn-icons-png.flaticon.com/512/5757/5757765.png" alt="Выберите чат" class="default-image">
        </div>
        
        <div class="chat-container hidden" id="chat-container">
            <div class="chat-header">
                <div class="chat-username" id="chat-username"></div>
                <div class="chat-header-info">
                    <div class="chat-status" id="chat-status"></div>
                </div>
            </div>
            <div class="chat-messages" id="chat-messages">
                <div class="no-messages">Нет сообщений</div>
            </div>
            <div class="message-input-container">
                <div class="reply-container hidden" id="reply-container"></div>
                <div class="input-row">
                    <button class="voice-message-btn" id="voice-message-btn">
                        <img src="https://images.icon-icons.com/2066/PNG/512/mic_icon_125214.png" alt="Запись">
                    </button>
                    <div class="message-input-wrapper">
                        <input type="text" class="message-input" placeholder="Напишите сообщение..." id="message-input">
                        <div class="recording-container hidden" id="recording-container">
                            Запись: <span id="recording-time">0</span> сек.
                        </div>
                    </div>
                </div>
            </div>

    <!-- Контекстное меню -->
    <div class="context-menu" id="context-menu">
        <div class="context-menu-item add-friend hidden" id="context-menu-add">Добавить в друзья</div>
        <div class="context-menu-item remove-friend hidden" id="context-menu-remove">Удалить из друзей</div>
    </div>

    <!-- Модальное окно выхода -->
    <div class="modal-overlay hidden" id="logout-overlay"></div>
    <div class="logout-modal hidden" id="logout-modal">
        <button class="modal-close-btn" id="logout-close-btn">×</button>
        <div class="logout-text">Выйти из аккаунта</div>
        <div class="logout-buttons">
            <button class="logout-button logout-cancel" id="logout-cancel-btn">Отмена</button>
            <button class="logout-button logout-confirm" id="logout-confirm-btn">Выйти</button>
        </div>
    </div>

    <div class="message-context-menu hidden" id="message-context-menu">
        <div class="message-context-item" id="message-reply">Ответить</div>
        <div class="message-context-item" id="message-edit">Изменить</div>
        <div class="message-context-item" id="message-pin">Закрепить</div>
        <div class="message-context-item" id="message-delete">Удалить</div>
        <div class="message-context-item" id="message-forward">Переслать</div>
        <div class="message-context-item" id="message-copy">Копировать</div>
    </div>

    <script src="eel.js"></script>
    <script>
        let currentUser = null;
        let contextMenu = null;
        let contextMenuTarget = null;
        let currentChatUserId = null;
        let lastMessageId = null;
        let activeChats = {};
        let readStatusInterval = null;
        let statusUpdateInterval = null;
        let onlineStatusInterval = null;
        let mediaRecorder = null;
        let audioChunks = [];
        let recordingStartTime = 0;
        let audioContext = null;
        let analyser = null;
        let visualizationInterval = null;
        let currentPlayingAudio = null;
        let voiceMessagePlaying = false;
        let currentPlayingVoiceElement = null;
        let currentContextMessage = null; 
        let chatInputs = {};

        document.addEventListener('DOMContentLoaded', async function() {
            // Проверяем авторизацию
            const user_id = localStorage.getItem('user_id');
            if (!user_id) {
                window.location.href = 'login.html';
                return;
            }

            // Добавляем обработчик перед выгрузкой страницы
            window.addEventListener('beforeunload', function() {
                stopVoiceMessage();
                if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                    mediaRecorder.stop();
                }
            });

            // Запускаем отправку статуса онлайн
            startOnlineStatusUpdates();

            // Загружаем данные пользователя
            try {
                currentUser = await eel.get_user_data(user_id)();
                if (!currentUser) {
                    localStorage.removeItem('user_id');
                    window.location.href = 'login.html';
                    return;
                }
            } catch (error) {
                localStorage.removeItem('user_id');
                window.location.href = 'login.html';
                return;
            }

            // Устанавливаем аватар текущего пользователя
            document.getElementById('top-avatar').style.backgroundImage = 'url(https://cdn-icons-png.flaticon.com/512/3135/3135715.png)';

            // Инициализация поиска
            const searchInput = document.querySelector('.search-input');
            const clearBtn = document.querySelector('.clear-btn');
            
            searchInput.addEventListener('input', async function() {
                const searchTerm = this.value.trim();
                if (searchTerm.length > 0) {
                    const users = await eel.search_users(searchTerm, user_id)();
                    displaySearchResults(users);
                } else {
                    loadFriends();
                }
            });

            clearBtn.addEventListener('click', function() {
                searchInput.value = '';
                searchInput.focus();
                loadFriends();
            });

            // Инициализация контекстного меню
            contextMenu = document.getElementById('context-menu');
            document.addEventListener('click', closeContextMenu);
            document.getElementById('context-menu-add').addEventListener('click', handleAddFriend);
            document.getElementById('context-menu-remove').addEventListener('click', handleRemoveFriend);

            // Обработчики для меню выхода
            document.querySelector('.menu-icon').addEventListener('click', function() {
                document.getElementById('logout-overlay').classList.remove('hidden');
                document.getElementById('logout-modal').classList.remove('hidden');
            });

            document.getElementById('logout-close-btn').addEventListener('click', closeLogoutModal);
            document.getElementById('logout-cancel-btn').addEventListener('click', closeLogoutModal);
            document.getElementById('logout-overlay').addEventListener('click', closeLogoutModal);
            document.getElementById('logout-confirm-btn').addEventListener('click', function() {
                eel.update_last_online(localStorage.getItem('user_id'))();
                localStorage.removeItem('user_id');
                window.location.href = 'login.html';
            });

            // Обработчик нажатия ESC
            document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape') {
        // Если открыто модальное окно выхода - закрываем его
        if (!document.getElementById('logout-modal').classList.contains('hidden')) {
            closeLogoutModal();
            return;
        }
        
        // Если открыт чат - обрабатываем закрытие
        if (!document.getElementById('chat-container').classList.contains('hidden')) {
            // Сбрасываем currentChatUserId только если это не чат с самим собой
            if (currentChatUserId !== localStorage.getItem('user_id')) {
                currentChatUserId = null;
            }
            
            // Скрываем контейнер чата и показываем дефолтный экран
            document.getElementById('default-content').classList.remove('hidden');
            document.getElementById('chat-container').classList.add('hidden');
            
            // Убираем выделение активного чата
            document.querySelectorAll('.user-bar').forEach(el => {
                el.classList.remove('active-chat');
            });
            
            // Останавливаем воспроизведение голосовых сообщений
            stopVoiceMessage();
            currentPlayingAudio = null;
            voiceMessagePlaying = false;
            currentPlayingVoiceElement = null;
            
            // Очищаем интервалы
            if (readStatusInterval) {
                clearInterval(readStatusInterval);
                readStatusInterval = null;
            }
            if (statusUpdateInterval) {
                clearInterval(statusUpdateInterval);
                statusUpdateInterval = null;
            }
            
            // Для чата с самим собой сохраняем возможность открыть его снова
            if (currentChatUserId === localStorage.getItem('user_id')) {
                const selfChat = document.querySelector(`.user-bar[data-user-id="${currentChatUserId}"]`);
                if (selfChat) {
                    selfChat.classList.add('active-chat');
                }
            }
        }
    }
});

            // Обработчик клика по карточке пользователя
            document.addEventListener('click', function(e) {
                let userBar = e.target.closest('.user-bar');
                if (userBar) {
                    const userId = userBar.dataset.userId;
                    openChat(userId);
                    
                    document.querySelectorAll('.user-bar').forEach(el => {
                        el.classList.remove('active-chat');
                    });
                    userBar.classList.add('active-chat');
                }
            });
            
document.getElementById('message-input').addEventListener('keypress', async function(e) {
    if (e.key === 'Enter' && this.value.trim()) {
        await sendMessage(this.value.trim());
        this.value = '';
    }
});

            // Инициализация голосовых сообщений
            document.getElementById('voice-message-btn').addEventListener('mousedown', startRecording);
            document.getElementById('voice-message-btn').addEventListener('touchstart', startRecording);
            document.getElementById('voice-message-btn').addEventListener('mouseup', stopRecording);
            document.getElementById('voice-message-btn').addEventListener('touchend', stopRecording);
            document.getElementById('voice-message-btn').addEventListener('mouseleave', stopRecording);

            // Проверка новых сообщений каждые 2 секунды
            setInterval(checkForNewMessages, 2000);

            // Первоначальная загрузка друзей
            await loadFriends();
        });

        function startOnlineStatusUpdates() {
            updateOnlineStatus();
            onlineStatusInterval = setInterval(updateOnlineStatus, 30000);
            window.addEventListener('beforeunload', updateOnlineStatus);
        }

        async function updateOnlineStatus() {
            try {
                await eel.update_last_online(localStorage.getItem('user_id'))();
            } catch (error) {
                console.error('Ошибка обновления статуса онлайн:', error);
            }
        }

        function closeLogoutModal() {
            document.getElementById('logout-overlay').classList.add('hidden');
            document.getElementById('logout-modal').classList.add('hidden');
        }


        function closeChat(softClose = false) {
    document.getElementById('default-content').classList.remove('hidden');
    document.getElementById('chat-container').classList.add('hidden');
    document.querySelectorAll('.user-bar').forEach(el => {
        el.classList.remove('active-chat');
    });
    
    stopVoiceMessage();
    currentPlayingAudio = null;
    voiceMessagePlaying = false;
    currentPlayingVoiceElement = null;
    
    // Сбрасываем currentChatUserId только если это не softClose
    if (!softClose) {
        currentChatUserId = null;
    }
    
    lastMessageId = null;
    
    if (readStatusInterval) {
        clearInterval(readStatusInterval);
        readStatusInterval = null;
    }
    if (statusUpdateInterval) {
        clearInterval(statusUpdateInterval);
        statusUpdateInterval = null;
    }
}


async function checkAndRestoreReplyState() {
    if (!currentChatUserId) return;
    
    try {
        const replyState = await eel.get_reply_state(localStorage.getItem('user_id'), currentChatUserId)();
        if (replyState.success) {
            const message = await eel.get_message_data(replyState.message_id)();
            if (message) {
                const replyContainer = document.getElementById('reply-container');
                const isMyMessage = message.sender_id === localStorage.getItem('user_id');
                
                replyContainer.dataset.messageId = message.id;
                replyContainer.innerHTML = `
                    <div class="reply-header">
                        <div class="reply-author">${isMyMessage ? 'Вы' : document.getElementById('chat-username').textContent}</div>
                        <div class="reply-close">×</div>
                    </div>
                    <div class="reply-text">${message.text.length > 50 ? message.text.substring(0, 47) + '...' : message.text}</div>
                `;
                
                replyContainer.classList.remove('hidden');
                document.querySelector('.message-input-container').classList.add('expanded');
                
                // Обработчик закрытия ответа
                replyContainer.querySelector('.reply-close').addEventListener('click', async () => {
                    replyContainer.classList.add('hidden');
                    document.querySelector('.message-input-container').classList.remove('expanded');
                    await eel.clear_reply_state(localStorage.getItem('user_id'), currentChatUserId)();
                });
            }
        }
    } catch (error) {
        console.error('Ошибка восстановления состояния ответа:', error);
    }
}



async function openChat(userId) {
    // Сохраняем текущий текст перед переключением
    if (currentChatUserId) {
        const currentText = document.getElementById('message-input').value;
        if (currentText.trim()) {
            await eel.save_draft_message(localStorage.getItem('user_id'), currentChatUserId, currentText)();
        }
        chatInputs[currentChatUserId] = currentText;
    }
    
    // Если чат уже открыт, просто прокручиваем сообщения
    if (currentChatUserId === userId && !document.getElementById('chat-container').classList.contains('hidden')) {
        const messagesContainer = document.getElementById('chat-messages');
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
        return;
    }

    // Полностью останавливаем текущее воспроизведение
    stopVoiceMessage();
    currentPlayingAudio = null;
    voiceMessagePlaying = false;
    currentPlayingVoiceElement = null;
    
    // Сбрасываем контейнер ответа при переходе в другой чат
    const replyContainer = document.getElementById('reply-container');
    if (replyContainer && !replyContainer.classList.contains('hidden')) {
        replyContainer.classList.add('hidden');
        document.querySelector('.message-input-container').classList.remove('expanded');
    }
    
    if (readStatusInterval) clearInterval(readStatusInterval);
    if (statusUpdateInterval) clearInterval(statusUpdateInterval);

    currentChatUserId = userId;
    const user = await eel.get_user_data(userId)();
    
    if (user) {
        document.getElementById('default-content').classList.add('hidden');
        document.getElementById('chat-container').classList.remove('hidden');
        document.getElementById('chat-username').textContent = 
            userId === localStorage.getItem('user_id') ? 'Избранное' : user.nickname;
        await updateUserStatus();
        
        if (activeChats[userId]) {
            document.getElementById('chat-messages').innerHTML = activeChats[userId].messages;
            lastMessageId = activeChats[userId].lastMessageId;
            const messagesContainer = document.getElementById('chat-messages');
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
            
            // Обновляем индикаторы перед установкой обработчиков
            await updateListenIndicators();
            setupVoiceMessageHandlers();
        } else {
            await loadChatHistory(userId);
        }
        
        // Восстанавливаем текст из черновика или из кеша
        const draftText = await eel.get_draft_message(localStorage.getItem('user_id'), userId)();
        document.getElementById('message-input').value = draftText || chatInputs[userId] || '';
        
        // Восстанавливаем состояние ответа
        await checkAndRestoreReplyState();
        
        readStatusInterval = setInterval(updateReadStatus, 2000);
        updateReadStatus();
        
        statusUpdateInterval = setInterval(updateUserStatus, 5000);
        
        // Помечаем карточку пользователя как активную
        document.querySelectorAll('.user-bar').forEach(el => {
            el.classList.remove('active-chat');
        });
        const userCard = document.querySelector(`.user-bar[data-user-id="${userId}"]`);
        if (userCard) {
            userCard.classList.add('active-chat');
        }
    }
}


async function updateListenIndicators() {
    if (!currentChatUserId) return;
    
    try {
        const messages = Array.from(document.querySelectorAll('.message'))
            .map(el => ({id: el.dataset.id, isVoice: !!el.querySelector('.voice-message')}))
            .filter(msg => msg.id && msg.isVoice);
        
        if (messages.length === 0) return;
        
        // Проверяем localStorage
        const listenedMessages = JSON.parse(localStorage.getItem('listenedVoiceMessages') || '{}');
        
        // Сначала обновляем индикаторы на основе localStorage
        messages.forEach(msg => {
            const messageElement = document.querySelector(`.message[data-id="${msg.id}"]`);
            if (messageElement) {
                const voiceMessage = messageElement.querySelector('.voice-message');
                if (voiceMessage) {
                    const indicator = voiceMessage.querySelector('.listen-indicator');
                    if (indicator) {
                        const isMyMessage = messageElement.classList.contains('my-message');
                        
                        // Если сообщение уже прослушано (по данным localStorage), скрываем индикатор
                        if (listenedMessages[msg.id] && !isMyMessage) {
                            indicator.style.opacity = '0';
                        }
                    }
                }
            }
        });
        
        // Затем проверяем статус на сервере
        const listenedStatus = await eel.check_voice_messages_listened_status(messages.map(m => m.id))();
        
        messages.forEach(msg => {
            const messageElement = document.querySelector(`.message[data-id="${msg.id}"]`);
            if (messageElement) {
                const voiceMessage = messageElement.querySelector('.voice-message'); // Исправлено здесь
                if (voiceMessage) {
                    const indicator = voiceMessage.querySelector('.listen-indicator');
                    if (indicator) {
                        const isListened = listenedStatus[msg.id] || false;
                        const isMyMessage = messageElement.classList.contains('my-message');
                        
                        if (!isMyMessage && isListened) {
                            indicator.style.opacity = '0';
                            
                            // Сохраняем в localStorage
                            const listenedMessages = JSON.parse(localStorage.getItem('listenedVoiceMessages') || '{}');
                            listenedMessages[msg.id] = true;
                            localStorage.setItem('listenedVoiceMessages', JSON.stringify(listenedMessages));
                        }
                    }
                }
            }
        });
    } catch (error) {
        console.error('Ошибка при обновлении индикаторов прослушивания:', error);
    }
}


function setupVoiceMessageHandlers() {
    const voiceMessages = document.querySelectorAll('.voice-message');
    voiceMessages.forEach((voiceMessage) => {
        const playBtn = voiceMessage.querySelector('.play-voice-btn');
        playBtn.addEventListener('click', async () => {
            const isPlaying = voiceMessage.classList.contains('playing');
            const messageElement = voiceMessage.closest('.message');
            const isMyMessage = messageElement.classList.contains('my-message');
            
            if (isPlaying) {
                stopVoiceMessage(voiceMessage);
            } else {
                // Для своих сообщений используем данные из кеша
                if (isMyMessage) {
                    const messageId = messageElement.dataset.id;
                    const cachedMessage = activeChats[currentChatUserId]?.messagesData?.find(m => m.id === messageId);
                    if (cachedMessage && cachedMessage.voiceData) {
                        playVoiceMessage(cachedMessage.voiceData, voiceMessage, cachedMessage.duration);
                        return;
                    }
                }
                
                // Для чужих сообщений запрашиваем данные с сервера
                const messageId = messageElement.dataset.id;
                const response = await eel.get_voice_message(messageId)();
                if (response.success) {
                    playVoiceMessage(response.voice_data, voiceMessage, response.duration);
                } else {
                    alert('Не удалось загрузить голосовое сообщение');
                }
            }
        });
    });
}

        async function updateUserStatus() {
            if (!currentChatUserId) return;

            try {
                const user = await eel.get_user_data(currentChatUserId)();
                if (!user) return;

                const statusElement = document.getElementById('chat-status');
                const now = new Date();
                const lastOnline = new Date(user.last_online + ' UTC');

                const diffMinutes = Math.floor((now - lastOnline) / (1000 * 60));

                if (currentChatUserId === localStorage.getItem('user_id')) {
                    statusElement.textContent = '';
                    statusElement.classList.remove('online');
                } else if (diffMinutes < 5) {
                    statusElement.textContent = 'В сети';
                    statusElement.classList.add('online');
                } else {
                    statusElement.textContent = `Был(а) в сети ${formatTimeAgo(lastOnline)}`;
                    statusElement.classList.remove('online');
                }

                updateOnlineStatusInContacts();
            } catch (error) {
                console.error('Ошибка при обновлении статуса:', error);
            }
        }

        function updateOnlineStatusInContacts() {
            const userBars = document.querySelectorAll('.user-bar:not(.current-user)');
            userBars.forEach(async bar => {
                const userId = bar.dataset.userId;
                try {
                    const user = await eel.get_user_data(userId)();
                    if (user) {
                        const now = new Date();
                        const lastOnline = new Date(user.last_online + ' UTC');
                        const diffMinutes = Math.floor((now - lastOnline) / (1000 * 60));

                        const avatar = bar.querySelector('.avatar-medium');
                        if (diffMinutes < 5) {
                            avatar.classList.add('online');
                        } else {
                            avatar.classList.remove('online');
                        }
                    }
                } catch (error) {
                    console.error('Ошибка при обновлении статуса контакта:', error);
                }
            });
        }

        function formatTimeAgo(date) {
            const now = new Date();
            const diff = Math.floor((now - date) / 1000);
            
            if (diff < 60) return 'только что';
            if (diff < 3600) return `${Math.floor(diff / 60)} мин. назад`;
            if (diff < 86400) return `${Math.floor(diff / 3600)} ч. назад`;
            
            const days = Math.floor(diff / 86400);
            if (days === 1) return 'вчера';
            if (days < 7) return `${days} дн. назад`;
            
            return date.toLocaleDateString('ru-RU', {
                day: 'numeric',
                month: 'long',
                year: 'numeric'
            });
        }

        async function updateReadStatus() {
    if (!currentChatUserId) return;
    
    try {
        const myMessages = Array.from(document.querySelectorAll('.my-message'))
            .map(el => el.dataset.id)
            .filter(id => id);
        
        if (myMessages.length === 0) return;
        
        const readStatus = await eel.check_message_read_status(myMessages)();
        const listenedStatus = await eel.check_voice_messages_listened_status(myMessages)();
        
        for (const [messageId, isRead] of Object.entries(readStatus)) {
            const messageElement = document.querySelector(`.message[data-id="${messageId}"]`);
            if (messageElement) {
                // Обновляем статус прочтения только для текстовых сообщений
                const voiceMessage = messageElement.querySelector('.voice-message');
                if (!voiceMessage) {
                    const infoElement = messageElement.querySelector('.message-info');
                    if (infoElement) {
                        const timeElement = infoElement.querySelector('span');
                        if (timeElement) {
                            infoElement.innerHTML = `${timeElement.outerHTML}${isRead ? '✓✓' : '✓'}`;
                        }
                    }
                }
                
                // Обновляем индикатор прослушивания для голосовых сообщений
                if (voiceMessage) {
                    const indicator = voiceMessage.querySelector('.listen-indicator');
                    if (indicator) {
                        const isListened = listenedStatus[messageId] || false;
                        indicator.style.opacity = isListened ? '0' : '0.7';
                    }
                }
            }
        }
    } catch (error) {
        console.error('Ошибка при обновлении статуса прочтения:', error);
    }
}

async function loadChatHistory(userId) {
    try {
        const messages = await eel.get_chat_history(localStorage.getItem('user_id'), userId)();
        const messagesContainer = document.getElementById('chat-messages');
        messagesContainer.innerHTML = '';

        if (messages && messages.length > 0) {
            messages.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
            
            // Сохраняем данные сообщений
            const messagesData = [];
            
            messages.forEach(msg => {
                const isMyMessage = msg.sender_id === localStorage.getItem('user_id');
                addMessageToChat(msg, isMyMessage, false);
                
                if (msg.isVoiceMessage || msg.is_voice) {
                    messagesData.push({
                        id: msg.id,
                        voiceData: msg.voiceData,
                        duration: msg.duration,
                        isVoiceMessage: true
                    });
                }
            });
            
            lastMessageId = messages[messages.length - 1].id;
            
            activeChats[userId] = {
                messages: messagesContainer.innerHTML,
                lastMessageId: lastMessageId,
                messagesData: messagesData
            };
            
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
            setupVoiceMessageHandlers();
        } else {
            messagesContainer.innerHTML = '<div class="no-messages">Нет сообщений</div>';
            lastMessageId = null;
            
            activeChats[userId] = {
                messages: messagesContainer.innerHTML,
                lastMessageId: null,
                messagesData: []
            };
        }
    } catch (error) {
        console.error('Error loading chat history:', error);
    }
}
async function sendMessage(text) {
    if (!currentChatUserId || !text) return;
    
    try {
        const replyContainer = document.getElementById('reply-container');
        const isReplying = !replyContainer.classList.contains('hidden');
        const replyToId = isReplying ? replyContainer.dataset.messageId : null;
        
        const result = await eel.send_message(
            localStorage.getItem('user_id'),
            currentChatUserId,
            text,
            replyToId
        )();
        
        if (result.success) {
            const message = {
                id: result.message_id,
                sender_id: localStorage.getItem('user_id'),
                receiver_id: currentChatUserId,
                text: text,
                timestamp: result.timestamp,
                read: result.read,
                reply_to: result.reply_to,
                reply_text: result.reply_text,
                reply_sender_id: result.reply_sender_id
            };
            
            addMessageToChat(message, true, true);
            lastMessageId = message.id;
            
            if (activeChats[currentChatUserId]) {
                const messagesContainer = document.getElementById('chat-messages');
                activeChats[currentChatUserId] = {
                    messages: messagesContainer.innerHTML,
                    lastMessageId: lastMessageId
                };
            }
            
            // Обновляем последнее сообщение на карточке пользователя
            updateLastMessageOnUserCard(currentChatUserId, text, true);
            
            // Сбрасываем контейнер ответа и очищаем состояние в БД
            if (replyContainer) {
                replyContainer.classList.add('hidden');
                replyContainer.innerHTML = '';
                document.querySelector('.message-input-container').classList.remove('expanded');
                await eel.clear_reply_state(localStorage.getItem('user_id'), currentChatUserId)();
            }
            
            // Очищаем черновик после успешной отправки
            await eel.clear_draft_message(localStorage.getItem('user_id'), currentChatUserId)();
            chatInputs[currentChatUserId] = '';
        } else {
            console.error("Ошибка при отправке:", result.message);
        }
    } catch (error) {
        console.error('Error sending message:', error);
    }
}

        function updateLastMessageOnUserCard(userId, messageText, isMyMessage) {
            const userCard = document.querySelector(`.user-bar[data-user-id="${userId}"]`);
            if (!userCard) return;
            
            const lastMsgDiv = userCard.querySelector('.last-message');
            let displayText = messageText;
            
            if (displayText.length > 25) {
                displayText = displayText.substring(0, 22) + '...';
            }
            
            if (isMyMessage) {
                if (lastMsgDiv) {
                    lastMsgDiv.innerHTML = `<span class="you-indicator">Вы:</span> ${displayText}`;
                } else {
                    // Если элемента еще нет, создаем его
                    const contentWrapper = userCard.querySelector('.user-content-wrapper');
                    if (contentWrapper) {
                        const newLastMsgDiv = document.createElement('div');
                        newLastMsgDiv.className = 'last-message';
                        newLastMsgDiv.innerHTML = `<span class="you-indicator">Вы:</span> ${displayText}`;
                        contentWrapper.appendChild(newLastMsgDiv);
                    }
                }
            } else {
                if (lastMsgDiv) {
                    lastMsgDiv.textContent = displayText;
                } else {
                    const contentWrapper = userCard.querySelector('.user-content-wrapper');
                    if (contentWrapper) {
                        const newLastMsgDiv = document.createElement('div');
                        newLastMsgDiv.className = 'last-message';
                        newLastMsgDiv.textContent = displayText;
                        contentWrapper.appendChild(newLastMsgDiv);
                    }
                }
            }
        }

function addMessageToChat(message, isMyMessage, isNewMessage = true) {
    const messagesContainer = document.getElementById('chat-messages');
    
    if (messagesContainer.querySelector('.no-messages')) {
        messagesContainer.innerHTML = '';
    }
    
    let messageElement = document.querySelector(`.message[data-id="${message.id}"]`);
    
    if (!messageElement) {
        messageElement = document.createElement('div');
        messageElement.className = `message ${isMyMessage ? 'my-message' : 'their-message'} ${message.reply_to ? 'with-reply' : ''}`;
        messageElement.dataset.id = message.id;
        
        const date = new Date(message.timestamp);
        const timeString = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        const dateString = date.toLocaleDateString([], { day: 'numeric', month: 'short' });
        
        if (message.isVoiceMessage || message.is_voice) {
            const voiceElement = createVoiceMessageElement(message);
            messageElement.appendChild(voiceElement);
            
            if (message.read) {
                const indicator = voiceElement.querySelector('.listen-indicator');
                if (indicator) indicator.style.opacity = '0';
            }
        } else {
            let messageContent = '';
            
            // Если есть reply_to, добавляем блок с ответом
            if (message.reply_to) {
                const replyAuthor = message.reply_sender_id === localStorage.getItem('user_id') ? 'Вы' : 
                                    document.getElementById('chat-username').textContent;
                
                // Обрезаем текст, если он слишком длинный
                let replyText = message.reply_text;
                if (replyText.length > 50) {
                    replyText = replyText.substring(0, 47) + '...';
                }
                
                messageContent += `
                    <div class="reply-preview">
                        <div class="reply-author">${replyAuthor}</div>
                        <div class="reply-text">${replyText}</div>
                    </div>
                `;
            }
            
            messageContent += `
                <div class="message-text">${message.text}</div>
                <div class="message-info">
                    <span>${dateString} ${timeString}</span>
                    ${isMyMessage ? (message.read ? '✓✓' : '✓') : ''}
                </div>
            `;
            
            messageElement.innerHTML = messageContent;
        }
        
        messagesContainer.appendChild(messageElement);
        
        // Если это сообщение с ответом, увеличиваем его высоту
        if (message.reply_to) {
            messageElement.style.minHeight = '100px'; // Увеличиваем высоту
        }
    } else if (isMyMessage && !message.isVoiceMessage && !message.is_voice) {
        const infoElement = messageElement.querySelector('.message-info');
        if (infoElement) {
            const timeElement = infoElement.querySelector('span');
            if (timeElement) {
                infoElement.innerHTML = `${timeElement.outerHTML}${message.read ? '✓✓' : '✓'}`;
            }
        }
    }
    
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
    
    // Сохраняем состояние чата и данные сообщений
    if (currentChatUserId) {
        if (!activeChats[currentChatUserId]) {
            activeChats[currentChatUserId] = {
                messages: '',
                lastMessageId: null,
                messagesData: []
            };
        }
        
        activeChats[currentChatUserId].messages = messagesContainer.innerHTML;
        activeChats[currentChatUserId].lastMessageId = lastMessageId;
        
        if (isNewMessage && (message.isVoiceMessage || message.is_voice)) {
            activeChats[currentChatUserId].messagesData.push({
                id: message.id,
                voiceData: message.voiceData,
                duration: message.duration,
                isVoiceMessage: true
            });
        }
    }
}


        async function checkForNewMessages() {
            if (!currentChatUserId) return;
            
            try {
                const newMessages = await eel.check_new_messages(
                    localStorage.getItem('user_id'),
                    lastMessageId
                )();
                
                if (newMessages && newMessages.length > 0) {
                    newMessages.forEach(msg => {
                        if (msg.sender_id === currentChatUserId) {
                            addMessageToChat(msg, false, true);
                            // Обновляем последнее сообщение на карточке
                            updateLastMessageOnUserCard(currentChatUserId, msg.text, false);
                        }
                    });
                    
                    lastMessageId = newMessages[newMessages.length - 1].id;
                    
                    const messagesContainer = document.getElementById('chat-messages');
                    activeChats[currentChatUserId] = {
                        messages: messagesContainer.innerHTML,
                        lastMessageId: lastMessageId
                    };
                    
                    updateOnlineStatusInContacts();
                    
                    // Устанавливаем обработчики для новых голосовых сообщений
                    setupVoiceMessageHandlers();
                }
            } catch (error) {
                console.error('Error checking new messages:', error);
            }
        }
        
        async function loadFriends() {
            const user_id = localStorage.getItem('user_id');
            try {
                currentUser = await eel.get_user_data(user_id)();
                
                const container = document.getElementById('user-container');
                container.innerHTML = '';
                
                // Добавляем карточку текущего пользователя
                const selfCard = createUserCard({
                    user_id: user_id,
                    nickname: currentUser.nickname,
                    isCurrentUser: true
                });
                container.appendChild(selfCard);
                
                // Добавляем друзей
                if (currentUser.friends && currentUser.friends.length > 0) {
                    for (const friendId of currentUser.friends) {
                        const friend = await eel.get_user_data(friendId)();
                        if (friend) {
                            // Получаем последнее сообщение
                            const lastMessage = await eel.get_last_message(user_id, friendId)();
                            const friendCard = createUserCard({
                                user_id: friendId,
                                nickname: friend.nickname,
                                isFriend: true,
                                lastMessage: lastMessage
                            });
                            container.appendChild(friendCard);
                        }
                    }
                    
                    updateOnlineStatusInContacts();
                } else {
                    const noFriends = document.createElement('div');
                    noFriends.className = 'no-friends';
                    noFriends.textContent = 'У вас пока нет друзей. Найдите их через поиск!';
                    container.appendChild(noFriends);
                }
            } catch (error) {
                console.error('Error loading friends:', error);
            }
        }

        function createUserCard(userData) {
            const card = document.createElement('div');
            card.className = 'user-bar' + (userData.isCurrentUser ? ' current-user' : '');
            card.dataset.userId = userData.user_id;
            
            const avatar = document.createElement('div');
            avatar.className = 'avatar-medium';
            avatar.style.backgroundImage = 'url(https://cdn-icons-png.flaticon.com/512/3135/3135715.png)';
            
            const contentWrapper = document.createElement('div');
            contentWrapper.className = 'user-content-wrapper';
            
            const username = document.createElement('div');
            username.className = 'username';
            username.textContent = userData.isCurrentUser ? `Вы (${userData.nickname})` : userData.nickname;
            
            contentWrapper.appendChild(username);
            
            // Добавляем последнее сообщение, если оно есть
            if (userData.lastMessage && !userData.isCurrentUser) {
                const lastMsgDiv = document.createElement('div');
                lastMsgDiv.className = 'last-message';
                
                let messageText = userData.lastMessage.text;
                if (messageText.length > 25) {
                    messageText = messageText.substring(0, 22) + '...';
                }
                
                if (userData.lastMessage.sender_id === localStorage.getItem('user_id')) {
                    lastMsgDiv.innerHTML = `<span class="you-indicator">Вы:</span> ${messageText}`;
                } else {
                    lastMsgDiv.textContent = messageText;
                }
                
                contentWrapper.appendChild(lastMsgDiv);
            }
            
            card.appendChild(avatar);
            card.appendChild(contentWrapper);
            
            if (!userData.isCurrentUser) {
                card.addEventListener('contextmenu', function(e) {
                    e.preventDefault();
                    showContextMenu(e, userData);
                });
            }
            
            return card;
        }

        function showContextMenu(e, userData) {
            closeContextMenu();
            
            contextMenuTarget = userData.user_id;
            
            const addBtn = document.getElementById('context-menu-add');
            const removeBtn = document.getElementById('context-menu-remove');
            
            if (currentUser.friends.includes(userData.user_id)) {
                addBtn.classList.add('hidden');
                removeBtn.classList.remove('hidden');
            } else {
                addBtn.classList.remove('hidden');
                removeBtn.classList.add('hidden');
            }
            
            contextMenu.style.display = 'block';
            contextMenu.style.left = `${e.pageX}px`;
            contextMenu.style.top = `${e.pageY}px`;
        }

        function closeContextMenu() {
            if (contextMenu) {
                contextMenu.style.display = 'none';
            }
            contextMenuTarget = null;
        }

        async function handleAddFriend() {
            if (!contextMenuTarget) return;
            
            const user_id = localStorage.getItem('user_id');
            try {
                const response = await eel.add_friend(user_id, contextMenuTarget)();
                
                if (response.success) {
                    await loadFriends();
                }
                alert(response.message);
            } catch (error) {
                alert('Ошибка при добавлении в друзья');
                console.error('Error adding friend:', error);
            }
            
            closeContextMenu();
        }

        async function handleRemoveFriend() {
            if (!contextMenuTarget) return;
            
            const user_id = localStorage.getItem('user_id');
            try {
                const response = await eel.remove_friend(user_id, contextMenuTarget)();
                
                if (response.success) {
                    await loadFriends();
                    if (currentChatUserId === contextMenuTarget) {
                        closeChat();
                    }
                }
                alert(response.message);
            } catch (error) {
                alert('Ошибка при удалении из друзей');
                console.error('Error removing friend:', error);
            }
            
            closeContextMenu();
        }

        async function displaySearchResults(users) {
            const container = document.getElementById('user-container');
            container.innerHTML = '';
            
            if (users.length === 0) {
                const noResults = document.createElement('div');
                noResults.className = 'no-results';
                noResults.textContent = 'Ничего не найдено';
                container.appendChild(noResults);
                return;
            }
            
            for (const user of users) {
                const isFriend = currentUser.friends.includes(user.user_id);
                // Получаем последнее сообщение для результатов поиска
                const lastMessage = await eel.get_last_message(localStorage.getItem('user_id'), user.user_id)();
                const userCard = createUserCard({
                    user_id: user.user_id,
                    nickname: user.nickname,
                    isFriend: isFriend,
                    lastMessage: lastMessage
                });
                container.appendChild(userCard);
            }
            
            updateOnlineStatusInContacts();
        }

        // Функции для работы с голосовыми сообщениями
        async function startRecording(e) {
    e.preventDefault();
    
    try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        mediaRecorder = new MediaRecorder(stream);
        audioChunks = [];
        recordingStartTime = Date.now();
        
        mediaRecorder.ondataavailable = (e) => {
            if (e.data.size > 0) audioChunks.push(e.data);
        };
        
        mediaRecorder.onstop = async () => {
            const recordingTime = (Date.now() - recordingStartTime) / 1000;
            if (recordingTime < 0.5) {
                alert('Сообщение слишком короткое');
                return;
            }
            
            const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
            await sendVoiceMessage(audioBlob, recordingTime);
        };
        
        mediaRecorder.start(100);
        document.getElementById('message-input').classList.add('hidden');
        document.getElementById('recording-container').classList.remove('hidden');
        updateRecordingTime();
    } catch (error) {
        console.error('Ошибка записи:', error);
        alert('Не удалось получить доступ к микрофону');
    }
}

        function stopRecording(e) {
            e.preventDefault();
            
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
                mediaRecorder.stream.getTracks().forEach(track => track.stop());
                
                // Скрываем индикатор записи
                document.getElementById('recording-container').classList.add('hidden');
                document.getElementById('message-input').classList.remove('hidden');
            }
        }

        function updateRecordingTime() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                const recordingTime = ((Date.now() - recordingStartTime) / 1000).toFixed(1);
                document.getElementById('recording-time').textContent = recordingTime;
                setTimeout(updateRecordingTime, 100);
            }
        }

        async function sendVoiceMessage(audioBlob, duration, oldVisualizationData = null) {
    if (!currentChatUserId || !audioBlob) return;
    
    try {
        const reader = new FileReader();
        reader.readAsDataURL(audioBlob);
        
        reader.onload = async () => {
            const audioData = reader.result.split(',')[1];
            
            // Анализируем аудио и создаем визуализацию
            const visualizationData = await analyzeAudioAndCreateVisualization(audioBlob, duration);
            
            const result = await eel.send_voice_message(
                localStorage.getItem('user_id'),
                currentChatUserId,
                audioData,
                duration,
                visualizationData
            )();
            
            if (result.success) {
                const message = {
                    id: result.message_id,
                    sender_id: localStorage.getItem('user_id'),
                    receiver_id: currentChatUserId,
                    text: '[Голосовое сообщение]',
                    timestamp: result.timestamp,
                    read: result.read,
                    isVoiceMessage: true,
                    voiceData: audioData,
                    duration: duration,
                    visualization: visualizationData,
                    listened: currentChatUserId === localStorage.getItem('user_id')
                };
                
                addMessageToChat(message, true, true);
                lastMessageId = message.id;
                
                // Сохраняем состояние чата
                const messagesContainer = document.getElementById('chat-messages');
                activeChats[currentChatUserId] = {
                    messages: messagesContainer.innerHTML,
                    lastMessageId: lastMessageId,
                    messagesData: activeChats[currentChatUserId]?.messagesData || []
                };
                
                // Добавляем данные сообщения в кеш
                activeChats[currentChatUserId].messagesData.push({
                    id: message.id,
                    voiceData: message.voiceData,
                    duration: message.duration,
                    isVoiceMessage: true,
                    listened: message.listened,
                    visualization: visualizationData
                });
                
                // Обновляем последнее сообщение на карточке
                updateLastMessageOnUserCard(currentChatUserId, 'Голосовое сообщение', true);
                
                // Устанавливаем обработчики для голосовых сообщений
                setupVoiceMessageHandlers();
            }
        };
    } catch (error) {
        console.error('Ошибка отправки голосового сообщения:', error);
    }
}

function createVoiceMessageElement(message) {
    const voiceMessage = document.createElement('div');
    voiceMessage.className = 'voice-message';
    voiceMessage.dataset.messageId = message.id;
    
    const playBtn = document.createElement('button');
    playBtn.className = 'play-voice-btn';
    playBtn.innerHTML = '<img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTdnax9muCZwZsJujMzKiWx8tnQXgbwNaX39A&s" alt="Play">';
    
    const isMyMessage = message.sender_id === localStorage.getItem('user_id');
    
    // Проверяем localStorage перед установкой opacity
    const listenedMessages = JSON.parse(localStorage.getItem('listenedVoiceMessages') || '{}');
    const isListened = listenedMessages[message.id] || message.listened;
    
    // Создаем индикатор прослушивания
    const listenIndicator = document.createElement('div');
    listenIndicator.className = 'listen-indicator';
    
    if (isMyMessage) {
        listenIndicator.style.opacity = isListened ? '0' : '0.7';
    } else {
        listenIndicator.style.opacity = isListened ? '0' : '0.7';
    }
    
    voiceMessage.appendChild(listenIndicator);
    
    const visualizationContainer = document.createElement('div');
    visualizationContainer.className = 'voice-visualization-container';
    
    const visualization = document.createElement('div');
    visualization.className = 'voice-visualization';
    
    // Получаем данные визуализации из сообщения
    const visualizationData = message.visualization || Array(20).fill(0.3);
    
    // Создаем полоски визуализации
// Создаем полоски визуализации
for (let i = 0; i < 20; i++) {
    const bar = document.createElement('div');
    bar.className = 'voice-bar';
    bar.style.setProperty('--i', i);
    
    // Нормализуем значение (0-1) и масштабируем до высоты (3-30px)
    const height = Math.max(3, visualizationData[i] * 30);
    bar.style.height = `${height}px`;
    
    if (isMyMessage) {
        bar.style.backgroundColor = `rgba(0, 0, 0, ${0.2 + visualizationData[i] * 0.8})`;
    } else {
        bar.style.backgroundColor = `rgba(255, 255, 255, ${0.5 + visualizationData[i] * 0.5})`;
    }
    
    visualization.appendChild(bar);
}
    
    // Добавляем ползунок прогресса
    const progressBar = document.createElement('div');
    progressBar.className = 'voice-progress';
    progressBar.style.display = 'none';
    
    visualizationContainer.appendChild(visualization);
    visualizationContainer.appendChild(progressBar);
    
    const time = document.createElement('div');
    time.className = 'voice-time';
    time.dataset.duration = message.duration;
    time.textContent = `${message.duration.toFixed(1)} сек.`;
    
    voiceMessage.appendChild(playBtn);
    voiceMessage.appendChild(visualizationContainer);
    voiceMessage.appendChild(time);
    
    return voiceMessage;
}

function initMessageContextMenu() {
    console.log('initMessageContextMenu вызвана');
    const messageContextMenu = document.getElementById('message-context-menu');
    window.messageContextMenu = messageContextMenu; // Делаем глобальной для доступа из других функций
    let currentContextMessage = null;

    // Закрытие меню при клике вне его
    document.addEventListener('click', function(e) {
        if (messageContextMenu && !messageContextMenu.contains(e.target)) {
            messageContextMenu.classList.add('hidden');
        }
    });

    // Обработчик правого клика по сообщению
    document.addEventListener('contextmenu', function(e) {
        const messageElement = e.target.closest('.message');
        if (messageElement) {
            e.preventDefault();
            console.log('Правый клик по сообщению');
            currentContextMessage = messageElement;
            
            // Проверяем тип сообщения
            const isVoiceMessage = messageElement.querySelector('.voice-message') !== null;
            const isMyMessage = messageElement.classList.contains('my-message');
            
            // Показываем/скрываем пункты меню в зависимости от типа сообщения
            document.getElementById('message-edit').classList.toggle('hidden', !isMyMessage || isVoiceMessage);
            document.getElementById('message-delete').classList.toggle('hidden', !isMyMessage);
            document.getElementById('message-pin').classList.toggle('hidden', !isMyMessage || isVoiceMessage);
            document.getElementById('message-reply').classList.toggle('hidden', false);
            document.getElementById('message-forward').classList.toggle('hidden', false);
            document.getElementById('message-copy').classList.toggle('hidden', false);
            
            // Позиционируем меню
            const menuWidth = messageContextMenu.offsetWidth;
            const menuHeight = messageContextMenu.offsetHeight;
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;
            
            let left = e.clientX;
            let top = e.clientY;
            
            // Проверяем, чтобы меню не выходило за границы экрана
            if (left + menuWidth > windowWidth) {
                left = windowWidth - menuWidth - 5;
            }
            
            if (top + menuHeight > windowHeight) {
                top = windowHeight - menuHeight - 5;
            }
            
            messageContextMenu.style.left = `${left}px`;
            messageContextMenu.style.top = `${top}px`;
            messageContextMenu.style.display = 'block';
            messageContextMenu.classList.remove('hidden');
            
            // Убедимся, что меню поверх других элементов
            messageContextMenu.style.zIndex = '1000';
        }
    });

    // Общая функция для закрытия меню
    function closeMessageContextMenu() {
        if (messageContextMenu) {
            messageContextMenu.classList.add('hidden');
        }
    }

    // Обработчики пунктов меню
    document.getElementById('message-reply').addEventListener('click', function() {
        handleReply();
        closeMessageContextMenu();
    });
    
    document.getElementById('message-edit').addEventListener('click', function() {
        handleEdit();
        closeMessageContextMenu();
    });
    
    document.getElementById('message-pin').addEventListener('click', function() {
        handlePin();
        closeMessageContextMenu();
    });
    
    document.getElementById('message-delete').addEventListener('click', function() {
        handleDelete();
        closeMessageContextMenu();
    });
    
    document.getElementById('message-forward').addEventListener('click', function() {
        handleForward();
        closeMessageContextMenu();
    });
    
    document.getElementById('message-copy').addEventListener('click', function() {
        handleCopy();
        closeMessageContextMenu();
    });

async function handleReply() {
    if (!currentContextMessage) return;
    
    try {
        const messageText = currentContextMessage.querySelector('.message-text')?.textContent || '[Голосовое сообщение]';
        const isMyMessage = currentContextMessage.classList.contains('my-message');
        const replyContainer = document.getElementById('reply-container');
        const messageId = currentContextMessage.dataset.id;
        
        // Сохраняем состояние ответа в БД для текущего чата
        await eel.save_reply_state(
            localStorage.getItem('user_id'),
            currentChatUserId,
            messageId
        )();
        
        // Устанавливаем ID сообщения, на которое отвечаем
        replyContainer.dataset.messageId = messageId;
        
        replyContainer.innerHTML = `
            <div class="reply-header">
                <div class="reply-author">${isMyMessage ? 'Вы' : document.getElementById('chat-username').textContent}</div>
                <div class="reply-close">×</div>
            </div>
            <div class="reply-text">${messageText.length > 50 ? messageText.substring(0, 47) + '...' : messageText}</div>
        `;
        
        replyContainer.classList.remove('hidden');
        document.querySelector('.message-input-container').classList.add('expanded');
        
        // Обработчик закрытия ответа
        replyContainer.querySelector('.reply-close').addEventListener('click', async () => {
            replyContainer.classList.add('hidden');
            document.querySelector('.message-input-container').classList.remove('expanded');
            // Очищаем состояние ответа в БД для текущего чата
            await eel.clear_reply_state(localStorage.getItem('user_id'), currentChatUserId)();
        });
        
        const messageInput = document.getElementById('message-input');
        messageInput.focus();
        
    } catch (error) {
        console.error('Ошибка при обработке ответа:', error);
    }
}



    function handleEdit() {
        if (!currentContextMessage) {
            messageContextMenu.classList.add('hidden');
            return;
        }
        
        try {
            const messageId = currentContextMessage.dataset.id;
            const messageTextElement = currentContextMessage.querySelector('.message-text');
            const originalText = messageTextElement.textContent;
            
            // Создаем поле ввода для редактирования
            const input = document.createElement('input');
            input.type = 'text';
            input.value = originalText;
            input.className = 'edit-message-input';
            
            // Заменяем текст на поле ввода
            messageTextElement.replaceWith(input);
            input.focus();
            
            // Функция завершения редактирования
            const finishEditing = async (newText) => {
                if (newText && newText !== originalText) {
                    const result = await eel.edit_message(messageId, newText)();
                    if (!result.success) {
                        throw new Error(result.message || 'Не удалось изменить сообщение');
                    }
                    return newText;
                }
                return originalText;
            };
            
            // Обработчики событий
            const handleKeyDown = async (e) => {
                if (e.key === 'Enter') {
                    const newText = input.value.trim();
                    try {
                        const finalText = await finishEditing(newText);
                        messageTextElement.textContent = finalText;
                    } catch (error) {
                        alert(error.message);
                        messageTextElement.textContent = originalText;
                    }
                    cleanup();
                } else if (e.key === 'Escape') {
                    messageTextElement.textContent = originalText;
                    cleanup();
                }
            };
            
            const handleBlur = async () => {
                const newText = input.value.trim();
                try {
                    const finalText = await finishEditing(newText);
                    messageTextElement.textContent = finalText;
                } catch (error) {
                    alert(error.message);
                    messageTextElement.textContent = originalText;
                }
                cleanup();
            };
            
            const cleanup = () => {
                input.replaceWith(messageTextElement);
                input.removeEventListener('keydown', handleKeyDown);
                input.removeEventListener('blur', handleBlur);
                messageContextMenu.classList.add('hidden');
            };
            
            input.addEventListener('keydown', handleKeyDown);
            input.addEventListener('blur', handleBlur);
            
        } catch (error) {
            console.error('Ошибка при редактировании:', error);
            alert('Ошибка при редактировании сообщения');
            messageContextMenu.classList.add('hidden');
        }
    }

    function handlePin() {
        alert('Функция "Закрепить" будет реализована в будущем');
        messageContextMenu.classList.add('hidden');
    }

    eel.expose(get_current_user_id);
function get_current_user_id() {
    return localStorage.getItem('user_id');
}


    async function handleDelete() {
    if (!currentContextMessage) {
        messageContextMenu.classList.add('hidden');
        return;
    }
    
    if (!confirm('Вы уверены, что хотите удалить это сообщение?')) {
        messageContextMenu.classList.add('hidden');
        return;
    }
    
    try {
        const messageId = currentContextMessage.dataset.id;
        const result = await eel.delete_message(messageId)();
        
        if (result.success) {
            currentContextMessage.remove();
            
            // Обновляем кеш активных чатов
            if (currentChatUserId && activeChats[currentChatUserId]) {
                const messagesContainer = document.getElementById('chat-messages');
                activeChats[currentChatUserId].messages = messagesContainer.innerHTML;
                
                // Удаляем сообщение из messagesData если оно там есть
                if (activeChats[currentChatUserId].messagesData) {
                    activeChats[currentChatUserId].messagesData = 
                        activeChats[currentChatUserId].messagesData.filter(m => m.id !== messageId);
                }
            }
        } else {
            alert(result.message || 'Не удалось удалить сообщение');
        }
    } catch (error) {
        console.error('Ошибка при удалении:', error);
        alert('Ошибка при удалении сообщения');
    } finally {
        messageContextMenu.classList.add('hidden');
    }
}



    function handleForward() {
        alert('Функция "Переслать" будет реализована в будущем');
        messageContextMenu.classList.add('hidden');
    }

    function handleCopy() {
        if (!currentContextMessage) {
            messageContextMenu.classList.add('hidden');
            return;
        }
        
        try {
            const messageText = currentContextMessage.querySelector('.message-text').textContent;
            navigator.clipboard.writeText(messageText)
                .then(() => {
                    console.log('Текст скопирован в буфер обмена');
                })
                .catch(err => {
                    console.error('Ошибка копирования:', err);
                    alert('Не удалось скопировать текст');
                });
        } catch (error) {
            console.error('Ошибка при копировании:', error);
            alert('Ошибка при копировании текста');
        } finally {
            messageContextMenu.classList.add('hidden');
        }
    }
}

// Вызов инициализации после загрузки DOM
document.addEventListener('DOMContentLoaded', function() {
    initMessageContextMenu();
});

function playVoiceMessage(audioData, voiceMessageElement, duration) {
    // Если это уже текущее сообщение и оно на паузе - возобновляем
    if (currentPlayingVoiceElement === voiceMessageElement && currentPlayingAudio) {
        const currentTime = currentPlayingAudio.currentTime;
        currentPlayingAudio.play().then(() => {
            voiceMessageElement.classList.add('playing');
            voiceMessagePlaying = true;
            
            const playBtn = voiceMessageElement.querySelector('.play-voice-btn img');
            playBtn.src = 'https://png.klev.club/uploads/posts/2024-05/png-klev-club-uejr-p-ikonka-pauzi-png-30.png';
            
            const progressBar = voiceMessageElement.querySelector('.voice-progress');
            progressBar.style.display = 'block';
            
            const timeElement = voiceMessageElement.querySelector('.voice-time');
            const startTime = Date.now() - (currentTime * 1000);
            
            // Функция обновления прогресса
            const updateProgress = () => {
                if (!voiceMessagePlaying) return;
                
                const currentPos = currentPlayingAudio.currentTime;
                const progressPercent = (currentPos / duration) * 100;
                
                // Обновляем позицию ползунка
                progressBar.style.left = `${progressPercent}%`;
                
                // Обновляем анимацию полосок
                const bars = voiceMessageElement.querySelectorAll('.voice-bar');
                bars.forEach((bar, i) => {
                    const barPos = (i / bars.length) * 100;
                    if (barPos < progressPercent) {
                        bar.style.opacity = '0.7';
                    } else {
                        bar.style.opacity = '0.3';
                    }
                });
                
                timeElement.textContent = `${currentPos.toFixed(1)} / ${duration.toFixed(1)} сек.`;
                
                if (currentPos >= duration) {
                    handleVoiceMessagePlayed(voiceMessageElement);
                } else if (voiceMessagePlaying) {
                    requestAnimationFrame(updateProgress);
                }
            };
            
            updateProgress();
        }).catch(error => {
            console.error('Ошибка возобновления:', error);
        });
        return;
    }

    // Останавливаем текущее воспроизведение, если есть
    if (currentPlayingAudio) {
        currentPlayingAudio.pause();
        currentPlayingAudio = null;
        
        if (currentPlayingVoiceElement) {
            stopVoiceMessage(currentPlayingVoiceElement, true);
        }
    }

    // Устанавливаем класс playing для текущего элемента
    voiceMessageElement.classList.add('playing');
    voiceMessagePlaying = true;
    currentPlayingVoiceElement = voiceMessageElement;
    
    const audio = new Audio(`data:audio/wav;base64,${audioData}`);
    currentPlayingAudio = audio;
    
    const playBtn = voiceMessageElement.querySelector('.play-voice-btn img');
    playBtn.src = 'https://png.klev.club/uploads/posts/2024-05/png-klev-club-uejr-p-ikonka-pauzi-png-30.png';
    
    const progressBar = voiceMessageElement.querySelector('.voice-progress');
    progressBar.style.display = 'block';
    progressBar.style.left = '0%';
    
    const timeElement = voiceMessageElement.querySelector('.voice-time');
    timeElement.dataset.duration = duration;
    
    // Получаем родительский элемент сообщения
    const messageElement = voiceMessageElement.closest('.message');
    const isMyMessage = messageElement.classList.contains('my-message');
    
    // Функция обновления прогресса
    const updateProgress = () => {
        if (!voiceMessagePlaying) return;
        
        const currentPos = audio.currentTime;
        const progressPercent = (currentPos / duration) * 100;
        
        // Обновляем позицию ползунка
        progressBar.style.left = `${progressPercent}%`;
        
        // Обновляем анимацию полосок
        const bars = voiceMessageElement.querySelectorAll('.voice-bar');
        bars.forEach((bar, i) => {
            const barPos = (i / bars.length) * 100;
            if (barPos < progressPercent) {
                bar.style.opacity = '0.7';
            } else {
                bar.style.opacity = '0.3';
            }
        });
        
        timeElement.textContent = `${currentPos.toFixed(1)} / ${duration.toFixed(1)} сек.`;
        
        if (currentPos >= duration) {
            handleVoiceMessagePlayed(voiceMessageElement);
        } else if (voiceMessagePlaying) {
            requestAnimationFrame(updateProgress);
        }
    };
        
    // Обработчики событий аудио
    audio.addEventListener('ended', () => {
        handleVoiceMessagePlayed(voiceMessageElement);
    });
    
    audio.addEventListener('pause', () => {
        voiceMessagePlaying = false;
        // При паузе сохраняем текущее состояние прогресса
        const currentTime = audio.currentTime;
        const progressPercent = (currentTime / duration) * 100;
        progressBar.style.left = `${progressPercent}%`;
        timeElement.textContent = `${currentTime.toFixed(1)} / ${duration.toFixed(1)} сек.`;
        
        // Меняем иконку на "play"
        playBtn.src = 'https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTdnax9muCZwZsJujMzKiWx8tnQXgbwNaX39A&s';
    });
    
    audio.addEventListener('error', () => {
        stopVoiceMessage(voiceMessageElement, true);
        alert('Ошибка воспроизведения голосового сообщения');
    });
    
    // Запускаем воспроизведение
    audio.play().then(() => {
        updateProgress();
    }).catch(error => {
        console.error('Ошибка воспроизведения:', error);
        stopVoiceMessage(voiceMessageElement, true);
    });
}

function handleVoiceMessagePlayed(voiceMessageElement) {
    const messageElement = voiceMessageElement.closest('.message');
    const messageId = messageElement?.dataset.id;
    const timeElement = voiceMessageElement.querySelector('.voice-time');
    const duration = parseFloat(timeElement.dataset.duration) || 0;
    
    // Скрываем ползунок
    const progressBar = voiceMessageElement.querySelector('.voice-progress');
    progressBar.style.display = 'none';
    
    timeElement.textContent = `${duration.toFixed(1)} сек.`;
    stopVoiceMessage(voiceMessageElement, true);
    
    const isMyMessage = messageElement.classList.contains('my-message');
    const indicator = voiceMessageElement.querySelector('.listen-indicator');
    
    // Для своих сообщений НЕ изменяем состояние индикатора
    if (!isMyMessage && indicator) {
        indicator.style.opacity = '0';
        
        // Сохраняем в localStorage, что сообщение прослушано
        if (messageId) {
            const listenedMessages = JSON.parse(localStorage.getItem('listenedVoiceMessages') || '{}');
            listenedMessages[messageId] = true;
            localStorage.setItem('listenedVoiceMessages', JSON.stringify(listenedMessages));
        }
    }
    
    // Обновляем состояние в кеше только для чужих сообщений
    if (!isMyMessage && currentChatUserId && activeChats[currentChatUserId]?.messagesData) {
        const messageIndex = activeChats[currentChatUserId].messagesData.findIndex(m => m.id === messageId);
        if (messageIndex !== -1) {
            activeChats[currentChatUserId].messagesData[messageIndex].listened = true;
        }
    }
    
    // Отправляем на сервер информацию о прослушивании (только для чужих сообщений)
    if (messageId && !isMyMessage) {
        const userId = localStorage.getItem('user_id');
        eel.mark_voice_message_as_listened(messageId, userId)();
    }
}

async function analyzeAudioAndCreateVisualization(audioBlob, duration) {
    try {
        // Создаем аудиоконтекст
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const arrayBuffer = await audioBlob.arrayBuffer();
        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
        
        // Получаем данные канала (берем первый канал)
        const channelData = audioBuffer.getChannelData(0);
        const sampleRate = audioBuffer.sampleRate;
        
        // Количество полосок
        const barsCount = 20;
        // Длительность одного сегмента в секундах
        const segmentDuration = duration / barsCount;
        // Количество семплов в одном сегменте
        const samplesPerSegment = Math.floor(segmentDuration * sampleRate);
        
        const visualizationData = [];
        
        // Анализируем каждый сегмент
        for (let i = 0; i < barsCount; i++) {
            const startSample = i * samplesPerSegment;
            const endSample = Math.min((i + 1) * samplesPerSegment, channelData.length);
            
            let maxAmplitude = 0;
            
            // Находим максимальную амплитуду в сегменте
            for (let j = startSample; j < endSample; j++) {
                const amplitude = Math.abs(channelData[j]);
                if (amplitude > maxAmplitude) {
                    maxAmplitude = amplitude;
                }
            }
            
            // Нормализуем значение от 0 до 1
            visualizationData.push(maxAmplitude);
        }
        
        return visualizationData;
    } catch (error) {
        console.error('Ошибка анализа аудио:', error);
        // Возвращаем массив нулей в случае ошибки
        return Array(20).fill(0);
    }
}



// Обработчики для пунктов меню
document.getElementById('message-reply').addEventListener('click', () => {
    if (currentContextMessage) {
        const messageText = currentContextMessage.querySelector('.message-text').textContent;
        const messageInput = document.getElementById('message-input');
        messageInput.value = `Ответ на: "${messageText}" `;
        messageInput.focus();
    }
    messageContextMenu.classList.add('hidden');
});

document.getElementById('message-edit').addEventListener('click', async () => {
    if (currentContextMessage) {
        const messageId = currentContextMessage.dataset.id;
        const messageText = currentContextMessage.querySelector('.message-text');
        const originalText = messageText.textContent;
        
        // Создаем поле ввода для редактирования
        const input = document.createElement('input');
        input.type = 'text';
        input.value = originalText;
        input.className = 'edit-message-input';
        
        // Заменяем текст на поле ввода
        messageText.replaceWith(input);
        input.focus();
        
        // Обработчик завершения редактирования
        const handleEdit = async (e) => {
            if (e.key === 'Enter' || e.type === 'blur') {
                const newText = input.value.trim();
                if (newText && newText !== originalText) {
                    try {
                        const result = await eel.edit_message(messageId, newText)();
                        if (result.success) {
                            messageText.textContent = newText;
                        } else {
                            alert(result.message);
                            messageText.textContent = originalText;
                        }
                    } catch (error) {
                        console.error('Ошибка редактирования:', error);
                        messageText.textContent = originalText;
                    }
                } else {
                    messageText.textContent = originalText;
                }
                
                input.replaceWith(messageText);
                input.removeEventListener('keydown', handleEdit);
                input.removeEventListener('blur', handleEdit);
            } else if (e.key === 'Escape') {
                messageText.textContent = originalText;
                input.replaceWith(messageText);
                input.removeEventListener('keydown', handleEdit);
                input.removeEventListener('blur', handleEdit);
            }
        };
        
        input.addEventListener('keydown', handleEdit);
        input.addEventListener('blur', handleEdit);
    }
    messageContextMenu.classList.add('hidden');
});

document.getElementById('message-pin').addEventListener('click', () => {
    if (currentContextMessage) {
        alert('Функция "Закрепить" будет реализована в будущем');
    }
    messageContextMenu.classList.add('hidden');
});

document.getElementById('message-delete').addEventListener('click', async () => {
    if (currentContextMessage) {
        if (confirm('Вы уверены, что хотите удалить это сообщение?')) {
            const messageId = currentContextMessage.dataset.id;
            try {
                const result = await eel.delete_message(messageId)();
                if (result.success) {
                    currentContextMessage.remove();
                } else {
                    alert(result.message);
                }
            } catch (error) {
                console.error('Ошибка удаления:', error);
                alert('Ошибка при удалении сообщения');
            }
        }
    }
    messageContextMenu.classList.add('hidden');
});

document.getElementById('message-forward').addEventListener('click', () => {
    if (currentContextMessage) {
        alert('Функция "Переслать" будет реализована в будущем');
    }
    messageContextMenu.classList.add('hidden');
});

document.getElementById('message-copy').addEventListener('click', () => {
    if (currentContextMessage) {
        const messageText = currentContextMessage.querySelector('.message-text').textContent;
        navigator.clipboard.writeText(messageText)
            .then(() => {
                // Можно добавить уведомление о успешном копировании
                console.log('Текст скопирован');
            })
            .catch(err => {
                console.error('Ошибка копирования:', err);
            });
    }
    messageContextMenu.classList.add('hidden');
});

// Стиль для поля редактирования
const style = document.createElement('style');
style.textContent = `
    .edit-message-input {
        width: 100%;
        padding: 5px;
        border: 1px solid #4CAF50;
        border-radius: 4px;
        font-size: 14px;
    }
`;
document.head.appendChild(style);  

function stopVoiceMessage(voiceMessageElement = null, reset = false) {
    if (!voiceMessageElement) {
        voiceMessageElement = currentPlayingVoiceElement;
    }
    
    if (currentPlayingAudio) {
        currentPlayingAudio.pause();
        if (reset) {
            currentPlayingAudio.currentTime = 0;
            currentPlayingAudio = null;
        }
        voiceMessagePlaying = false;
    }
    
    if (voiceMessageElement) {
        voiceMessageElement.classList.remove('playing');
        const playBtn = voiceMessageElement.querySelector('.play-voice-btn img');
        playBtn.src = 'https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTdnax9muCZwZsJujMzKiWx8tnQXgbwNaX39A&s';
        
        const timeElement = voiceMessageElement.querySelector('.voice-time');
        const duration = parseFloat(timeElement.dataset.duration) || 0;
        const progressBar = voiceMessageElement.querySelector('.voice-progress');
        
        if (reset) {
            progressBar.style.display = 'none';
            timeElement.textContent = `${duration.toFixed(1)} сек.`;
            currentPlayingVoiceElement = null;
        } else {
            // При паузе сохраняем текущее состояние прогресса
            const currentTime = currentPlayingAudio?.currentTime || 0;
            const progressPercent = (currentTime / duration) * 100;
            progressBar.style.left = `${progressPercent}%`;
            timeElement.textContent = `${currentTime.toFixed(1)} / ${duration.toFixed(1)} сек.`;
        }
    }
}
    </script>
</body>
</html>